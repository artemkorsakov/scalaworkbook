// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Абстрактные классы",
      "url": "/scalaworkbook/docs/modeling/abstract-class.html",
      "content": "Абстрактные классы Когда необходимо написать класс, но известно, что в нем будут абстрактные члены, можно создать либо trait, либо абстрактный класс. В большинстве случаев желательно использовать trait, но исторически сложилось так, что было две ситуации, когда предпочтительнее использование абстрактного класса: необходимо создать базовый класс, который принимает аргументы конструктора код будет вызван из Java-кода Базовый класс, который принимает аргументы конструктора До Scala 3, когда базовому классу нужно было принимать аргументы конструктора, он объявлялся как абстрактный класс: abstract class Pet(name: String): def greeting: String def age: Int override def toString = s\"My name is $name, I say $greeting, and I’m $age\" class Dog(name: String, age: Int) extends Pet(name): val greeting = \"Woof\" val d = Dog(\"Fido\", 1) Однако в Scala 3 trait-ы могут иметь параметры, так что теперь в той же ситуации можно использовать trait-ы: trait Pet(name: String): def greeting: String def age: Int override def toString = s\"My name is $name, I say $greeting, and I’m $age\" class Dog(name: String, var age: Int) extends Pet(name): val greeting = \"Woof\" val d = Dog(\"Fido\", 1) trait-ы более гибки в составлении, потому что можно смешивать (наследовать) несколько trait-ов, но только один класс. В большинстве случаев trait-ы следует предпочитать классам и абстрактным классам. Правило выбора состоит в том, чтобы использовать классы всякий раз, когда необходимо создавать экземпляры определенного типа, и trait-ы, когда желательно разложить и повторно использовать поведение. References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Abstract Factory",
      "url": "/scalaworkbook/design-patterns/abstract-factory.html",
      "content": "Abstract Factory Описание Цель паттерна: Предоставить интерфейс для создания семейств связанных или зависимых объектов без указания конкретных классов. Допустим, необходимо создать библиотеку графического интерфейса, которая должна работать на разных платформах, таких как Microsoft Windows или Mac OSX. Чтобы поддерживать собственный внешний вид на каждой платформе, например, для графического окна, сохраняя при этом переносимость клиентского кода между платформами, клиентам должен быть доступен только интерфейс окна. Обычно окно состоит из нескольких виджетов, некоторые из которых могут зависеть от конкретной платформы. Что именно и как создается конкретное окно, абстрагируется от клиентского кода абстрактной фабрикой. Это позволяет изменять код создания объектов без изменения клиентского кода. Поскольку клиент не знает о конкретных классах, в клиенте не вводятся зависимости от платформы. Казалось бы, можно изменить реализации окна и связанных с ним виджетов и предоставить новые, если они соответствуют абстрактному интерфейсу. Обычно фабрика создает семейство продуктов, в наших настройках графического интерфейса это могут быть окна, меню и т.д. Важной проблемой является то, что мы не должны смешивать классы, зависящие от платформы, так как это может привести к ошибкам во время выполнения. Конкретные фабрики чаще всего реализуются в виде singleton-ов. Диаграмма Пример trait WindowFactory определяет интерфейс для фабрики. Он содержит типы aWindow и aScrollbar. Эти типы сверху ограничены trait-ми и должны быть доработаны на конкретных фабриках. Код создания экземпляра, общий для конкретных фабрик, может быть повторно использован в подклассах, если они ссылаются только на определенные абстрактные типы. Абстрактные продукты - это оба trait-а, вложенных в фабричный признак, то есть Window и Scrollbar. Любой конкретный продукт должен расширяться их. Абстрактные фабричные методы createWindow и createScrollbar скрывают фактический код создания экземпляра от клиентов. trait WindowFactory: type aWindow &lt;: Window type aScrollbar &lt;: Scrollbar def createWindow(s: aScrollbar): aWindow def createScrollbar(): aScrollbar trait Window(s: aScrollbar) trait Scrollbar Ниже показано, как можно расширить нашу абстрактную фабрику с помощью конкретной фабрики. Конкретная фабрика в данном примере - это объект singleton, содержащий protected nested классы. Это конкретная реализация. Поскольку они protected, они скрыты от клиентов. object VistaFactory extends WindowFactory: type aWindow = VistaWindow type aScrollbar = VistaScrollbar def createWindow(s: aScrollbar) = VistaWindow(s) def createScrollbar() = new VistaScrollbar val scrollbar: aScrollbar = new VistaScrollbar val window: aWindow = VistaWindow(scrollbar) protected class VistaWindow(s: aScrollbar) extends Window(s) protected class VistaScrollbar extends Scrollbar По соображениям технического обслуживания мы можем быть не заинтересованы в том, чтобы фактический исходный код, реализующий классы продуктов, находился внутри фабрики. Используя явный тип self, можно выразить зависимость, существующую между модулем, предоставляющим классы продуктов, и любой WindowFactory. Это позволяет расширить Window и Scrollbar в модуле, где в противном случае они не были бы видны в области видимости. trait VistaWidgets { self: WindowFactory =&gt; protected class VistaWindow(s: aScrollbar) extends Window(s) protected class VistaScrollbar extends Scrollbar } Вложенность классов полезна для инкапсуляции определенных типов. Фабрика - это, по сути, просто признак пространства имен или репозиторий для конкретных продуктов. Абстрактные типы позволяют выразить взаимозависимость продуктов. Это дает статические гарантии того, что продукты с разных фабрик не могут быть смешаны. Кроме того, они расширяют возможности повторного использования в подклассах фабрики. References: Scala &amp; Design Patterns by Frederik Skeel Løkke Wikipedia"
    } ,    
    {
      "title": "Абстракции",
      "url": "/scalaworkbook/docs/abstractions.html",
      "content": "Контекстуальные абстракции Background Implicits в Scala 2 были главной отличительной особенностью дизайна. Это основной способ абстрагироваться от контекста. Implicits представляют собой единую парадигму с большим разнообразием вариантов использования, среди которых: реализация type classes установление контекста внедрение зависимости (dependency injection) выражение возможностей вычисление новых типов и доказательство взаимосвязей между ними С тех пор этому примеру последовали другие языки, например, traits в Rust или protocol extensions в Swift. Предложения по дизайну также представлены для Kotlin в качестве разрешения зависимостей во время компиляции, для C# в качестве Shapes и Extensions или для F# в качестве Traits. Implicits также являются общей особенностью тех, кто доказывает теоремы, таких как Coq или Agda. Несмотря на то, что в этих проектах используется разная терминология, все они являются вариантами основной идеи вывода терминов (term inference): учитывая тип, компилятор синтезирует “канонический” термин, который имеет этот тип. Редизайн Scala 3 включает в себя переработку контекстных абстракций. Хотя эти концепции постепенно “открывались” в Scala 2, теперь они хорошо известны и понятны, и редизайн использует эти знания. Дизайн Scala 3 фокусируется на намерении, а не на механизме. Вместо того, чтобы предлагать одну очень мощную функцию имплицитов, Scala 3 предлагает несколько функций, ориентированных на варианты использования: Отвлечение контекстной информации. Предложения Using позволяют программистам абстрагироваться от информации, которая доступна в контексте вызова и должна передаваться неявно. В качестве улучшения по сравнению со Scala 2 подразумевается, что предложения using могут быть указаны по типу, освобождая сигнатуры функций от имен переменных, на которые никогда не ссылаются явно. Предоставление экземпляров Type-class. Given экземпляры позволяют программистам определять каноническое значение определенного типа. Это делает программирование с type-classes более простым без утечек деталей реализации. Расширение классов. В Scala 2 методы расширения должны были кодироваться с использованием неявных преобразований или неявных классов. Напротив, в Scala 3 методы расширения теперь встроены непосредственно в язык, что приводит к улучшению сообщений об ошибках и улучшению вывода типов. Неявное преобразование одного типа в другой. Неявное преобразование было переработано с нуля как экземпляры type-class Conversion. Контекстные абстракции более высокого порядка. Совершенно новая функция контекстных функций делает контекстные абстракции объектами первого класса. Они являются важным инструментом для авторов библиотек и позволяют выражать лаконичный DSL. Полезная обратная связь от компилятора. Если компилятор не может разрешить неявный параметр, теперь он предлагает предложения по импорту, которые могут решить проблему. Преимущества Эти изменения в Scala 3 обеспечивают лучшее разделение вывода терминов от остального языка: существует единственный способ определить данные существует единственный способ ввести неявные параметры и аргументы существует отдельный способ импорта givens, который не позволяет им прятаться в море обычного импорта существует единственный способ определить неявное преобразование, которое четко обозначено как таковое и не требует специального синтаксиса К преимуществам этих изменений относятся: новый дизайн позволяет избежать взаимодействия функций и делает язык более согласованным implicits становятся более легкими для изучения и более сложными для злоупотреблений значительно улучшается ясность 95% программ Scala, использующих implicits В этой главе в следующих разделах представлены многие из этих новых функций. References: Scala3 book, Contextual Abstractions Scala 3 Reference"
    } ,    
    {
      "title": "Анонимные функции",
      "url": "/scalaworkbook/docs/functions/anonymous.html",
      "content": "Анонимные функции Анонимная функция, также называемая лямбда, представляет собой блок кода, который передается в качестве аргумента функции более высокого порядка. Википедия определяет анонимную функцию как “определение функции, не привязанное к идентификатору”. Например, возьмем коллекцию: val ints = List(1, 2, 3) Можно создать новый список, удвоив каждый элемент в целых числах, используя метод map класса List и свою пользовательскую анонимную функцию: val doubledInts = ints.map(_ * 2) // doubledInts: List[Int] = List(2, 4, 6) Как видно из комментария, doubleInts содержит список List(2, 4, 6). В этом примере анонимной функцией является часть кода: _ * 2. Это сокращенный способ сказать: “Умножить данный элемент на 2”. Более длинные формы Более длинными формами предыдущего примера являются следующие функции: val doubledInts = ints.map((i: Int) =&gt; i * 2) val doubledInts = ints.map((i) =&gt; i * 2) val doubledInts = ints.map(i =&gt; i * 2) Все эти строки имеют одно и то же значение: удваивайте каждый элемент в ints, чтобы создать новый список, doubledInts. Сокращение анонимных функций Если необходимо явно указать анонимную функцию, можно использовать эту длинную форму: val doubledInts = ints.map((i: Int) =&gt; i * 2) Анонимная функция в этом выражении такова: (i: Int) =&gt; i * 2 Если незнаком данный синтаксис, то можно воспринимать символ =&gt; как преобразователь, потому что выражение преобразует список параметров в левой части символа (переменная Int с именем i) в новый результат, используя алгоритм справа от символа =&gt; (в данном случае выражение, которое удваивает значение Int). Сокращение выражения Эту длинную форму можно сократить: val doubledInts = ints.map((i: Int) =&gt; i * 2) Поскольку компилятор Scala из данных в ints может сделать вывод, что i является Int, объявление Int можно удалить: val doubledInts = ints.map((i) =&gt; i * 2) Поскольку аргумент всего один, скобки вокруг параметра i можно не указывать: val doubledInts = ints.map(i =&gt; i * 2) Поскольку Scala позволяет использовать символ _ вместо имени переменной, если в функции только один параметр, код можно упростить еще больше: val doubledInts = ints.map(_ * 2) Ещё короче В других примерах можно еще больше упростить анонимные функции. Например, начиная с самой явной формы, можно распечатать каждый элемент в целых числах, используя эту анонимную функцию с методом foreach класса List: ints.foreach((i: Int) =&gt; println(i)) Как и раньше, объявление Int не требуется, а поскольку аргумент всего один, скобки вокруг i не нужны: ints.foreach(i =&gt; println(i)) Поскольку i используется в теле функции только один раз, выражение можно еще больше упростить с помощью символа _: ints.foreach(println(_)) Наконец, если анонимная функция состоит из одного вызова метода с одним аргументом, нет необходимости явно называть и указывать аргумент, можно написать только имя метода (здесь, println): ints.foreach(println) References: Scala3 book Scala3 book, Anonymous Functions"
    } ,    
    {
      "title": "Applicative",
      "url": "/scalaworkbook/typeclass/monad/applicative.html",
      "content": "Applicative Applicative расширяет Functor и позволяет работать с несколькими «ящиками». Он реализует операцию applicate (также встречаются названия join, sequence, joinWith, ap - названия взаимозаменяемы), которая объединяет F[A =&gt; B] и F[A] в F[B]. Для Applicative должны соблюдаться следующие законы: map(apply(x))(f) == apply(f(x)) join(apply(x), apply(y)) == apply((x, y)) Примеры Applicative Реализации Applicative в различных библиотеках References: Tour of Scala Algebird"
    } ,    
    {
      "title": "ArrayBuffer",
      "url": "/scalaworkbook/docs/collections/array-buffer.html",
      "content": "ArrayBuffer ArrayBuffer используется тогда, когда нужна изменяемая индексированная последовательность общего назначения. Поскольку ArrayBuffer индексирован, произвольный доступ к элементам выполняется быстро. Создание ArrayBuffer Чтобы использовать ArrayBuffer, в отличие от предыдущих рассмотренных классов, его нужно вначале импортировать: import scala.collection.mutable.ArrayBuffer Если необходимо начать с пустого ArrayBuffer, просто укажите его тип: var strings = ArrayBuffer[String]() var ints = ArrayBuffer[Int]() var people = ArrayBuffer[Person]() Если известен примерный размер ArrayBuffer, его можно задать: val buf = new ArrayBuffer[Int](100_000) Чтобы создать новый ArrayBuffer с начальными элементами, достаточно просто указать начальные элементы, как для List или Vector: val nums = ArrayBuffer(1, 2, 3) val people = ArrayBuffer( Person(\"Bert\"), Person(\"Ernie\"), Person(\"Grover\") ) Добавление элементов в ArrayBuffer Новые элементы добавляются в ArrayBuffer с помощью методов += и ++=. Также можно использовать текстовый аналог: append, appendAll, insert, insertAll, prepend и prependAll. Вот несколько примеров с += и ++=: val nums = ArrayBuffer(1, 2, 3) // nums: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3) nums += 4 // res2: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4) nums ++= List(5, 6) // res5: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6) Удаление элементов из ArrayBuffer ArrayBuffer является изменяемым, поэтому у него есть такие методы, как -=, --=, clear, remove и другие. Примеры с -= и --=: val a = ArrayBuffer.range('a', 'h') // a: ArrayBuffer[Char] = ArrayBuffer('a', 'b', 'c', 'd', 'e', 'f', 'g') a -= 'a' // res7: ArrayBuffer[Char] = ArrayBuffer('b', 'c', 'd', 'e', 'f', 'g') a --= Seq('b', 'c') // res10: ArrayBuffer[Char] = ArrayBuffer('d', 'e', 'f', 'g') a --= Set('d', 'e') // res14: ArrayBuffer[Char] = ArrayBuffer('f', 'g') Обновление элементов в ArrayBuffer Элементы в ArrayBuffer можно обновлять, либо переназначать: val a = ArrayBuffer.range(1,5) // a: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4) a(2) = 50 println(a) // ArrayBuffer(1, 2, 50, 4) a.update(0, 10) println(a) // ArrayBuffer(10, 2, 50, 4) References: Scala3 book Scala3 book, Collections Types Scala, Mutable collections"
    } ,    
    {
      "title": "ArraySeq",
      "url": "/scalaworkbook/docs/collections/array-seq.html",
      "content": "ArraySeq Списки очень эффективны в алгоритмах которые активно использует head. Получение, добавление и удаление к переднему (head) элементу списка занимает постоянное время, в то время как доступ или изменение остальных элементов в списке занимает линейное время. Последовательный массив (ArraySeq) - это тип коллекции, который решает проблему неэффективности случайного доступа к спискам. ArraySeq позволяют получить доступ к любому элементу коллекции за постоянное время, из-за чего проще создавать эффективные алгоритмы. ArraySeq-ы создаются и изменяются также, как и любые другие последовательности. val arr = scala.collection.immutable.ArraySeq(1, 2, 3) // arr: ArraySeq[Int] = ArraySeq(1, 2, 3) val arr2 = arr :+ 4 // arr2: ArraySeq[Int] = ArraySeq(1, 2, 3, 4) arr2(0) // res0: Int = 1 ArraySeq-ы являются immutable, поэтому нельзя изменять элементы непосредственно в коллекции. Однако операции updated, appended и prepended создают новые ArraySeq-ы, которые отличаются от базового ArraySeq только в одном элементе: arr.updated(2, 4) // res1: ArraySeq[Int] = ArraySeq(1, 2, 4) arr // res2: ArraySeq[Int] = ArraySeq(1, 2, 3) Как видно из последней строки выше, вызов updated не влияет на исходный ArraySeq arr. ArraySeq-ы хранят свои элементы в приватном массиве. Таким образом достигается компактное представление и обеспечивается быстрый индексированный доступ к элементам, но обновление или добавление одного элемента занимает линейное время, так как требует создания другого массива и копирования всех элементов исходного. Изменяемый ArraySeq References: Scala, Immutable collections Scala, Mutable collections"
    } ,    
    {
      "title": "Блог",
      "url": "/scalaworkbook/docs/scaladoc/blog.html",
      "content": "Встроенный блог Scaladoc позволяет включить в документацию простой блог. Правильная настройка каталога Сообщения в блоге должны быть помещены в каталог _blog/_posts. ├── _blog │ ├── _posts │ │ └── 2022-06-17-implicit-function-types.md │ └── index.html Scaladoc загружает блог, если существует каталог _blog. Соглашение об именовании Все имена файлов сообщений блога должны начинаться с даты в числовом формате, соответствующем YYYY-MM-DD. Пример имени 2022-06-17-dotty-compiler-bootstraps.md. References: Scaladoc Guide"
    } ,    
    {
      "title": "Builder",
      "url": "/scalaworkbook/design-patterns/builder.html",
      "content": "Builder Описание Цель паттерна: Отделение построения сложного объекта от его представления, чтобы один и тот же процесс построения мог создавать разные представления. Диаграмма Пример class Pizza(var dough: String = \"\", var sauce: String = \"\", var topping: String = \"\"): def outputReceipt(): Unit = println(s\"Dough: $dough\\nSauce: $sauce\\nTopping: $topping\") trait PizzaBuilder: private var maybePizza: Option[Pizza] = None def getPizza: Pizza = maybePizza.getOrElse(throw new Exception(\"Pizza has not been created yet\")) def createPizza(): Unit = maybePizza = Some(new Pizza) def buildDough(dough: String): Unit = getPizza.dough = dough def buildSauce(sauce: String): Unit = getPizza.sauce = sauce def buildTopping(topping: String): Unit = getPizza.topping = topping end PizzaBuilder Использование паттерна строитель: object HawaiianPizzaBuilder extends PizzaBuilder: def createHawaiianPizza(): Pizza = createPizza() buildDough(\"cross\") buildSauce(\"mild\") buildTopping(\"ham+pineapple\") getPizza object SpicyPizzaBuilder extends PizzaBuilder: def createSpicyPizza(): Pizza = createPizza() buildDough(\"pan baked\") buildSauce(\"hot\") buildTopping(\"pepperoni+salami\") getPizza HawaiianPizzaBuilder.createHawaiianPizza().outputReceipt() // Dough: cross // Sauce: mild // Topping: ham+pineapple SpicyPizzaBuilder.createSpicyPizza().outputReceipt() // Dough: pan baked // Sauce: hot // Topping: pepperoni+salami References: Scala &amp; Design Patterns by Frederik Skeel Løkke Wikipedia"
    } ,    
    {
      "title": "Параметры по имени",
      "url": "/scalaworkbook/docs/methods/by-name-parameter.html",
      "content": "Параметры по имени Параметры по имени - это такие параметры, которые вычисляются только при использовании. Они указываются с помощью символа “стрелка” - =&gt; Пример: def or(a: Boolean, b: =&gt; Int): Int = if a then 1 else b def b: Int = println(\"I'm calculated\") 2 or(true, b) // res0: Int = 1 or(false, b) // I'm calculated // res1: Int = 2 В первом случае b не вычислялся, потому что он не используется при a = true. References: Scala3 book, Method Features"
    } ,    
    {
      "title": "Конт. пар. по имени",
      "url": "/scalaworkbook/docs/abstractions/ca-by-name-parameters.html",
      "content": "Контекстные параметры по имени Контекстные параметры также могут быть объявлены по имени, чтобы избежать использования предполагаемого расширения. Пример: trait Codec[T]: def write(x: T): Unit given intCodec: Codec[Int] = (x: Int) =&gt; println(s\"$x has been written\") given optionCodec[T](using ev: =&gt; Codec[T]): Codec[Option[T]] with def write(xo: Option[T]) = xo match case Some(x) =&gt; ev.write(x) case None =&gt; val s = summon[Codec[Option[Int]]] // s: optionCodec[Int] = repl.MdocSession$App$optionCodec@9801ecc s.write(Some(33)) // 33 has been written s.write(None) Как и в случае обычного параметра по имени, аргумент контекстного параметра ev оценивается по требованию. В приведенном выше примере, если значение параметра xo равно None, оно вообще не вычисляется. References: Scala 3 Reference"
    } ,    
    {
      "title": "Контекстные границы",
      "url": "/scalaworkbook/docs/abstractions/ca-context-bounds.html",
      "content": "Контекстные границы Во многих ситуациях необязательно указывать имя параметра контекста явно, поскольку оно используется компилятором только в синтезированных аргументах для других параметров контекста. В таких случаях имя параметра определять не нужно и можно просто указать его тип. Background Например, этот метод maximum принимает параметр контекста типа Ord только для того, чтобы передать его в качестве аргумента функции max: def maximum[A](xs: List[A])(using ord: Ord[A]): A = xs.reduceLeft(max(ord)) В этом коде имя параметра ord на самом деле не требуется; его можно передать в качестве предполагаемого аргумента в max, поэтому достаточно просто указать, что maximum использует тип Ord[A], не называя его: def maximum[A](xs: List[A])(using Ord[A]): A = xs.reduceLeft(max) Контекстные границы Учитывая вышесказанное, контекстная граница (context bound) — это сокращенный синтаксис для выражения шаблона “параметр контекста, который зависит от параметра типа”. Используя привязку к контексту, метод maximum можно записать следующим образом: def maximum[A: Ord](xs: List[A]): A = xs.reduceLeft(max) Привязка типа : Ord к параметру типа A метода или класса указывает параметр контекста using Ord[A]. Параметры контекста, сгенерированные из границ контекста, идут последними в определении содержащего их метода или класса. Например, def f[T: C1 : C2, U: C3](x: T)(using y: U, z: V): R расширится до def f[T, U](x: T)(using y: U, z: V)(using C1[T], C2[T], C3[U]): R Границы контекста можно комбинировать с границами подтипа. Если присутствуют оба, сначала идут границы подтипа, например def g[T &lt;: B : C](x: T): R = ... Дополнительные сведения о границах контекста см. в ответе “Что такое границы контекста?”. References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Методы расш. - детали",
      "url": "/scalaworkbook/docs/abstractions/ca-extension-methods.html",
      "content": "Методы расширения Методы расширения (extension methods) позволяют добавлять методы к типу после его определения, т.е. позволяют добавлять новые методы в закрытые классы. Например, предположим, что кто-то другой создал класс Circle: case class Circle(x: Double, y: Double, radius: Double) Теперь представим, что необходим метод circumference, но нет возможности изменить исходный код Circle. До того как концепция вывода терминов была введена в языки программирования, единственное, что можно было сделать, это написать метод в отдельном классе или объекте, подобном этому: object CircleHelpers: def circumference(c: Circle): Double = c.radius * math.Pi * 2 Затем этот метод можно было использовать следующим образом: val aCircle = Circle(2, 3, 5) CircleHelpers.circumference(aCircle) Методы расширения позволяют создать метод circumference для работы с экземплярами Circle: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 В этом коде: Circle — это тип, к которому будет добавлен метод расширения circumference Синтаксис c: Circle позволяет ссылаться на переменную c в методах расширения Затем в коде метод circumference можно использовать так же, как если бы он был изначально определен в классе Circle: aCircle.circumference Импорт методов расширения Представим, что circumference определен в пакете lib - его можно импортировать с помощью import lib.circumference aCircle.circumference Если импорт отсутствует, то компилятор выводит подробное сообщение об ошибке, подсказывая возможный импорт, например так: value circumference is not a member of Circle, but could be made available as an extension method. The following import might fix the problem: import lib.circumference Операторы Синтаксис метода расширения также можно использовать для определения операторов. Примеры: extension (x: String) def &lt; (y: String): Boolean = ... extension (x: Elem) def +: (xs: Seq[Elem]): Seq[Elem] = ... extension (x: Number) infix def min (y: Number): Number = ... \"ab\" &lt; \"c\" 1 +: List(2, 3) x min 3 Generic расширения Также возможно расширить generic типы, добавив параметры типа в расширение. Например: extension [T](xs: List[T]) def second = xs.tail.head extension [T: Numeric](x: T) def + (y: T): T = summon[Numeric[T]].plus(x, y) Параметры типа в расширениях также можно комбинировать с параметрами типа в самих методах: extension [T](xs: List[T]) def sumBy[U: Numeric](f: T =&gt; U): U = ... Аргументы типа, соответствующие параметрам типа метода, передаются стандартно: List(\"a\", \"bb\", \"ccc\").sumBy[Int](_.length) Напротив, аргументы типа, соответствующие параметрам типа extension, могут быть переданы, только если на метод ссылаются как на метод без расширения: sumBy[String](List(\"a\", \"bb\", \"ccc\"))(_.length) Или при передаче обоих аргументов типа: sumBy[String](List(\"a\", \"bb\", \"ccc\"))[Int](_.length) Расширения также могут принимать предложения using. Например, приведенное выше расширение + можно было бы записать с предложения using: extension [T](x: T)(using n: Numeric[T]) def + (y: T): T = n.plus(x, y) Коллективные расширения Ключевое слово extension объявляет о намерении определить один или несколько методов расширения для типа, заключенного в круглые скобки. Чтобы определить для типа несколько методов расширения, используется следующий синтаксис: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 def diameter: Double = c.radius * 2 def area: Double = math.Pi * c.radius * c.radius Коллективные расширения, подобные этим, являются сокращением для индивидуальных расширений, где каждый метод определяется отдельно. Например, расширение выше - это: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 extension (c: Circle) def diameter: Double = c.radius * 2 extension (c: Circle) def area: Double = math.Pi * c.radius * c.radius Коллективные расширения также могут принимать параметры типа и содержать предложения using. Пример: extension [T](xs: List[T])(using Ordering[T]) def smallest(n: Int): List[T] = xs.sorted.take(n) def smallestIndices(n: Int): List[Int] = val limit = smallest(n).max xs.zipWithIndex.collect { case (x, i) if x &lt;= limit =&gt; i } Вызов методов расширения Чтобы преобразовать ссылку в метод расширения, компилятор должен знать о методе расширения. В этом случае говорится, что метод расширения применим в точке отсчета. Существует четыре возможных способа применения метода расширения: метод расширения виден под простым именем, будучи определенным, унаследованным или импортированным в области, охватывающей ссылку. метод расширения является членом некоторого экземпляра given, видимого в точке ссылки. ссылка имеет форму r.m, а метод расширения определен в неявной области видимости типа r. ссылка имеет форму r.m, а метод расширения определен в некотором экземпляре given в неявной области видимости типа r. Вот пример первого правила: trait IntOps: extension (i: Int) def isZero: Boolean = i == 0 extension (i: Int) def safeMod(x: Int): Option[Int] = // метод расширения, определенный в той же области видимости - IntOps if x.isZero then None else Some(i % x) object IntOpsEx extends IntOps: extension (i: Int) def safeDiv(x: Int): Option[Int] = // метод расширения, введенный в область видимости через наследование от IntOps if x.isZero then None else Some(i / x) trait SafeDiv: import IntOpsEx.* extension (i: Int) def divide(d: Int): Option[(Int, Int)] = // методы расширения импортированы и, следовательно, находятся в области видимости (i.safeDiv(d), i.safeMod(d)) match case (Some(d), Some(r)) =&gt; Some((d, r)) case _ =&gt; None Согласно второму правилу, метод расширения можно сделать доступным, определив экземпляр given, содержащий его, например так: given ops1: IntOps() // приносит safeMod в область видимости 1.safeMod(2) По третьему и четвертому правилу метод расширения доступен, если он находится в неявной области действия типа получателя или в экземпляре given в этой области. Пример: class List[T]: ... object List: ... extension [T](xs: List[List[T]]) def flatten: List[T] = xs.foldLeft(List.empty[T])(_ ++ _) given [T: Ordering]: Ordering[List[T]] with extension (xs: List[T]) def &lt; (ys: List[T]): Boolean = ... end List // метод расширения доступен, поскольку он находится в неявной области видимости List[List[Int]] List(List(1, 2), List(3, 4)).flatten // метод расширения доступен, поскольку он находится в given Ordering[List[T]], // который сам находится в неявной области видимости List[Int] List(1, 2) &lt; List(3) References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Given imports",
      "url": "/scalaworkbook/docs/abstractions/ca-given-imports.html",
      "content": "Given imports Для большей ясности, откуда берутся данные в текущей области видимости, для импорта экземпляров given используется специальная форма оператора import. Базовая форма показана в этом примере: object A: class TC given tc: TC = ??? def f(using TC) = ??? object B: import A.* // импорт всех non-given членов import A.given // импорт given членов В этом коде предложение import A.* объекта B импортирует все элементы A, кроме given экземпляра tc. И наоборот, второй импорт, import A.given, импортирует только экземпляр given. Два предложения импорта также могут быть объединены в одно: object B: import A.{given, *} Обсуждение Селектор с подстановочным знаком * помещает в область видимости все определения, кроме givens или расширений, тогда как селектор given помещает в область видимости все givens, включая те, которые являются результатом расширений. Эти правила имеют два основных преимущества: понятнее, откуда берутся данные в текущей области видимости. В частности, невозможно скрыть импортированные givens в длинном списке других импортов. есть возможность импортировать все given, не импортируя ничего другого. Это важно, потому что givens могут быть анонимными, поэтому обычное использование именованного импорта нецелесообразно. Дополнительные примеры синтаксиса “import given” показаны в главе “Пакеты и импорт”. References: Scala3 book"
    } ,    
    {
      "title": "Given",
      "url": "/scalaworkbook/docs/abstractions/ca-given.html",
      "content": "Экземпляры given Given instances (или просто “givens”) определяют “канонические” значения определенных типов, которые служат для синтеза аргументов в параметрах контекста. Пример: trait Ord[T]: def compare(x: T, y: T): Int extension (x: T) def &lt; (y: T) = compare(x, y) &lt; 0 extension (x: T) def &gt; (y: T) = compare(x, y) &gt; 0 given intOrd: Ord[Int] with def compare(x: Int, y: Int) = if x &lt; y then -1 else if x &gt; y then +1 else 0 given listOrd[T](using ord: Ord[T]): Ord[List[T]] with def compare(xs: List[T], ys: List[T]): Int = (xs, ys) match case (Nil, Nil) =&gt; 0 case (Nil, _) =&gt; -1 case (_, Nil) =&gt; +1 case (x :: xs1, y :: ys1) =&gt; val fst = ord.compare(x, y) if fst != 0 then fst else compare(xs1, ys1) Этот код определяет трейт Ord с двумя экземплярами given. intOrd определяет given для типа Ord[Int], тогда как listOrd[T] определяет given Ord[List[T]] для всех типов T, которые поставляются с given экземпляром Ord[T]. Предложение using в listOrd определяет условие: для существования given типа Ord[List[T]] должен существовать given тип Ord[T]. Такие условия расширяются компилятором до параметров контекста. Результат: def sort[T](lists: List[List[T]])(using ord: Ord[List[T]]): List[List[T]] = lists.sortWith((l1, l2) =&gt; ord.compare(l1, l2) &lt; 0) sort(List(List(1, 3, 4), List(1, 2), List(1, 2, 3, 4, 5))) // res0: List[List[Int]] = List(List(1, 2), List(1, 2, 3, 4, 5), List(1, 3, 4)) Анонимные givens Имя given может быть опущено. Таким образом, определения выше также могут быть выражены следующим образом: given Ord[Int] with ... given [T](using Ord[T]): Ord[List[T]] with ... Если имя given отсутствует, компилятор синтезирует его из реализованного типа (типов). Имя, синтезированное компилятором, выбирается читабельным и достаточно кратким. Например, два приведенных выше экземпляра получат имена: given_Ord_Int и given_Ord_List. Точные правила синтеза имен находятся здесь. Эти правила не гарантируют отсутствия конфликтов имен между экземплярами типов given, которые “слишком похожи”. Чтобы избежать конфликтов, можно использовать именованные экземпляры. Для обеспечения надежной двоичной совместимости общедоступным библиотекам следует отдавать предпочтение именованным экземплярам. Псевдоним given Псевдоним можно использовать для определения экземпляра given, равного некоторому выражению. Пример: given global: ExecutionContext = ForkJoinPool() Это создает given global типа ExecutionContext, который равен правой части ForkJoinPool(). При первом запросе к global создается новый ForkJoinPool, который затем возвращается для всех обращений к global. Эта операция является потокобезопасной. Псевдоним также может быть анонимным, например: given Position = enclosingTree.position given (using config: Config): Factory = MemoizingFactory(config) Псевдоним given может иметь параметры типа и параметры контекста, как и любой другой given, но он может реализовывать только один тип. Given макросы Псевдонимы given могут иметь модификаторы inline и transparent. Пример: transparent inline given mkAnnotations[A, T]: Annotations[A, T] = ${ // code producing a value of a subtype of Annotations } Так как mkAnnotations - transparent, тип приложения — это тип его правой части, которая может быть правильным подтипом объявленного типа результата Annotations[A, T]. Экземпляры given могут иметь модификаторы inline, но не иметь transparent, так как их тип уже известен из подписи. Пример: trait Show[T] { inline def show(x: T): String } inline given Show[Foo] with { /*transparent*/ inline def show(x: Foo): String = ${ ... } } def app = // inlines `show` method call and removes the call to `given Show[Foo]` summon[Show[Foo]].show(foo) Обратите внимание, что встроенные методы в экземплярах given могут быть transparent. Встраивание экземпляров given не будет встраивать/дублировать реализацию given, оно просто дополнит создание экземпляра. Это используется для устранения мертвого кода экземпляров given, которые не используются после встраивания. Привязанные к шаблону экземпляры given Экземпляры given также могут появляться в шаблонах. Пример: for given Context &lt;- applicationContexts do pair match case (ctx @ given Context, y) =&gt; ... В первом фрагменте анонимные экземпляры given для класса Context устанавливаются путем перечисления applicationContexts. Во втором фрагменте given экземпляр Context с именем ctx устанавливается путем сопоставления с первой половиной селектора pair. В каждом случае экземпляр given, привязанный к шаблону, состоит из given и типа T. Шаблон соответствует точно тем же селекторам, что и шаблон приписывания типа _: T. Отрицательные given Специальный тип scala.util.NotGiven реализует “отрицательный” поиск в неявном расширении. Для любого типа запроса Q, NotGiven[Q] выполняется успешно тогда и только тогда, когда неявный поиск Q терпит неудачу, например: import scala.util.NotGiven trait Tagged[A] case class Foo[A](value: String) object Foo: given fooTagged[A](using Tagged[A]): Foo[A] = Foo(\"fooTagged is found\") given fooNotTagged[A](using NotGiven[Tagged[A]]): Foo[A] = Foo(\"fooNotTagged is found\") given Tagged[Int]() summon[Foo[Int]].value // res1: String = \"fooTagged is found\" summon[Foo[String]].value // res2: String = \"fooNotTagged is found\" References: Scala 3 Reference"
    } ,    
    {
      "title": "Неявные преобр.",
      "url": "/scalaworkbook/docs/abstractions/ca-implicit-conversions.html",
      "content": "Неявные преобразования типов Неявные преобразования определяются экземплярами given класса scala.Conversion. Этот класс определен в пакете scala следующим образом: abstract class Conversion[-T, +U] extends (T =&gt; U): def apply (x: T): U Например, без учета возможных ошибок преобразования, этот код определяет неявное преобразование из String в Int: given Conversion[String, Int] with def apply(s: String): Int = Integer.parseInt(s) Используя псевдоним, можно выразиться более кратко: given Conversion[String, Int] = Integer.parseInt(_) Используя любое из этих преобразований, теперь String можно использовать в местах, где ожидается Int: import scala.language.implicitConversions // метод, который ожидает Int def plus1(i: Int) = i + 1 // можно передать строку, которая преобразуется в Int plus1(\"1\") Обратите внимание на предложение import scala.language.implicitConversions в начале, чтобы разрешить неявные преобразования в файле. Неявное преобразование автоматически применяется компилятором в трех случаях: Если выражение e имеет тип T и T не соответствует ожидаемому типу выражения S. В выборе e.m с e типа T, но T не определяет член m. В приложении e.m(args) с e типа T, если T определяет некоторые элементы с именем m, но ни один из этих членов не может быть применен к аргументам args. В первом случае компилятор ищет given экземпляр scala.Conversion, который сопоставляет аргумент типа T с типом S. Во втором и третьем случаях он ищет given экземпляр scala.Conversion, который сопоставляет аргумент типа T с типом, определяющим член m, к которому можно применить args, если они присутствуют. Если такой экземпляр C найден, выражение e заменяется на C.apply(e). Примеры 1) Пакет Predef содержит преобразования «автоматического упаковывания», которые сопоставляют примитивные числовые типы с подклассами java.lang.Number. Например, преобразование из Int в java.lang.Integer можно определить следующим образом: given int2Integer: Conversion[Int, java.lang.Integer] = java.lang.Integer.valueOf(_) 2) Паттерн “magnet” иногда используется для выражения нескольких вариантов метода. Вместо того чтобы определять перегруженные версии метода, можно также позволить ему принимать один или несколько аргументов специально определенных “магнитных” типов, в которые могут быть преобразованы различные типы аргументов. Пример: object Completions: // The argument \"magnet\" type enum CompletionArg: case Error(s: String) case Response(f: Future[HttpResponse]) case Status(code: Future[StatusCode]) object CompletionArg: // conversions defining the possible arguments to pass to `complete` // these always come with CompletionArg // They can be invoked explicitly, e.g. // // CompletionArg.fromStatusCode(statusCode) given fromString : Conversion[String, CompletionArg] = Error(_) given fromFuture : Conversion[Future[HttpResponse], CompletionArg] = Response(_) given fromStatusCode: Conversion[Future[StatusCode], CompletionArg] = Status(_) end CompletionArg import CompletionArg.* def complete[T](arg: CompletionArg) = arg match case Error(s) =&gt; ... case Response(f) =&gt; ... case Status(code) =&gt; ... end Completions Эта конструкция сложнее, чем простая перегрузка complete, но все же может быть полезна, если обычная перегрузка недоступна (как в случае выше, поскольку у нас не может быть двух перегруженных методов, принимающих аргументы Future[...]), или если обычная перегрузка привела бы к комбинаторному взрыву вариантов. References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Multiversal Equality",
      "url": "/scalaworkbook/docs/abstractions/ca-multiversal-equality.html",
      "content": "Многостороннее равенство Раньше в Scala было универсальное равенство (universal equality): два значения любых типов можно было сравнивать друг с другом с помощью == и !=. Это произошло из-за того факта, что == и != реализованы в терминах метода equals Java, который также может сравнивать значения любых двух ссылочных типов. Всеобщее равенство удобно, но оно также опасно, поскольку подрывает безопасность типов. Например, предположим, что после некоторого рефакторинга осталась ошибочная программа, в которой значение y имеет тип S вместо правильного типа T: val x = ... // типа T val y = ... // типа S, но должно быть типа T x == y // проверки типов всегда будут выдавать false Если y сравнивается с другими значениями типа T, программа все равно будет проверять тип, так как значения всех типов можно сравнивать друг с другом. Но это, вероятно, даст неожиданные результаты и завершится ошибкой во время выполнения. Типобезопасный язык программирования может работать лучше, а мультиуниверсальное равенство — это дополнительный способ сделать универсальное равенство более безопасным. Он использует класс двоичного типа CanEqual, чтобы указать, что значения двух заданных типов можно сравнивать друг с другом. Разрешение сравнения экземпляров класса По умолчанию сравнение на равенство можно создать следующим образом: case class Cat(name: String) case class Dog(name: String) val d = Dog(\"Fido\") val c = Cat(\"Morris\") d == c // false, но он компилируется Но в Scala 3 такие сравнения можно отключить. При (а) импорте scala.language.strictEquality или (б) использовании флага компилятора -language:strictEquality это сравнение больше не компилируется: import scala.language.strictEquality val rover = Dog(\"Rover\") val fido = Dog(\"Fido\") println(rover == fido) // compiler error // compiler error message: // Values of types Dog and Dog cannot be compared with == or != Включение сравнений Есть два способа включить сравнение с помощью класса типов CanEqual. Для простых случаев класс может выводиться (derive) от класса CanEqual: // Способ 1 case class Dog(name: String) derives CanEqual Также можно использовать следующий синтаксис: // Способ 2 case class Dog(name: String) given CanEqual[Dog, Dog] = CanEqual.derived Любой из этих двух подходов позволяет сравнивать экземпляры Dog друг с другом. Более реалистичный пример В более реалистичном примере представим, что есть книжный интернет-магазин и мы хотим разрешить или запретить сравнение бумажных, печатных и аудиокниг. В Scala 3 для начала необходимо включить мультиуниверсальное равенство: // [1] добавить этот импорт или command line flag: -language:strictEquality import scala.language.strictEquality Затем создать объекты домена: // [2] создание иерархии классов trait Book: def author: String def title: String def year: Int case class PrintedBook( author: String, title: String, year: Int, pages: Int ) extends Book case class AudioBook( author: String, title: String, year: Int, lengthInMinutes: Int ) extends Book Наконец, используем CanEqual, чтобы определить, какие сравнения необходимо разрешить: // [3] создайте экземпляры класса типов, чтобы определить разрешенные сравнения. // разрешено `PrintedBook == PrintedBook` // разрешено `AudioBook == AudioBook` given CanEqual[PrintedBook, PrintedBook] = CanEqual.derived given CanEqual[AudioBook, AudioBook] = CanEqual.derived // [4a] сравнение двух печатных книг разрешено val p1 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328) val p2 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328) println(p1 == p2) // true // [4b] нельзя сравнивать печатную книгу и аудиокнигу val pBook = PrintedBook(\"1984\", \"George Orwell\", 1961, 328) val aBook = AudioBook(\"1984\", \"George Orwell\", 2006, 682) println(pBook == aBook) // compiler error Последняя строка кода приводит к следующему сообщению компилятора об ошибке: Values of types PrintedBook and AudioBook cannot be compared with == or != Вот как мультиуниверсальное равенство отлавливает недопустимые сравнения типов во время компиляции. Включение «PrintedBook == AudioBook» Если есть необходимость разрешить сравнение PrintedBook с AudioBook, то достаточно создать следующие два дополнительных сравнения равенства: // разрешить `PrintedBook == AudioBook` и `AudioBook == PrintedBook` given CanEqual[PrintedBook, AudioBook] = CanEqual.derived given CanEqual[AudioBook, PrintedBook] = CanEqual.derived Теперь можно сравнивать PrintedBook с AudioBook без ошибки компилятора: println(pBook == aBook) // false println(aBook == pBook) // false Внедрение «equals» Хотя эти сравнения теперь разрешены, они всегда будут ложными, потому что их методы equals не знают, как проводить подобные сравнения. Чтобы доработать сравнение, можно переопределить методы equals для каждого класса. Например, если переопределить метод equals для AudioBook: case class AudioBook( author: String, title: String, year: Int, lengthInMinutes: Int ) extends Book: // переопределить, чтобы разрешить сравнение AudioBook с PrintedBook override def equals(that: Any): Boolean = that match case a: AudioBook =&gt; if this.author == a.author &amp;&amp; this.title == a.title &amp;&amp; this.year == a.year &amp;&amp; this.lengthInMinutes == a.lengthInMinutes then true else false case p: PrintedBook =&gt; if this.author == p.author &amp;&amp; this.title == p.title then true else false case _ =&gt; false Теперь можно сравнить AudioBook с PrintedBook: println(aBook == pBook) // true (работает из-за переопределенного `equals` в `AudioBook`) println(pBook == aBook) // false Книга PrintedBook не имеет метода equals, поэтому второе сравнение возвращает false. Чтобы включить это сравнение, достаточно переопределить метод equals в PrintedBook. References: Scala3 book"
    } ,    
    {
      "title": "Type Class Derivation",
      "url": "/scalaworkbook/docs/abstractions/ca-type-class-derivation.html",
      "content": "Type Class Derivation Type class derivation - это способ автоматического создания экземпляров given классов типов, которые удовлетворяют некоторым простым условиям. Класс типов в этом смысле — это любой trait или класс с параметром типа, определяющим тип, над которым выполняется операция. Общие примеры: Eq, Ordering или Show. Пример, для следующего алгебраического типа данных (ADT) Tree: enum Tree[T] derives Eq, Ordering, Show: case Branch(left: Tree[T], right: Tree[T]) case Leaf(elem: T) Предложение derives создает следующие экземпляры given для классов типов Eq, Ordering и Show в сопутствующем объекте Tree: given [T: Eq] : Eq[Tree[T]] = Eq.derived given [T: Ordering] : Ordering[Tree] = Ordering.derived given [T: Show] : Show[Tree] = Show.derived Говорится, что Tree - это производный тип (deriving type), а экземпляры Eq, Ordering и Show являются производными экземплярами (derived instances). Типы вспомогательных derives предложений Все типы данных могут содержать предложение derives. В этом документе основное внимание уделяется типам данных, для которых также доступен given экземпляр класса типа Mirror. Экземпляры класса типа Mirror автоматически генерируются компилятором для, enums и enum cases case classes и case objects sealed классы или trait-ы, которые содержат в качестве потомков только case classes и case objects Экземпляры класса типа Mirror предоставляют информацию на уровне типа о компонентах и маркировке типа. Они также обеспечивают минимальную инфраструктуру уровня терминов, позволяющую библиотекам более высокого уровня обеспечивать всестороннюю поддержку деривации. sealed trait Mirror: /** the type being mirrored */ type MirroredType /** the type of the elements of the mirrored type */ type MirroredElemTypes /** The mirrored *-type */ type MirroredMonoType /** The name of the type */ type MirroredLabel &lt;: String /** The names of the elements of the type */ type MirroredElemLabels &lt;: Tuple object Mirror: /** The Mirror for a product type */ trait Product extends Mirror: /** Create a new instance of type `T` with elements * taken from product `p`. */ def fromProduct(p: scala.Product): MirroredMonoType trait Sum extends Mirror: /** The ordinal number of the case class of `x`. * For enums, `ordinal(x) == x.ordinal` */ def ordinal(x: MirroredMonoType): Int end Mirror Типы продуктов (т.е. case классы и case объекты, а также enum case) имеют зеркала, которые являются подтипами Mirror.Product. Типы суммы (т.е. закрытый (sealed) класс или trait-ы с дочерними продуктами и перечисления) имеют зеркала, которые являются подтипами Mirror.Sum. Для Tree ADT, описанного выше, следующие экземпляры Mirror будут автоматически предоставлены компилятором: // Mirror for Tree new Mirror.Sum: type MirroredType = Tree type MirroredElemTypes[T] = (Branch[T], Leaf[T]) type MirroredMonoType = Tree[_] type MirroredLabel = \"Tree\" type MirroredElemLabels = (\"Branch\", \"Leaf\") def ordinal(x: MirroredMonoType): Int = x match case _: Branch[_] =&gt; 0 case _: Leaf[_] =&gt; 1 // Mirror for Branch new Mirror.Product: type MirroredType = Branch type MirroredElemTypes[T] = (Tree[T], Tree[T]) type MirroredMonoType = Branch[_] type MirroredLabel = \"Branch\" type MirroredElemLabels = (\"left\", \"right\") def fromProduct(p: Product): MirroredMonoType = new Branch(...) // Mirror for Leaf new Mirror.Product: type MirroredType = Leaf type MirroredElemTypes[T] = Tuple1[T] type MirroredMonoType = Leaf[_] type MirroredLabel = \"Leaf\" type MirroredElemLabels = Tuple1[\"elem\"] def fromProduct(p: Product): MirroredMonoType = new Leaf(...) Обратите внимание на следующие свойства типов Mirror: Свойства кодируются с использованием типов, а не терминов. Это означает, что они не влияют на время выполнения, если не используются, а также что они являются функцией времени компиляции для использования со средствами метапрограммирования Scala 3. Типы MirroredType и MirroredElemTypes соответствуют типам данных, экземпляром которых является зеркало. Это позволяет Mirrors поддерживать ADT всех видов. Нет отдельного типа представления для сумм или произведений (т.е. нет типа HList или Coproduct, как в версиях Shapeless для Scala 2). Вместо этого набор дочерних типов типа данных представлен обычным, возможно, параметризованным типом кортежа. Средства метапрограммирования Scala 3 можно использовать для работы с этими типами кортежей как есть, а поверх них можно создавать библиотеки более высокого уровня. Как для типов произведения, так и для суммы, элементы MirroredElemTypes располагаются в порядке определения (т.е. Branch[T] предшествуют Leaf[T], потому что они определены раньше в исходном файле). Это означает, что в этом отношении оно отличается от общего представления Shapeless для ADT в Scala 2, где конструкторы упорядочены в алфавитном порядке по именам. Методы ordinal и fromProduct определяются в терминах того MirroredMonoType, который получается из MirroredType с подстановочными знаками в его параметрах типа. Классы типов, поддерживающие автоматическую деривиацию Trait или класс могут появиться в предложении derives, если их сопутствующий объект определяет метод с именем derived. Сигнатура и реализация derived метода для класса типов TC[_] произвольны, но обычно имеют следующую форму: import scala.deriving.Mirror def derived[T](using Mirror.Of[T]): TC[T] = ... То есть метод derived принимает контекстный параметр типа Mirror (некоторого подтипа), который определяет форму производного типа T, и вычисляет реализацию класса типа в соответствии с этой формой. Это все, что поставщик ADT с предложением derives должен знать о порождении экземпляра класса типов. Обратите внимание, что методы derived могут косвенно иметь параметры контекста Mirror (например, иметь аргумент контекста, который, в свою очередь, имеет параметр контекста Mirror, или вообще не иметь (например, они могут использовать какой-то совершенно другой механизм, предоставленный пользователем, например, с помощью макросов Scala 3 или runtime reflection)). Ожидается, что наиболее распространенными будут (прямые или непрямые) реализации Mirror. Авторы классов типов, скорее всего, будут использовать производные библиотеки более высокого уровня или универсальные библиотеки программирования для реализации методов derived. Пример того, как метод derived может быть реализован с использованием только средств низкого уровня, описанных выше, и общих возможностей метапрограммирования Scala 3, приведен ниже. Не предполагается, что авторы классов типов обычно будут реализовывать метод derived таким образом, однако это пошаговое руководство можно рассматривать как руководство для авторов библиотек деривации более высокого уровня (для полностью проработанного примера о такой библиотеке см. Shapeless 3). Как написать метод derived класса типов, используя низкоуровневые механизмы Низкоуровневый метод, который будет использоваться для реализации метода derived класса типа в этом примере, использует три новые конструкции уровня типа в Scala 3: встроенные методы (inline methods), встроенные совпадения (inline matches) и неявный поиск через summonInline или summonFrom. Учитывая это определение класса типа Eq: trait Eq[T]: def eqv(x: T, y: T): Boolean нужно реализовать метод Eq.derived для сопутствующего объекта Eq, который создает экземпляр given для Eq[T] заданного Mirror[T]. Вот возможная реализация: import scala.deriving.Mirror inline given derived[T](using m: Mirror.Of[T]): Eq[T] = val elemInstances = summonAll[m.MirroredElemTypes] // (1) inline m match // (2) case s: Mirror.SumOf[T] =&gt; eqSum(s, elemInstances) case p: Mirror.ProductOf[T] =&gt; eqProduct(p, elemInstances) Обратите внимание, что derived определяется как inline given. Это означает, что метод будет расширен в местах вызова (например, компилятор сгенерировал определения экземпляров в сопутствующих объектах ADT, которые содержат derived Eq предложение), а также, что его можно будет использовать рекурсивно, если необходимо, для вычисления экземпляров для дочерних элементов. Тело этого метода (1) сначала материализует экземпляры Eq для всех дочерних типов типа, для которого создается экземпляр. Это либо все ветви типа суммы, либо все поля типа продукта. Реализация summonAll - inline и использует конструкцию Scala 3 summonInline для сбора экземпляров в виде List: inline def summonAll[T &lt;: Tuple]: List[Eq[_]] = inline erasedValue[T] match case _: EmptyTuple =&gt; Nil case _: (t *: ts) =&gt; summonInline[Eq[t]] :: summonAll[ts] с экземплярами для дочерних элементов метод derived использует inline match для отправки методов, которые могут создавать экземпляры либо для сумм, либо для произведений (2). Обратите внимание, что поскольку derived - inline совпадение будет разрешено во время компиляции, и только левая часть совпадающего случая будет встроена в сгенерированный код с уточненными типами, выявленными в результате совпадения. В случае суммы, eqSum, используются ordinal runtime значения аргументов eqv, чтобы сначала проверить, относятся ли два значения к одному и тому же подтипу ADT (3), а затем, если подтипы совпадают, для дальнейшей проверки на равенство на основе экземпляра Eq для соответствующего подтипа ADT с помощью вспомогательного метода check (4). import scala.deriving.Mirror def eqSum[T](s: Mirror.SumOf[T], elems: List[Eq[_]]): Eq[T] = new Eq[T]: def eqv(x: T, y: T): Boolean = val ordx = s.ordinal(x) // (3) (s.ordinal(y) == ordx) &amp;&amp; check(elems(ordx))(x, y) // (4) В случае продукта eqProduct мы проверяем runtime значения аргументов eqv на равенство как продукты на основе экземпляров Eq для полей типа данных (5): import scala.deriving.Mirror def eqProduct[T](p: Mirror.ProductOf[T], elems: List[Eq[_]]): Eq[T] = new Eq[T]: def eqv(x: T, y: T): Boolean = iterator(x).zip(iterator(y)).zip(elems.iterator).forall { // (5) case ((x, y), elem) =&gt; check(elem)(x, y) } Собрав все это вместе, получается следующая полная реализация: import scala.deriving.* import scala.compiletime.{erasedValue, summonInline} inline def summonAll[T &lt;: Tuple]: List[Eq[_]] = inline erasedValue[T] match case _: EmptyTuple =&gt; Nil case _: (t *: ts) =&gt; summonInline[Eq[t]] :: summonAll[ts] trait Eq[T]: def eqv(x: T, y: T): Boolean object Eq: given Eq[Int] with def eqv(x: Int, y: Int) = x == y def check(elem: Eq[_])(x: Any, y: Any): Boolean = elem.asInstanceOf[Eq[Any]].eqv(x, y) def iterator[T](p: T) = p.asInstanceOf[Product].productIterator def eqSum[T](s: Mirror.SumOf[T], elems: =&gt; List[Eq[_]]): Eq[T] = new Eq[T]: def eqv(x: T, y: T): Boolean = val ordx = s.ordinal(x) (s.ordinal(y) == ordx) &amp;&amp; check(elems(ordx))(x, y) def eqProduct[T](p: Mirror.ProductOf[T], elems: =&gt; List[Eq[_]]): Eq[T] = new Eq[T]: def eqv(x: T, y: T): Boolean = iterator(x).zip(iterator(y)).zip(elems.iterator).forall { case ((x, y), elem) =&gt; check(elem)(x, y) } inline given derived[T](using m: Mirror.Of[T]): Eq[T] = lazy val elemInstances = summonAll[m.MirroredElemTypes] inline m match case s: Mirror.SumOf[T] =&gt; eqSum(s, elemInstances) case p: Mirror.ProductOf[T] =&gt; eqProduct(p, elemInstances) end Eq Получившийся результат можно проверить относительно простого ADT, например: enum Opt[+T] derives Eq: case Sm(t: T) case Nn @main def test(): Unit = import Opt.* val eqoi = summon[Eq[Opt[Int]]] assert(eqoi.eqv(Sm(23), Sm(23))) assert(!eqoi.eqv(Sm(23), Sm(13))) assert(!eqoi.eqv(Sm(23), Nn)) В этом случае код, сгенерированный встроенным расширением для derived экземпляра Eq для Opt, после небольшой доработки выглядит следующим образом: given derived$Eq[T](using eqT: Eq[T]): Eq[Opt[T]] = eqSum( summon[Mirror[Opt[T]]], List( eqProduct(summon[Mirror[Sm[T]]], List(summon[Eq[T]])), eqProduct(summon[Mirror[Nn.type]], Nil) ) ) Можно использовать альтернативные подходы к определению derived методов. Например, более агрессивно встроенные варианты с использованием макросов Scala 3, хотя и более используемы авторами классов типов, чем в приведенном выше примере, могут создавать код для классов типов наподобие Eq, который устраняет все артефакты абстракции (например, дочерние экземпляры List-а в приведенном выше примере) и генерировать код, который неотличим от того, что программист мог бы написать вручную. В качестве третьего примера, используя библиотеку более высокого уровня, такую как Shapeless, автор класса типов может определить эквивалентный derived метод как: given eqSum[A](using inst: =&gt; K0.CoproductInstances[Eq, A]): Eq[A] with def eqv(x: A, y: A): Boolean = inst.fold2(x, y)(false)( [t] =&gt; (eqt: Eq[t], t0: t, t1: t) =&gt; eqt.eqv(t0, t1) ) given eqProduct[A](using inst: K0.ProductInstances[Eq, A]): Eq[A] with def eqv(x: A, y: A): Boolean = inst.foldLeft2(x, y)(true: Boolean)( [t] =&gt; (acc: Boolean, eqt: Eq[t], t0: t, t1: t) =&gt; Complete(!eqt.eqv(t0, t1))(false)(true) ) inline def derived[A](using gen: K0.Generic[A]): Eq[A] = gen.derive(eqProduct, eqSum) Описанная здесь структура позволяет использовать все три этих подхода, не навязывая ни один из них. Получение экземпляров в другом месте Иногда требуется создать экземпляр класса типов для ADT после того, как ADT определен, без возможности изменения кода самого ADT. Для этого просто определите экземпляр, используя метод derived класса типа в правой части. Например, для реализации Ordering для определения Option: given [T: Ordering]: Ordering[Option[T]] = Ordering.derived Предполагая, что у метода Ordering.derived есть контекстный параметр типа Mirror[T], сгенерированным компилятором экземпляр Mirror для Option будет достаточен, а вывод экземпляра будет расширен в правой части этого определения так же, как экземпляр, определенный в сопутствующих объектах ADT. Как написать метод derived класса типов, используя макросы Ниже демонстрируется, как реализовать derived метод класса типа, используя только макросы. Мы следуем тому же примеру deriving экземпляров Eq и для простоты поддерживаем тип Product, например класс case Person. Низкоуровневый метод, который будет использовать для реализации метода derived, использует кавычки, соединения как выражений, так и типов, а также scala.quoted.Expr.summon метод, эквивалентный методу summonFrom. Первый подходит для использования в контексте кавычек, используемых в макросах. Как и в исходном коде, определение класса типа такое же: trait Eq[T]: def eqv(x: T, y: T): Boolean нам нужно реализовать метод Eq.derived для сопутствующего объекта Eq, который создает quoted экземпляр для Eq[T]. Вот возможная подпись: given derived[T: Type](using Quotes): Expr[Eq[T]] и для сравнения дадим ту же подпись, что и у нас с inline: inline given derived[T]: (m: Mirror.Of[T]) =&gt; Eq[T] = ??? Обратите внимание, что поскольку тип используется на последующем этапе, его необходимо поднять до Type с помощью соответствующей привязки контекста. Кроме того, мы не можем вызвать quoted Mirror внутри тела derived, мы можем опустить его из подписи. Тело метода derived показано ниже: given derived[T: Type](using Quotes): Expr[Eq[T]] = import quotes.reflect.* val ev: Expr[Mirror.Of[T]] = Expr.summon[Mirror.Of[T]].get ev match case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =&gt; val elemInstances = summonAll[elementTypes] val eqProductBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt; elemInstances.zipWithIndex.foldLeft(Expr(true: Boolean)) { case (acc, (elem, index)) =&gt; val e1 = '{$x.asInstanceOf[Product].productElement(${Expr(index)})} val e2 = '{$y.asInstanceOf[Product].productElement(${Expr(index)})} '{ $acc &amp;&amp; $elem.asInstanceOf[Eq[Any]].eqv($e1, $e2) } } '{ eqProduct((x: T, y: T) =&gt; ${eqProductBody('x, 'y)}) } // case for Mirror.ProductOf[T] // ... Обратите внимание, что в этом inline случае можно просто написать summonAll[m.MirroredElemTypes] внутри встроенного метода, но здесь, поскольку это необходимо Expr.summon, можно извлечь типы элементов в виде макроса. Находясь внутри макроса, нашей первой реакцией было бы написать приведенный ниже код. Поскольку путь внутри аргумента типа нестабилен, его нельзя использовать: '{ summonAll[$m.MirroredElemTypes] } Вместо этого мы извлекаем тип кортежа для типов элементов, используя сопоставление с образцом по кавычкам и, более конкретно, уточненный тип: case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =&gt; ... Ниже показана реализация summonAll в виде макроса. Предполагается, что given экземпляры для примитивных типов существуют. def summonAll[T: Type](using Quotes): List[Expr[Eq[_]]] = Type.of[T] match case '[String *: tpes] =&gt; '{ summon[Eq[String]] } :: summonAll[tpes] case '[Int *: tpes] =&gt; '{ summon[Eq[Int]] } :: summonAll[tpes] case '[tpe *: tpes] =&gt; derived[tpe] :: summonAll[tpes] case '[EmptyTuple] =&gt; Nil Еще одно отличие тела derived здесь от тела с inline заключается в том, что с макросами нужно синтезировать тело кода во время макрорасширения. Это обоснование функции eqProductBody. Предполагая, что мы вычисляем равенство двух Persons, определенных с case классом, который содержит имя типа String и возраст типа Int, проверка на равенство, которую хотим сгенерировать, выглядит следующим образом: true &amp;&amp; Eq[String].eqv(x.productElement(0),y.productElement(0)) &amp;&amp; Eq[Int].eqv(x.productElement(1), y.productElement(1)) Вызов производного метода внутри макроса Следуя правилам макросов, мы создаем два метода. Первый, в котором размещается соединение верхнего уровня eqv, и второй - реализация. В качестве альтернативы показанного ниже, можно вызвать метод eqv напрямую. eqGen может вызвать деривацию. extension [T](inline x: T) inline def === (inline y: T)(using eq: Eq[T]): Boolean = eq.eqv(x, y) inline given eqGen[T]: Eq[T] = ${ Eq.derived[T] } Обратите внимание, что используется синтаксис inline метода, и можно сравнивать экземпляры, Sm(Person(\"Test\", 23)) === Sm(Person(\"Test\", 24)), например, для следующих двух типов: case class Person(name: String, age: Int) enum Opt[+T]: case Sm(t: T) case Nn Полный код показан ниже: import scala.deriving.* import scala.quoted.* trait Eq[T]: def eqv(x: T, y: T): Boolean object Eq: given Eq[String] with def eqv(x: String, y: String) = x == y given Eq[Int] with def eqv(x: Int, y: Int) = x == y def eqProduct[T](body: (T, T) =&gt; Boolean): Eq[T] = new Eq[T]: def eqv(x: T, y: T): Boolean = body(x, y) def eqSum[T](body: (T, T) =&gt; Boolean): Eq[T] = new Eq[T]: def eqv(x: T, y: T): Boolean = body(x, y) def summonAll[T: Type](using Quotes): List[Expr[Eq[_]]] = Type.of[T] match case '[String *: tpes] =&gt; '{ summon[Eq[String]] } :: summonAll[tpes] case '[Int *: tpes] =&gt; '{ summon[Eq[Int]] } :: summonAll[tpes] case '[tpe *: tpes] =&gt; derived[tpe] :: summonAll[tpes] case '[EmptyTuple] =&gt; Nil given derived[T: Type](using q: Quotes): Expr[Eq[T]] = import quotes.reflect.* val ev: Expr[Mirror.Of[T]] = Expr.summon[Mirror.Of[T]].get ev match case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =&gt; val elemInstances = summonAll[elementTypes] val eqProductBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt; elemInstances.zipWithIndex.foldLeft(Expr(true: Boolean)) { case (acc, (elem, index)) =&gt; val e1 = '{$x.asInstanceOf[Product].productElement(${Expr(index)})} val e2 = '{$y.asInstanceOf[Product].productElement(${Expr(index)})} '{ $acc &amp;&amp; $elem.asInstanceOf[Eq[Any]].eqv($e1, $e2) } } '{ eqProduct((x: T, y: T) =&gt; ${eqProductBody('x, 'y)}) } case '{ $m: Mirror.SumOf[T] { type MirroredElemTypes = elementTypes }} =&gt; val elemInstances = summonAll[elementTypes] val eqSumBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt; val ordx = '{ $m.ordinal($x) } val ordy = '{ $m.ordinal($y) } val elements = Expr.ofList(elemInstances) '{ $ordx == $ordy &amp;&amp; $elements($ordx).asInstanceOf[Eq[Any]].eqv($x, $y) } '{ eqSum((x: T, y: T) =&gt; ${eqSumBody('x, 'y)}) } end derived end Eq object Macro3: extension [T](inline x: T) inline def === (inline y: T)(using eq: Eq[T]): Boolean = eq.eqv(x, y) inline given eqGen[T]: Eq[T] = ${ Eq.derived[T] } References: Scala 3 Reference Scala 3 Reference, Derivation macros"
    } ,    
    {
      "title": "Импл. type классов",
      "url": "/scalaworkbook/docs/abstractions/ca-type-classes.html",
      "content": "Имплементация type классов Класс типов — это абстрактный параметризованный тип, который позволяет добавлять новое поведение к любому закрытому типу данных без использования подтипов. Это полезно во многих случаях, например: выражение того, как тип, которым вы не владеете, например, из стандартной или сторонней библиотеки, соответствует такому поведению добавление поведения к нескольким типам без введения отношений подтипов между этими типами В Scala 3 классы типов — это просто trait-ы с одним или несколькими параметрами типа, реализации которых предоставляются заданными экземплярами. Пример Рассмотрим Show - хорошо известный класс типов в Haskell. Следующий код показывает один из способов его реализации в Scala 3. Предположим, что классы Scala не имеют метода toString. Можно определить класс Show, чтобы добавить это поведение к любому классу, который необходимо преобразовать в пользовательскую строку. Класс типа Первым шагом в создании класса типа является объявление параметризованного trait, который имеет один или несколько абстрактных методов. Поскольку у Showable есть только один метод с именем show, он написан так: // Класс типа trait Showable[A]: extension(a: A) def show: String В Scala 3 это способ сказать, что любой тип, который реализует этот trait, должен определять, как работает метод show. Обратите внимание, что синтаксис очень близок к обычному trait: // a trait trait Show: def show: String Следует отметить несколько важных моментов: классы типов, такие как Showable, принимают параметр типа A, чтобы установить, для какого типа предоставляется реализация show; Напротив, стандартные trait, такие, как Show, этого не делают. чтобы добавить функциональность show к определенному типу A, стандартный trait требует, чтобы A расширял Show, в то время как для классов типов требуется реализация Showable[A]. чтобы разрешить одинаковый синтаксис вызова метода в обоих Showable, который имитирует один из Show, Showable.show определяется как метод расширения. Реализация конкретных экземпляров Следующий шаг — определить, для каких классов должен работать Showable, а затем реализовать это поведение. Например, чтобы реализовать Showable для данного класса Person: case class Person(firstName: String, lastName: String) нужно определить given значение для Showable[Person]. Этот код предоставляет конкретный экземпляр Showable для класса Person: given Showable[Person] with extension(p: Person) def show: String = s\"${p.firstName} ${p.lastName}\" Как показано, Showable[Person] определяет метод расширения класса Person и использует ссылку p внутри тела метода show. Использование класса типов Этот класс типа можно использовать следующим образом: val person = Person(\"John\", \"Doe\") // person: Person = Person(firstName = \"John\", lastName = \"Doe\") println(person.show) // John Doe Опять же, если бы в Scala не было метода toString, доступного для каждого класса, можно было бы использовать эту технику, чтобы добавить поведение Showable к любому классу, который необходимо преобразовать в String. Написание методов, использующих класс типов Как и в случае с наследованием, можно определить методы, использующие Showable в качестве параметра типа: def showAll[S: Showable](xs: List[S]): Unit = xs.foreach(x =&gt; println(x.show)) showAll(List(Person(\"Jane\", \"Jackson\"), Person(\"Mary\", \"Jameson\"))) // Jane Jackson // Mary Jameson Класс типов с несколькими методами Если необходимо создать класс типов с несколькими методами, исходный синтаксис выглядит следующим образом: trait HasLegs[A]: extension (a: A) def walk(): Unit def run(): Unit Распространенные классы типов Полугруппы и моноиды Вот определение класса типа Monoid: trait SemiGroup[T]: extension (x: T) def combine (y: T): T trait Monoid[T] extends SemiGroup[T]: def unit: T Реализация класса типа Monoid для типа String может быть следующей: given Monoid[String] with extension (x: String) def combine (y: String): String = x.concat(y) def unit: String = \"\" Тогда как для типа Int можно было бы написать следующее: given Monoid[Int] with extension (x: Int) def combine (y: Int): Int = x + y def unit: Int = 0 Этот моноид теперь можно использовать в качестве привязки к контексту в следующем методе combineAll: def combineAll[T: Monoid](xs: List[T]): T = xs.foldLeft(summon[Monoid[T]].unit)(_.combine(_)) Чтобы избавиться от summon[...] можно определить объект Monoid следующим образом: object Monoid: def apply[T](using m: Monoid[T]) = m Что позволило бы переписать метод combineAll следующим образом: def combineAll[T: Monoid](xs: List[T]): T = xs.foldLeft(Monoid[T].unit)(_.combine(_)) Функторы Тип Functor предоставляет возможность “отображать” свои значения, т.е. применять функцию, которая трансформируется внутри значения, сохраняя при этом его форму. Например, чтобы изменить каждый элемент коллекции, не удаляя и не добавляя их. Можно представить все типы, которые могут быть “отображены” с помощью F. Это конструктор типа: тип его значений становится конкретным, когда предоставляется аргумент типа. Поэтому мы пишем F[_], намекая, что тип F принимает в качестве аргумента другой тип. Таким образом, определение generic Functor будет записано как: trait Functor[F[_]]: def map[A, B](x: F[A], f: A =&gt; B): F[B] Что можно было бы прочитать следующим образом: “Конструктор Functor типа F[_] представляет собой возможность преобразования F[A] к F[B] посредством применения функции f с типом A =&gt; B”. Определение Functor здесь - класс типов. Экземпляр Functor для типа List можно определить следующим образом: given Functor[List] with def map[A, B](x: List[A], f: A =&gt; B): List[B] = x.map(f) // в List уже реализован метод `map` С данным экземпляром given в области видимости везде, где доступен Functor, компилятор примет его для использования с List. Например, можно написать такой метод тестирования: def assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A =&gt; B): Unit = assert(expected == summon[Functor[F]].map(original, mapping)) И использовать его, например, так: assertTransformation(List(\"a1\", \"b1\"), List(\"a\", \"b\"), elt =&gt; s\"${elt}1\") Это первый шаг, но на практике желательно, чтобы функция map была методом, доступным непосредственно для типа F. Чтобы можно было экземплярам F напрямую обращаться к map и избавиться от части summon[Functor[F]]. Как и в предыдущем примере моноидов, в этом помогают extension методы. Переопределим класс типов Functor с помощью методов расширения. trait Functor[F[_]]: extension [A](x: F[A]) def map[B](f: A =&gt; B): F[B] Экземпляр given Functor для List становится: given Functor[List] with extension [A](xs: List[A]) def map[B](f: A =&gt; B): List[B] = xs.map(f) Это упрощает метод assertTransformation: def assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A =&gt; B): Unit = assert(expected == original.map(mapping)) Метод map теперь используется непосредственно на original. Он доступен как метод расширения, так как тип original - это F[A] - и экземпляр given, Functor[F[A]], для которого определяется map, находится в области видимости. Монады Применение map в Functor[List] к функции отображения типа A =&gt; B приводит к созданию List[B]. Таким образом, применение его к функции отображения типа A =&gt; List[B] приводит к созданию List[List[B]]. Чтобы избежать управления списками списков, желательно “свести” значения в один список. Вот здесь появляются Monad-ы. Monad-а для F[_] — это Functor[F] + еще две операции: flatMap, который превращает F[A] в F[B] при заданной функции типа A =&gt; F[B], pure, который создает F[A] из одного значения A. Определение монады: trait Monad[F[_]] extends Functor[F]: /** Оборачивание в монаду */ def pure[A](x: A): F[A] extension [A](x: F[A]) /** Основная операция композиции */ def flatMap[B](f: A =&gt; F[B]): F[B] /** Операция `map` может быть определена в терминах `flatMap` */ def map[B](f: A =&gt; B) = x.flatMap(f.andThen(pure)) end Monad Список List можно превратить в монаду через следующий экземпляр given: given listMonad: Monad[List] with def pure[A](x: A): List[A] = List(x) extension [A](xs: List[A]) def flatMap[B](f: A =&gt; List[B]): List[B] = xs.flatMap(f) // можно использовать уже существующий `flatMap` из `List` Поскольку Monad является подтипом Functor, List также является функтором. Метод функтора map уже реализован в trait Monad, поэтому экземпляру не нужно определять его явно. Option Option - ещё один тип, имеющий такое же поведение: given optionMonad: Monad[Option] with def pure[A](x: A): Option[A] = Option(x) extension [A](xo: Option[A]) def flatMap[B](f: A =&gt; Option[B]): Option[B] = xo match case Some(x) =&gt; f(x) case None =&gt; None Reader Другим примером Monad-ы является монада Reader, которая работает с функциями, а не с типами данных, такими как List или Option. Его можно использовать для объединения нескольких функций, которым нужен один и тот же параметр. Например, когда нескольким функциям требуется доступ к некоторой конфигурации, контексту, переменным среды и т. д. Давайте определим тип Config и две функции, использующие его: trait Config // ... def compute(i: Int)(config: Config): String = ??? def show(str: String)(config: Config): Unit = ??? Желательно объединить compute и show в единую функцию, принимающую параметр Config и показывающую результат вычисления. Также желательно использовать монаду, чтобы избежать явной передачи параметра несколько раз. Таким образом, постулируя правильную операцию flatMap, можно было бы написать так: def computeAndShow(i: Int): Config =&gt; Unit = compute(i).flatMap(show) вместо show(compute(i)(config))(config) Определим такую монаду. Во-первых, мы собираемся определить тип с именем ConfigDependent, представляющий функцию, которая при передаче создает Result из Config. type ConfigDependent[Result] = Config =&gt; Result Экземпляр монады будет выглядеть так: given configDependentMonad: Monad[ConfigDependent] with def pure[A](x: A): ConfigDependent[A] = config =&gt; x extension [A](x: ConfigDependent[A]) def flatMap[B](f: A =&gt; ConfigDependent[B]): ConfigDependent[B] = config =&gt; f(x(config))(config) end configDependentMonad Тип ConfigDependent может быть записан с использованием лямбда-выражений типа: type ConfigDependent = [Result] =&gt;&gt; Config =&gt; Result Использование этого синтаксиса превратит предыдущий configDependentMonad в: given configDependentMonad: Monad[[Result] =&gt;&gt; Config =&gt; Result] with def pure[A](x: A): Config =&gt; A = config =&gt; x extension [A](x: Config =&gt; A) def flatMap[B](f: A =&gt; Config =&gt; B): Config =&gt; B = config =&gt; f(x(config))(config) end configDependentMonad Вполне вероятно, что мы бы также хотели использовать этот паттерн с другими типами окружения, не только с trait Config. Монада Reader позволяет абстрагировать Config в параметр типа, названный Ctx в следующем определении: given readerMonad[Ctx]: Monad[[X] =&gt;&gt; Ctx =&gt; X] with def pure[A](x: A): Ctx =&gt; A = ctx =&gt; x extension [A](x: Ctx =&gt; A) def flatMap[B](f: A =&gt; Ctx =&gt; B): Ctx =&gt; B = ctx =&gt; f(x(ctx))(ctx) end readerMonad Резюме Определение класса типа выражается с помощью параметризованного типа с абстрактными элементами, такими как trait. Основное различие между полиморфизмом подтипа и специальным полиморфизмом с классами типов заключается в том, как реализуется определение класса типов по отношению к типу, на который он действует. В случае класса типов его реализация для конкретного типа выражается через определение экземпляра given, предоставляемый как неявный аргумент вместе со значением, на которое он действует. При полиморфизме подтипов реализация смешивается с родительскими элементами класса, и для выполнения полиморфной операции требуется только один терм. Решение класса типов требует больше усилий для настройки, но оно более расширяемо: добавление нового интерфейса в класс требует изменения исходного кода этого класса. Напротив, экземпляры классов типов могут быть определены где угодно. В заключение мы увидели, что trait-ы и экземпляры given в сочетании с другими конструкциями, такими как методы расширения, границы контекста и лямбда-выражения типов, позволяют получить краткое и естественное выражение классов типов. References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Using",
      "url": "/scalaworkbook/docs/abstractions/ca-using.html",
      "content": "Предложения using Функциональное программирование имеет тенденцию выражать большинство зависимостей в виде простой параметризации функций. Это чисто и мощно, но иногда это приводит к функциям, которые принимают много параметров, где одно и то же значение передается снова и снова в длинных цепочках вызовов функций. Здесь могут помочь параметры контекста, поскольку они позволяют компилятору синтезировать повторяющиеся аргументы вместо того, чтобы каждый раз записывать их явно. Например, с экземплярами given intOrd и listOrd функция max, которая работает для любых аргументов с возможностью упорядочивания, может быть определена следующим образом: def max[T](x: T, y: T)(using ord: Ord[T]): T = if ord.compare(x, y) &lt; 0 then y else x Здесь параметр контекста ord вводится с предложением using. Начав секцию параметров с ключевого слова using, мы сообщаем компилятору Scala, что на месте вызова он должен автоматически найти аргумент с правильным типом. Таким образом, компилятор Scala выполняет вывод терминов (term inference). Функцию max можно применить следующим образом: max(2, 3)(using intOrd) // res0: Int = 3 Часть (using intOrd) передает intOrd как аргумент для параметра ord. Но смысл параметров контекста в том, что этот аргумент также можно опустить (и это обычно так и есть). Таким образом, следующие выражения валидны: max(2, 3) // res1: Int = 3 max(List(1, 2, 3), Nil) // res2: List[Int] = List(1, 2, 3) В вызове max(2, 3) компилятор Scala видит, что в области действия есть терм типа Ord[Int], и автоматически предоставит его в max. Анонимные параметры контекста Во многих ситуациях нет необходимости явно упоминать имя параметра контекста, поскольку оно используется только в синтезированных аргументах для других параметров контекста. В этом случае можно не задавать имя параметра и указать только его тип. Например: // не нужно придумывать имя параметра // vvvvvvvvvvvv def maximum[T](xs: List[T])(using Ord[T]): T = xs.reduceLeft(max) maximum принимает контекстный параметр типа Ord[T] только для того, чтобы передать его в качестве предполагаемого аргумента в max. Имя параметра опущено. maximum(List(1, 2, 3)) // res3: Int = 3 Как правило, параметры контекста могут быть определены либо как полный список параметров, (p_1: T_1, ..., p_n: T_n) либо как последовательность типов T_1, ..., T_n. Параметры Vararg не поддерживаются в using предложениях. Явное предоставление контекстных аргументов Подобно тому, как задается раздел параметров с using, контекстные аргументы можно указать явно с помощью того же using: maximum(List(1, 2, 3))(using intOrd) // res4: Int = 3 Явное предоставление контекстных параметров может быть полезно, если в области видимости доступны несколько разных подходящих по типу значений, и мы хотим убедиться, что в функцию передается правильное значение. Параметры контекста класса Если параметр контекста класса становится элементом путем добавления модификатора val или var, то этот член доступен как экземпляр given. Сравните следующие примеры, в которых попытка указать явный элемент given приводит к двусмысленности: class GivenIntBox(using val givenInt: Int): def n = summon[Int] class GivenIntBox2(using givenInt: Int): given Int = givenInt //def n = summon[Int] // неопределенность Элемент given можно импортировать, как описано в разделе об импорте givens: val b = GivenIntBox(using 23) import b.given summon[Int] // 23 import b.* //givenInt // Not found Вывод сложных аргументов Вот два других метода, которые используют контекстный параметр типа Ord[T]: def descending[T](using asc: Ord[T]): Ord[T] = new Ord[T]: def compare(x: T, y: T) = asc.compare(y, x) def minimum[T](xs: List[T])(using Ord[T]) = maximum(xs)(using descending) Тело метода minimum передает descending как явный аргумент в maximum(xs). С этой настройкой все следующие вызовы нормализуются так: val xs = List(List(1,2,3), Nil) // xs: List[List[Int]] = List(List(1, 2, 3), List()) minimum(xs) // res5: List[Int] = List() maximum(xs)(using descending) // res6: List[Int] = List() maximum(xs)(using descending(using listOrd)) // res7: List[Int] = List() maximum(xs)(using descending(using listOrd(using intOrd))) // res8: List[Int] = List() Несколько using В определении может быть несколько using предложений, и using предложения можно свободно смешивать с обычными предложениями параметров. Пример: def f(u: Universe)(using ctx: u.Context)(using s: ctx.Symbol, k: ctx.Kind) = ... В коде несколько using предложений сопоставляются слева направо. Пример: object global extends Universe { type Context = ... } given ctx : global.Context with { type Symbol = ...; type Kind = ... } given sym : ctx.Symbol given kind: ctx.Kind Тогда все следующие вызовы действительны (и нормализуются до последнего) f(global) f(global)(using ctx) f(global)(using ctx)(using sym, kind) Но f(global)(using sym, kind) выдало бы ошибку типа. Вызов экземпляров Метод summon в Predef возвращает given определенного типа. Например, вот как можно вызвать given экземпляр для Ord[List[Int]]: summon[Ord[List[Int]]] // reduces to listOrd(using intOrd) Метод summon определяется как (нерасширяющая) функция идентификации по параметру контекста. def summon[T](using x: T): x.type = x References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Case classes",
      "url": "/scalaworkbook/docs/modeling/case-class.html",
      "content": "Case classes и Case objects Case classes Scala case class позволяет моделировать концепции с неизменяемыми структурами данных. case class обладает всеми функциональными возможностями класса, а также имеет встроенные дополнительные функции, которые делают их полезными для функционального программирования. case class имеет следующие эффекты и преимущества: Параметры конструктора case class по умолчанию являются общедоступными полями val, поэтому поля являются неизменяемыми, а методы доступа генерируются для каждого параметра. Генерируется метод unapply, который позволяет использовать case class в match выражениях. В классе создается метод copy, который позволяет создавать копии объекта без изменения исходного объекта. генерируются методы equals и hashCode для проверки структурного равенства, что позволяет использовать экземпляры case class в Map. генерируется метод toString, который полезен для отладки. Этот код демонстрирует несколько функций case class: case class Person(name: String, vocation: String) val person = Person(\"Reginald Kenneth Dwight\", \"Singer\") // person: Person = Person( // name = \"Reginald Kenneth Dwight\", // vocation = \"Singer\" // ) person.name // res1: String = \"Reginald Kenneth Dwight\" Необходимо помнить, что поля в case class-е неизменяемые: person.name = \"Joe\" // error: Reassignment to val name Остальные возможности продемонстрированы в коде: println(person) // Person(Reginald Kenneth Dwight,Singer) person match case Person(n, r) =&gt; println(\"name is \" + n) // name is Reginald Kenneth Dwight val elton = Person(\"Elton John\", \"Singer\") // elton: Person = Person(name = \"Elton John\", vocation = \"Singer\") person == elton // res4: Boolean = false case class BaseballTeam(name: String, lastWorldSeriesWin: Int) val cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908) // cubs1908: BaseballTeam = BaseballTeam( // name = \"Chicago Cubs\", // lastWorldSeriesWin = 1908 // ) val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016) // cubs2016: BaseballTeam = BaseballTeam( // name = \"Chicago Cubs\", // lastWorldSeriesWin = 2016 // ) Поддержка функционального программирования Как уже упоминалось ранее, case class-ы поддерживают функциональное программирование (ФП): ФП избегает изменения структур данных. Поэтому поля конструктора по умолчанию имеют значение val. Поскольку экземпляры case class не могут быть изменены, ими можно легко делиться, не опасаясь мутаций или условий гонки. вместо изменения экземпляра можно использовать метод copy в качестве шаблона для создания нового (потенциально измененного) экземпляра. Этот процесс можно назвать “обновлением по мере копирования”. наличие автоматически сгенерированного метода unapply позволяет использовать case class в сопоставлении шаблонов. Case objects Case object-ы относятся к объектам так же, как case class-ы относятся к классам: они предоставляют ряд автоматически генерируемых методов, чтобы сделать их более мощными. Case object-ы особенно полезны тогда, когда необходим одноэлементный объект, который нуждается в небольшой дополнительной функциональности, например, для использования с сопоставлением шаблонов в выражениях match. Case object-ы полезны, когда необходимо передавать неизменяемые сообщения. Например, представим проект музыкального проигрывателя, и создадим набор команд или сообщений: sealed trait Message case class PlaySong(name: String) extends Message case class IncreaseVolume(amount: Int) extends Message case class DecreaseVolume(amount: Int) extends Message case object StopPlaying extends Message Затем в других частях кода можно написать методы, которые используют сопоставление с образцом для обработки входящего сообщения (при условии, что методы playSong, changeVolume и stopPlayingSong определены где-то еще): def handleMessages(message: Message): Unit = message match case PlaySong(name) =&gt; playSong(name) case IncreaseVolume(amount) =&gt; changeVolume(amount) case DecreaseVolume(amount) =&gt; changeVolume(-amount) case StopPlaying =&gt; stopPlayingSong() References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Classes",
      "url": "/scalaworkbook/docs/modeling/classes.html",
      "content": "Classes Как и в других языках, класс в Scala — это шаблон для создания экземпляров объекта. Вот несколько примеров классов: class Person(var name: String, var vocation: String) class Book(var title: String, var author: String, var year: Int) class Movie(var name: String, var director: String, var year: Int) Эти примеры показывают, как в Scala объявляются классы. В примере выше все параметры классов определены как поля var, что означает, что они изменяемы. Если необходимо, чтобы они были неизменяемыми, можно определить их как val или использовать case class. Новый экземпляр класса создается следующим образом (без ключевого слова new, благодаря универсальным apply методам, см. ниже): val p = Person(\"Robert Allen Zimmerman\", \"Harmonica Player\") Если есть экземпляр класса, такого как p, то можно получить доступ к его полям, которые в этом примере являются параметрами конструктора: p.name // res0: String = \"Robert Allen Zimmerman\" p.vocation // res1: String = \"Harmonica Player\" Как уже упоминалось, все эти параметры были созданы как поля var, поэтому их можно изменять: p.name = \"Bob Dylan\" p.vocation = \"Musician\" Поля и методы Классы также могут иметь методы и дополнительные поля, не являющиеся частью конструкторов. Они определены в теле класса. Тело инициализируется как часть конструктора по умолчанию: class Person(var firstName: String, var lastName: String): println(\"initialization begins\") val fullName = s\"$firstName $lastName\" def printFullName: Unit = println(fullName) printFullName println(\"initialization ends\") Пример демонстрирует, как происходит инициализация класса: val john = Person(\"John\", \"Doe\") // initialization begins // John Doe // initialization ends // john: Person = repl.MdocSession$App4$Person@546ab436 john.printFullName // John Doe Классы также могут расширять trait-ы и абстрактные классы, которые будут рассмотрены в специальных разделах ниже. Параметры по умолчанию Параметры конструктора класса также могут иметь значения по умолчанию: class Socket(val timeout: Int = 5_000, val linger: Int = 5_000): override def toString = s\"timeout: $timeout, linger: $linger\" Отличительной особенностью этой функции является то, что она позволяет пользователям кода создавать классы различными способами, как если бы у класса были альтернативные конструкторы: Socket() // res6: Socket = timeout: 5000, linger: 5000 Socket(2_500) // res7: Socket = timeout: 2500, linger: 5000 Socket(10_000, 10_000) // res8: Socket = timeout: 10000, linger: 10000 Socket(timeout = 10_000) // res9: Socket = timeout: 10000, linger: 5000 Socket(linger = 10_000) // res10: Socket = timeout: 5000, linger: 10000 При создании нового экземпляра класса также можно использовать именованные параметры. Это приветствуется и особенно полезно, когда параметры имеют одинаковый тип: Socket(10_000, 10_001) // res11: Socket = timeout: 10000, linger: 10001 Socket(timeout = 10_000, linger = 10_001) // res12: Socket = timeout: 10000, linger: 10001 Socket(linger = 10_000, timeout = 10_001) // res13: Socket = timeout: 10001, linger: 10000 Вспомогательные конструкторы В классе можно определить несколько конструкторов. Например, предположим, что нужно определить три конструктора класса Student: с именем и государственным ID (1) с именем, государственным ID и датой подачи заявления (2) с именем, государственным ID и студенческим ID (3) Пример описания класса с тремя этими конструкторами: import java.time.* class Student(var name: String, var govtId: String): // [1] основной конструктор private var _applicationDate: Option[LocalDate] = None private var _studentId: Int = 0 def this(name: String, govtId: String, applicationDate: LocalDate) = // [2] конструктор с датой подачи заявления this(name, govtId) _applicationDate = Some(applicationDate) def this(name: String, govtId: String, studentId: Int) = // [3] конструктор со студенческим id this(name, govtId) _studentId = studentId Эти конструкторы могут быть вызваны следующим образом: Student(\"Mary\", \"123\") Student(\"Mary\", \"123\", LocalDate.now) Student(\"Mary\", \"123\", 456) Для возможности создания классов несколькими способами можно использовать как параметры по умолчанию, так и несколько конструкторов, как в примере выше. Универсальные apply методы Scala 3 обобщает схему генерации apply методов на все конкретные классы. Т.е., как упоминалось выше, можно создавать экземпляры класса без ключевого слова new. Пример: class StringBuilder(s: String): def this() = this(\"\") StringBuilder(\"abc\") // устаревший вариант: new StringBuilder(\"abc\") StringBuilder() // устаревший вариант: new StringBuilder() Это работает, поскольку вместе с классом создается сопутствующий объект с двумя apply методами. Объект выглядит так: object StringBuilder: inline def apply(s: String): StringBuilder = new StringBuilder(s) inline def apply(): StringBuilder = new StringBuilder() Синтетический объект StringBuilder и его apply методы называются прокси-конструкторами. Прокси-конструкторы генерируются даже для классов Java и классов из Scala 2. Точные правила следующие: прокси-конструктор сопутствующего объекта object C создается для конкретного класса C при условии, что класс еще не имеет сопутствующего объекта, а также нет другого значения или метода с именем C, определенным или унаследованным в области, в которой он определен. прокси-конструкторы apply методов генерируются для предоставленного конкретного класса если: у класса есть объект-компаньон (который мог быть сгенерирован на шаге 1) и этот сопутствующий объект еще не определяет элемент с именем apply. каждый сгенерированный apply метод пересылается одному конструктору класса. Он имеет те же параметры типа и значения, что и конструктор. Прокси-конструкторы сопутствующего объекта не могут использоваться в качестве значений сами по себе. Они должны быть выбраны с помощью apply (или применены к аргументам, и в этом случае apply неявно вставляется). Прокси-конструкторы также не могут затенять обычные определения. То есть, если идентификатор разрешается в прокси конструктор, и тот же идентификатор также определен или импортирован в какой-либо другой области, сообщается о неоднозначности. References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects Scala 3 Reference, Universal Apply Methods"
    } ,    
    {
      "title": "Типы коллекций",
      "url": "/scalaworkbook/docs/collections/classes.html",
      "content": "Типы коллекций В этом разделе продемонстрированы наиболее распространенные типы коллекций и их методы. В конце этого раздела для получения более подробной информации представлены дополнительные ссылки для более глубокого изучения коллекций. Три основные категории коллекций Для коллекций Scala можно выделить три основные категории: Последовательности (Sequences/Seq) представляют собой последовательный набор элементов и могут быть индексированными (как массив) или линейными (как связанный список) Карты (Maps) содержат набор пар ключ/значение, например Java Map, Python dictionary или Ruby Hash Множества (Sets) — это неупорядоченный набор уникальных элементов Все они являются базовыми типами и имеют подтипы для конкретных целей, таких как параллелизм (concurrency), кэширование (caching) и потоковая передача (streaming). В дополнение к этим трем основным категориям существуют и другие полезные типы коллекций, включая диапазоны (ranges), стеки (stacks) и очереди (queues). Иерархия коллекций В качестве краткого обзора следующие три рисунка показывают иерархию классов и трейтов в коллекциях Scala. На первом рисунке показаны типы коллекций в пакете scala.collection. Все это высокоуровневые абстрактные классы или трейты, которые обычно имеют неизменяемые и изменяемые реализации. На этом рисунке показаны все коллекции в пакете scala.collection.immutable: А на этом рисунке показаны все коллекции в пакете scala.collection.mutable: В следующих разделах представлены некоторые из распространенных типов. Общие коллекции Основные коллекции, используемые чаще всего: Тип коллекции Неизменяемая Изменяемая Описание List ✓   Линейная неизменяемая последовательность (связный список) Vector ✓   Индексированная неизменяемая последовательность LazyList ✓   Ленивый неизменяемый связанный список, элементы которого вычисляются только тогда, когда они необходимы; подходит для больших или бесконечных последовательностей. ArrayBuffer   ✓ Подходящий тип для изменяемой индексированной последовательности ListBuffer   ✓ Используется, когда вам нужен изменяемый список; обычно преобразуется в List Map ✓ ✓ Итерируемая коллекция, состоящая из пар ключей и значений Set ✓ ✓ Итерируемая коллекция без повторяющихся элементов Как показано, Map и Set бывают как неизменяемыми, так и изменяемыми. Основы каждого типа демонстрируются в следующих разделах. В Scala буфер, такой как ArrayBuffer или ListBuffer, представляет собой последовательность, которая может увеличиваться и уменьшаться. Примечание о неизменяемых коллекциях В последующих разделах всякий раз, когда используется слово immutable, можно с уверенностью сказать, что тип предназначен для использования в стиле функционального программирования (ФП). С помощью таких типов коллекция не меняется, а при вызове функциональных методов возвращается новый результат - новая коллекция. Выбор последовательности При выборе последовательности нужно руководствоваться двумя основными вопросами: должна ли последовательность индексироваться (как массив), обеспечивая быстрый доступ к любому элементу, или она должна быть реализована как линейный связанный список? необходима изменяемая или неизменяемая коллекция? Рекомендуемые универсальные последовательности: Тип \\ Категория Неизменяемая Изменяемая индексируемая Vector ArrayBuffer линейный связанный список List ListBuffer Например, если нужна неизменяемая индексированная коллекция, в общем случае следует использовать Vector. И наоборот, если нужна изменяемая индексированная коллекция, используйте ArrayBuffer. List и Vector часто используются при написании кода в функциональном стиле. ArrayBuffer обычно используется при написании кода в императивном стиле. ListBuffer используется, когда стили смешиваются, например, при создании списка. Следующие несколько разделов кратко демонстрируют типы List, Vector и ArrayBuffer. Подробнее Для дополнительной информации о коллекциях, см. следующие ресурсы: Как устроены коллекции? Какую из них выбирать? References: Scala3 book Scala3 book, Collections Types"
    } ,    
    {
      "title": "Коллекции",
      "url": "/scalaworkbook/docs/collections.html",
      "content": "Коллекции Scala поставляется с большим количеством типов коллекций, на изучение которых может уйти время, поэтому желательно начать с нескольких из них, а затем использовать остальные по мере необходимости. Точно так же у каждого типа коллекции есть десятки методов, облегчающих разработку, но также желательно начать с нескольких из них. Поэтому в этом разделе продемонстрированы наиболее распространенные типы и методы коллекций. Более подробная информация о типах коллекций, показанных в этой главе, доступна в Scaladoc: List Vector ArrayBuffer Range Также упоминаются неизменяемые Map и Set: Map Set и изменяемые Map и Set: Map Set References: Scala3 book, Collections intro Scala3 book"
    } ,    
    {
      "title": "Companion objects",
      "url": "/scalaworkbook/docs/modeling/companion-objects.html",
      "content": "Companion objects Объект, который имеет то же имя, что и класс, и объявлен в том же файле, что и класс, называется “сопутствующим объектом” (companion object). Аналогично, соответствующий класс называется сопутствующим классом объекта (companion class). Сопутствующий класс или объект может получить доступ к закрытым членам своего “соседа”. Сопутствующие объекты используются для методов и значений, которые не являются специфичными для экземпляров сопутствующего класса. В следующем примере класс Circle содержит метод с именем area, который специфичен для каждого экземпляра. А его сопутствующий объект содержит метод с именем calculateArea, который (а) не специфичен для экземпляра и (б) доступен для каждого экземпляра: import scala.math.* case class Circle(radius: Double): import Circle.* def area: Double = calculateArea(radius) object Circle: private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0) val circle = Circle(5.0) circle.area // res0: Double = 78.53981633974483 В этом примере метод area, доступный для каждого экземпляра Circle, использует метод calculateArea, определенный в сопутствующем объекте. Кроме того, поскольку calculateArea является закрытым, к нему нельзя получить доступ с помощью другого кода, но, как показано, его могут видеть экземпляры класса Circle. Другие виды использования сопутствующих объектов Сопутствующие объекты могут использоваться для нескольких целей: их можно использовать для группировки “статических” методов в пространстве имен, как в примере выше эти методы могут быть public или private если бы calculateArea был public, к нему можно было бы получить доступ из любого места как Circle.calculateArea они могут содержать методы apply, которые — благодаря некоторому синтаксическому сахару — работают как фабричные методы для создания новых экземпляров они могут содержать методы unapply, которые используются для деконструкции объектов, например, с помощью pattern matching Вот краткий обзор того, как методы apply можно использовать в качестве фабричных методов для создания новых объектов: class Person: var name = \"\" var age = 0 override def toString = s\"$name is $age years old\" object Person: def apply(name: String): Person = // a one-arg factory method val p = new Person p.name = name p def apply(name: String, age: Int): Person = // a two-arg factory method val p = new Person p.name = name p.age = age p end Person val joe = Person(\"Joe\") // joe: Person = Joe is 0 years old val fred = Person(\"Fred\", 29) // fred: Person = Fred is 29 years old References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Compile-time ops",
      "url": "/scalaworkbook/docs/metaprogramming/compile-time-ops.html",
      "content": "Операции во время компиляции Пакет scala.compiletime Пакет scala.compiletime содержит операции метапрограммирования, которые можно использовать внутри inline метода. Эти операции охватывают некоторые распространенные случаи использования макросов без необходимости определения макроса. Reporting Метод error используется для создания определяемых пользователем ошибок компиляции во время встроенного расширения. Он имеет следующую подпись: inline def error(inline msg: String): Nothing Если встроенное расширение приводит к вызову error(msgStr), компилятор выдает сообщение об ошибке, содержащее заданный msgStr. import scala.compiletime.error inline def doSomething(inline mode: Boolean): Unit = if mode then println(\"true\") else if !mode then println(\"false\") else error(\"Mode must be a known value\") doSomething(true) // true doSomething(false) // false val bool: Boolean = true doSomething(bool) // error: // Mode must be a known value Если error вызывается вне inline метода, при компиляции этого вызова будет выдаваться ошибка. Если error написан внутри inline метода, ошибка будет выдаваться только в том случае, если после встраивания вызова он не будет удален как часть мертвой ветки. В предыдущем примере, если бы значение mode было известно во время компиляции, сохранена была бы только одна из первых двух ветвей и ошибки компиляции не было бы. Если желательно включить часть исходного кода аргументов в сообщение об ошибке, можно использовать метод codeOf. import scala.compiletime.{codeOf, error} inline def doSomething(inline mode: Boolean): Unit = if mode then println(\"true\") else if !mode then println(\"false\") else error(\"Mode must be a known value but got: \" + codeOf(mode)) val bool: Boolean = true doSomething(bool) |doSomething(bool) |^^^^^^^^^^^^^^^^^ |Mode must be a known value but got: bool Выборочный вызов имплицитов (Summoning) summonFrom Предполагается, что многие области программирования на уровне типов могут выполняться с помощью методов перезаписи вместо implicits. Но иногда implicits неизбежны. До сих пор проблема заключалась в том, что стиль программирования неявного поиска, подобный Prolog, становится вирусным: как только некоторая конструкция зависит от неявного поиска, она сама должна быть написана как логическая программа. Рассмотрим, например, проблему создания TreeSet[T] или HashSet[T] в зависимости от того, имеет ли тип T Ordering или нет. Мы можем создать набор неявных определений следующим образом: trait SetFor[T, S &lt;: Set[T]] class LowPriority: implicit def hashSetFor[T]: SetFor[T, HashSet[T]] = ... object SetsFor extends LowPriority: implicit def treeSetFor[T: Ordering]: SetFor[T, TreeSet[T]] = ... Понятно, что это некрасиво. Помимо всей обычной косвенности неявного поиска, мы сталкиваемся с проблемой определения приоритетов правил, когда мы должны гарантировать, что treeSetFor имеет приоритет над hashSetFor, если тип элемента имеет Ordering. Это решается (неуклюже) путем добавления hashSetFor в суперкласс LowPriority объекта SetsFor, где определен treeSetFor. Возможно, шаблон все еще был бы приемлем, если бы можно было сдержать грубый код. Однако, это не так. Каждый пользователь абстракции должен быть параметризован с помощью имплицитного SetFor. Принимая во внимание простую задачу “Я хочу TreeSet[T], если T можно упорядочить, иначе — HashSet[T]”, это кажется слишком церемонным. Есть некоторые предложения по улучшению ситуации в конкретных областях, например, путем разрешения более сложных схем определения приоритетов. Но все они сохраняют вирусный характер программ неявного поиска, основанных на логическом программировании. Напротив, новая конструкция summonFrom делает неявный поиск доступным в функциональном контексте. Чтобы решить проблему создания правильного набора, можно было бы использовать его следующим образом: import scala.compiletime.summonFrom inline def setFor[T]: Set[T] = summonFrom { case ord: Ordering[T] =&gt; new TreeSet[T]()(using ord) case _ =&gt; new HashSet[T] } Вызов summonFrom принимает pattern matching в качестве аргумента. Все паттерны в замыкании являются атрибуциями типа формы identifier : Type. Паттерны примеряются последовательно. Выбирается первый паттерн x: T, при котором может быть вызвано неявное значение типа T. В качестве альтернативы можно также использовать given экземпляр с привязкой к шаблону, что позволяет избежать явного предложения using. Например, setFor можно было бы также сформулировать следующим образом: import scala.compiletime.summonFrom inline def setFor[T]: Set[T] = summonFrom { case given Ordering[T] =&gt; new TreeSet[T] case _ =&gt; new HashSet[T] } summonFrom приложения должны быть уменьшены во время компиляции. Следовательно, если мы вызовем Ordering[String], то вернется новый экземпляр TreeSet[String]. summon[Ordering[String]] println(setFor[String].getClass) // prints class scala.collection.immutable.TreeSet Отметим, приложения summonFrom могут вызывать ambiguity errors. Рассмотрим следующий код с двумя given в области видимости типа A. Совпадение с шаблоном f вызовет ошибку неоднозначности f. class A given a1: A = new A given a2: A = new A inline def f: Any = summonFrom { case given _: A =&gt; ??? // error: ambiguous givens } summonInline Сокращение summonInline обеспечивает простой способ написать summon, который откладывается до тех пор, пока вызов не будет встроен. В отличие от summonFrom, summonInline также выдает ошибку неявного отсутствия (implicit-not-found error), если данный экземпляр вызываемого типа не найден. import scala.compiletime.summonInline import scala.annotation.implicitNotFound @implicitNotFound(\"Missing One\") trait Missing1 @implicitNotFound(\"Missing Two\") trait Missing2 trait NotMissing given NotMissing = ??? transparent inline def summonInlineCheck[T &lt;: Int](inline t : T) : Any = inline t match case 1 =&gt; summonInline[Missing1] case 2 =&gt; summonInline[Missing2] case _ =&gt; summonInline[NotMissing] val missing1 = summonInlineCheck(1) // error: Missing One val missing2 = summonInlineCheck(2) // error: Missing Two val notMissing : NotMissing = summonInlineCheck(3) Values constValue и constValueOpt constValue - это функция, которая производит постоянное значение, представленное типом. import scala.compiletime.constValue import scala.compiletime.ops.int.S transparent inline def toIntC[N]: Int = inline constValue[N] match case 0 =&gt; 0 case _: S[n1] =&gt; 1 + toIntC[n1] inline val ctwo = toIntC[2] constValueOpt - то же самое, что и constValue, но возвращает Option[T], что позволяет обрабатывать ситуации, когда значение отсутствует. Обратите внимание, что S - это тип преемника некоторого одноэлементного типа. Например, S[1] - это одноэлементный тип 2. Inline Matching erasedValue До сих пор были показаны встроенные (inline) методы, которые принимают термины (кортежи и целые числа) в качестве параметров. Что, если вместо этого необходимо основывать различия на типах? Например, хотелось бы иметь возможность написать функцию defaultValue, которая для заданного типа T возвращает Option значение по умолчанию для T, если оно существует. Можно выразить это, используя переписывающие выражения соответствия и простую вспомогательную функцию scala.compiletime.erasedValue, которая определяется следующим образом: def erasedValue[T]: T Функция erasedValue делает вид, что возвращает значение аргумента типа T. Вызов этой функции всегда будет приводить к ошибке времени компиляции, если вызов не будет удален из кода при встраивании. Используя erasedValue, можно определить defaultValue следующим образом: import scala.compiletime.erasedValue transparent inline def defaultValue[T] = inline erasedValue[T] match case _: Byte =&gt; Some(0: Byte) case _: Char =&gt; Some(0: Char) case _: Short =&gt; Some(0: Short) case _: Int =&gt; Some(0) case _: Long =&gt; Some(0L) case _: Float =&gt; Some(0.0f) case _: Double =&gt; Some(0.0d) case _: Boolean =&gt; Some(false) case _: Unit =&gt; Some(()) case _ =&gt; None Затем: val dInt: Some[Int] = defaultValue[Int] // dInt: Some[Int] = Some(value = 0) val dDouble: Some[Double] = defaultValue[Double] // dDouble: Some[Double] = Some(value = 0.0) val dBoolean: Some[Boolean] = defaultValue[Boolean] // dBoolean: Some[Boolean] = Some(value = false) val dAny: None.type = defaultValue[Any] // dAny: None = None В качестве другого примера рассмотрим приведенную ниже версию на уровне типов toInt: для заданного типа, представляющего число Пеано, вернуть соответствующее ему целочисленное значение. Рассмотрим определения чисел, как в разделе “inline match”. Вот как можно определить toIntT: transparent inline def toIntT[N &lt;: Nat]: Int = inline scala.compiletime.erasedValue[N] match case _: Zero.type =&gt; 0 case _: Succ[n] =&gt; toIntT[n] + 1 inline val two = toIntT[Succ[Succ[Zero.type]]] erasedValue - это erased метод, поэтому его нельзя использовать и он не имеет поведения во время выполнения. Поскольку toIntT выполняет статические проверки статического типа N, его можно безопасно использовать для тщательного изучения возвращаемого типа (в данном случае - S[S[Z]]). Операции (scala.compiletime.ops) Пакет scala.compiletime.ops содержит типы, обеспечивающие поддержку примитивных операций над одноэлементными типами. Например, scala.compiletime.ops.int.* обеспечивает поддержку умножения двух одноэлементных типов Int, scala.compiletime.ops.boolean.&amp;&amp; - объединения двух Boolean типов. Когда все аргументы типа scala.compiletime.ops являются одноэлементными типами, компилятор может оценить результат операции. import scala.compiletime.ops.int.* import scala.compiletime.ops.boolean.* val conjunction: true &amp;&amp; true = true val multiplication: 3 * 5 = 15 Многие из этих одноэлементных операций предназначены для использования в инфиксе (как в SLS §3.2.10). Поскольку псевдонимы типов имеют те же правила приоритета, что и их эквиваленты на уровне терминов, операции составляются с ожидаемыми правилами приоритета: import scala.compiletime.ops.int.* val x: 1 + 2 * 3 = 7 Типы операций расположены в пакетах, названных по типу левого параметра: например, scala.compiletime.ops.int.+ представляет собой сложение двух чисел, а scala.compiletime.ops.string.+ представляет собой конкатенацию строк. Чтобы использовать оба типа и отличить их друг от друга, тип соответствия может отправляться в правильную реализацию: import scala.compiletime.ops.* type +[X &lt;: Int | String, Y &lt;: Int | String] = (X, Y) match case (Int, Int) =&gt; int.+[X, Y] case (String, String) =&gt; string.+[X, Y] val concat: \"a\" + \"b\" = \"ab\" val addition: 1 + 1 = 2 Детали Дополнительная информация об операциях во время компиляции: PR #4768, PR #7201. References: Scala 3 Reference Scala 3 Guide"
    } ,    
    {
      "title": "Параллелизм",
      "url": "/scalaworkbook/docs/concurrency.html",
      "content": "Параллелизм Для написания параллельных приложений на Scala, можно использовать нативный поток Java, но Scala Future предлагает более высокий уровень и идиоматический подход. Введение Вот описание Scala Future из его Scaladoc: “Future представляет собой значение, которое может быть или не быть доступным в настоящее время, но будет доступно в какой-то момент, или исключение, если это значение не может быть сделано доступным”. Чтобы продемонстрировать, что это значит, сначала рассмотрим однопоточное программирование. В однопоточном мире результат вызова метода привязывается к переменной следующим образом: def aShortRunningTask(): Int = 42 val x = aShortRunningTask() В этом коде значение 42 сразу привязывается к x. При работе с Future процесс назначения выглядит примерно так: def aLongRunningTask(): Future[Int] = ??? val x = aLongRunningTask() Но главное отличие в этом случае заключается в том, что, поскольку aLongRunningTask возвращает неопределенное время, значение x может быть доступно или недоступно в данный момент, но оно будет доступно в какой-то момент — в будущем. Другой способ взглянуть на это с точки зрения блокировки. В этом однопоточном примере оператор println не печатается до тех пор, пока не завершится выполнение aShortRunningTask: def aShortRunningTask(): Int = Thread.sleep(500) 42 val x = aShortRunningTask() println(\"Here\") И наоборот, если aShortRunningTask создается как Future, оператор println печатается почти сразу, потому что aShortRunningTask порождается в другом потоке — он не блокируется. В этой главе будет рассказано, как использовать Future, в том числе как запускать несколько Future параллельно и объединять их результаты в выражении for. Также будут показаны примеры методов, которые используются для обработки значения Future после его возврата. О Future, важно знать, что они задуманы как одноразовая конструкция “Обработайте это относительно медленное вычисление в каком-нибудь другом потоке и перезвоните мне с результатом, когда закончите”. В отличие от этого, акторы Akka предназначены для работы в течение длительного времени и отвечают на множество запросов в течение своей жизни. В то время как субъект может жить вечно, Future в конечном итоге содержит результат вычисления, которое выполнялось только один раз. Пример в REPL Future используется для создания временного кармана параллелизма. Например, можно использовать Future, когда нужно вызвать алгоритм, который выполняется неопределенное количество времени — например, вызов удаленного микросервиса, — поэтому его желательно запустить вне основного потока. Чтобы продемонстрировать, как это работает, начнем с примера Future в REPL. Во-первых, вставим необходимые инструкции импорта: import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global import scala.util.{Failure, Success} Теперь можно создать Future. Для этого примера сначала определим долговременный однопоточный алгоритм: def longRunningAlgorithm() = Thread.sleep(10_000) 42 Этот причудливый алгоритм возвращает целочисленное значение 42 после десятисекундной задержки. Теперь вызовем этот алгоритм, поместив его в конструктор Future и присвоив результат переменной: scala&gt; val eventualInt = Future(longRunningAlgorithm()) eventualInt: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;) Вычисления начинают выполняться после вызова longRunningAlgorithm(). Если сразу проверить значение переменной eventualInt, то можно увидеть, что Future еще не завершен: scala&gt; eventualInt val res1: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;) Но если проверить через десять секунд еще раз, то можно увидеть, что оно выполнено успешно: scala&gt; eventualInt val res2: scala.concurrent.Future[Int] = Future(Success(42)) Хотя это относительно простой пример, он демонстрирует основной подход: просто создайте новое Future с помощью своего долговременного алгоритма. Одна вещь, на которую следует обратить внимание - это то, что ожидаемый результат 42 обернут в Success, который обернут в Future. Это ключевая концепция для понимания: значение Future всегда является экземпляром одного из scala.util.Try: Success или Failure. Поэтому, при работе с результатом Future, используются обычные методы обработки Try. Использование map с Future Future имеет метод map, который используется точно так же, как метод map для коллекций. Вот как выглядит результат, при вызове map сразу после создания переменной eventualInt: scala&gt; val a = eventualInt.map(_ * 2) a: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;) Как показано, для Future, созданного с помощью longRunningAlgorithm, первоначальный вывод показывает Future(&lt;not completed&gt;). Но если проверить значение a через десять секунд, то можно увидеть, что оно содержит ожидаемый результат 84: scala&gt; a res1: scala.concurrent.Future[Int] = Future(Success(84)) Еще раз, успешный результат обернут внутри Success и Future. Использование методов обратного вызова с Future В дополнение к функциям высшего порядка, таким как map, с Future также можно использовать методы обратного вызова. Одним из часто используемых методов обратного вызова является onComplete, принимающий частичную функцию, в которой обрабатываются случаи Success и Failure: eventualInt.onComplete { case Success(value) =&gt; println(s\"Got the callback, value = $value\") case Failure(e) =&gt; e.printStackTrace } Если вставить этот код в REPL, то в конечном итоге придет результат: Got the callback, value = 42 Другие методы Future Класс Future имеет некоторые методы, которые можно найти в классах коллекций Scala, в том числе: filter flatMap map Методы обратного вызова: onComplete andThen foreach Другие методы трансформации: fallbackTo recover recoverWith См. страницу “Futures and Promises” для обсуждения дополнительных методов, доступных для Future. Запуск нескольких Future и объединение результатов Чтобы запустить несколько вычислений параллельно и соединить их результаты после завершения всех Future, можно использовать выражение for. Правильный подход такой: Запустить вычисления, которые возвращают Future результаты Объединить их результаты в выражении for Извлечь объединенный результат, используя onComplete или аналогичный метод Пример Рассмотрим следующий пример. Ключевой момент - сначала запускаются вычисления, возвращающие Future, а затем они объединяются в выражении for: import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global import scala.util.{Failure, Success} val startTime = System.currentTimeMillis() def delta() = System.currentTimeMillis() - startTime def sleep(millis: Long) = Thread.sleep(millis) @main def multipleFutures1 = println(s\"creating the futures: ${delta()}\") // (1) запуск вычислений, возвращающих Future val f1 = Future { sleep(800); 1 } // в конце концов возвращается 1 val f2 = Future { sleep(200); 2 } // в конце концов возвращается 2 val f3 = Future { sleep(400); 3 } // в конце концов возвращается 3 // (2) объединение нескольких Future в выражении `for` val result = for r1 &lt;- f1 r2 &lt;- f2 r3 &lt;- f3 yield println(s\"in the 'yield': ${delta()}\") (r1 + r2 + r3) // (3) обработка результата result.onComplete { case Success(x) =&gt; println(s\"in the Success case: ${delta()}\") println(s\"result = $x\") case Failure(e) =&gt; e.printStackTrace } println(s\"before the 'sleep(3000)': ${delta()}\") // важно для небольшой параллельной демонстрации: не глушить jvm sleep(3000) После запуска этого приложения, вывод выглядит следующим образом: creating the futures: 1 before the 'sleep(3000)': 2 in the 'yield': 806 in the Success case: 806 result = 6 Как показывает вывод, Future создаются очень быстро, и всего за две миллисекунды достигается оператор печати непосредственно перед операцией sleep(3000) в конце метода. Весь этот код выполняется в основном потоке JVM. Затем, через 806 мс, три Future завершаются, и выполняется код в блоке yield. Затем код немедленно переходит к успешному завершению в методе onComplete. Вывод 806 мс является ключом к тому, чтобы убедиться, что три вычисления выполняются параллельно. Если бы они выполнялись последовательно, общее время составило бы около 1400 мс — сумма времени ожидания трех вычислений. Но поскольку они выполняются параллельно, общее время чуть больше, чем у самого продолжительного вычисления f1, которое составляет 800 мс. Обратите внимание, что если бы вычисления выполнялись в выражении for, они выполнялись бы последовательно, а не параллельно: // последовательное выполнение (не параллельно!) for r1 &lt;- Future { sleep(800); 1 } r2 &lt;- Future { sleep(200); 2 } r3 &lt;- Future { sleep(400); 3 } yield r1 + r2 + r3 Итак, если необходимо, чтобы вычисления выполнялись параллельно, не забудьте запустить их вне выражения for. Метод, возвращающий Future Было показано, как передавать однопоточный алгоритм в конструктор Future. Ту же технику можно использовать для создания метода, который возвращает Future: // моделируем медленно работающий метод def slowlyDouble(x: Int, delay: Long): Future[Int] = Future { sleep(delay) x * 2 } Как и в предыдущих примерах, достаточно просто присвоить результат вызова метода новой переменной. Тогда, если сразу проверить результат, то можно увидеть, что он не завершен, но по истечении времени задержки в Future результат будет выдан: scala&gt; val f = slowlyDouble(2, 5_000L) val f: concurrent.Future[Int] = Future(&lt;not completed&gt;) scala&gt; f val res0: concurrent.Future[Int] = Future(&lt;not completed&gt;) scala&gt; f val res1: concurrent.Future[Int] = Future(Success(4)) Ключевые моменты о Future Подводя итог, несколько ключевых моментов о Future: Future создается для запуска задач вне основного потока Future предназначены для одноразовых, потенциально длительных параллельных задач, которые в конечном итоге возвращают значение; они создают временный карман параллелизма Future начинает работать в момент построения преимущество Future над потоками заключается в том, что они работают с выражениями for и имеют множество методов обратного вызова, упрощающих процесс работы с параллельными потоками при работе с Future не нужно беспокоиться о низкоуровневых деталях управления потоками результат Future обрабатывается с помощью методов обратного вызова, таких как onComplete и andThen, или методов преобразования, таких как filter, map и т.д. значение внутри Future всегда является экземпляром одного из типов Try: Success или Failure при использовании нескольких Future для получения одного результата, они объединяются в выражении for Кроме того, как было видно по операторам import, Scala Future зависит от ExecutionContext. Дополнительные сведения о Future см. в статье Futures and Promises, в которой обсуждаются futures, promises и execution contexts. В ней также обсуждается, как выражение for транслируется в операцию flatMap. References: Scala3 book"
    } ,    
    {
      "title": "Контекстные функции",
      "url": "/scalaworkbook/docs/abstractions/context-functions.html",
      "content": "Контекстные функции Контекстные функции — это функции с параметрами контекста. Их типы являются типами контекстных функций. Вот пример подобного типа: type Executable[T] = ExecutionContext ?=&gt; T Контекстные функции записываются с использованием ?=&gt; знака “стрелка”. Они применяются к синтезированным аргументам точно так же, как применяются методы с контекстными параметрами. Например: given ec: ExecutionContext = ... def f(x: Int): ExecutionContext ?=&gt; Int = ... // можно было бы написать следующим образом с псевдонимом типа выше // def f(x: Int): Executable[Int] = ... f(2)(using ec) // явный аргумент f(2) // выводимый аргумент И наоборот, если ожидаемый тип выражения E является типом контекстной функции (T_1, ..., T_n) ?=&gt; U и E не является литералом контекстной функции, E преобразуется в литерал контекстной функции путем перезаписи его в (x_1: T1, ..., x_n: Tn) ?=&gt; E где имена x_1, ..., x_n произвольны. Это расширение выполняется перед проверкой типа выражения E, что означает, что x_1, ..., x_n доступны как данные в E. Как и их типы, литералы контекстных функций записываются с использованием ?=&gt; стрелки между параметрами и результатами. Они отличаются от обычных литералов функций тем, что их типы являются типами контекстной функций. Например, продолжая предыдущие определения, def g(arg: Executable[Int]) = ... g(22) // расширяется до g((ev: ExecutionContext) ?=&gt; 22) g(f(2)) // расширяется до g((ev: ExecutionContext) ?=&gt; f(2)(using ev)) g((ctx: ExecutionContext) ?=&gt; f(3)) // расширяется до g((ctx: ExecutionContext) ?=&gt; f(3)(using ctx)) g((ctx: ExecutionContext) ?=&gt; f(3)(using ctx)) // осталось как есть Пример: шаблон построителя Типы контекстных функций обладают значительной выразительной силой. Например, вот как они могут поддерживать “шаблон построителя”, целью которого является создание таких таблиц: table { row { cell(\"top left\") cell(\"top right\") } row { cell(\"bottom left\") cell(\"bottom right\") } } Идея состоит в том, чтобы определить классы для Table и Row, которые позволяют добавлять элементы через add: class Table: val rows = new ArrayBuffer[Row] def add(r: Row): Unit = rows += r override def toString = rows.mkString(\"Table(\", \", \", \")\") class Row: val cells = new ArrayBuffer[Cell] def add(c: Cell): Unit = cells += c override def toString = cells.mkString(\"Row(\", \", \", \")\") case class Cell(elem: String) Затем можно определить методы конструктора table, row и cell с типами контекстных функций в качестве параметров. def table(init: Table ?=&gt; Unit) = given t: Table = Table() init t def row(init: Row ?=&gt; Unit)(using t: Table) = given r: Row = Row() init t.add(r) def cell(str: String)(using r: Row) = r.add(new Cell(str)) При такой настройке приведенный выше код построения таблицы компилируется и расширяется до: table { ($t: Table) ?=&gt; row { ($r: Row) ?=&gt; cell(\"top left\")(using $r) cell(\"top right\")(using $r) }(using $t) row { ($r: Row) ?=&gt; cell(\"bottom left\")(using $r) cell(\"bottom right\")(using $r) }(using $t) } Пример пост-условия В качестве более крупного примера, вот способ определения конструкций для проверки произвольных постусловий с использованием метода расширения ensuring, чтобы на проверенный результат можно было ссылаться просто с помощью result. В примере сочетаются непрозрачные псевдонимы типов, типы контекстных функций и методы расширения, чтобы обеспечить абстракцию с нулевыми издержками. object PostConditions: opaque type WrappedResult[T] = T def result[T](using r: WrappedResult[T]): T = r extension [T](x: T) def ensuring(condition: WrappedResult[T] ?=&gt; Boolean): T = assert(condition(using x)) x end PostConditions import PostConditions.{ensuring, result} val s = List(1, 2, 3).sum.ensuring(result == 6) // s: Int = 6 Пояснения: тип контекстной функции WrappedResult[T] ?=&gt; Boolean используется в качестве типа условия ensuring. Таким образом, аргумент для ensuring такой, как (result == 6) будет иметь заданный тип WrappedResult[T] в области видимости для передачи методу result. WrappedResult является новым типом, чтобы убедиться, что мы не получаем нежелательных данных в области видимости (это хорошая практика во всех случаях, когда задействованы параметры контекста). Поскольку WrappedResult - это псевдоним opaque типа, его значения не нужно упаковывать, а поскольку ensuring добавляется как метод расширения, его аргумент также не нуждается в упаковывании. Следовательно, реализация ensuring близка по эффективности к наилучшему коду, который можно было бы написать вручную: val s = val result = List(1, 2, 3).sum assert(result == 6) result References: Scala 3 Reference"
    } ,    
    {
      "title": "Параметры по умолчанию",
      "url": "/scalaworkbook/docs/methods/default-parameters.html",
      "content": "Параметры по умолчанию В параметрах метода можно указывать значения по умолчанию. В этом примере значения по умолчанию заданы как для timeout, так и для protocol: def makeConnection(timeout: Int = 5_000, protocol: String = \"http\") = println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\") Поскольку параметры имеют значения по умолчанию, метод можно вызвать следующими способами: makeConnection() // timeout = 5000, protocol = http makeConnection(2_000) // timeout = 2000, protocol = http makeConnection(3_000, \"https\") // timeout = 3000, protocol = https Ключевые моменты: в первом примере метод вызывается без аргументов, поэтому он использует значения параметров по умолчанию: 5_000 и http во втором примере для значения timeout указано 2_000 - оно используется вместе со значением по умолчанию для protocol в третьем примере указаны значения для обоих параметров, поэтому используются именно они Обратите внимание, что при использовании значений параметров по умолчанию создается впечатление, что используются три разных переопределенных метода. References: Scala3 book, Method Features"
    } ,    
    {
      "title": "Детали",
      "url": "/scalaworkbook/docs/details.html",
      "content": "Детали В этом разделе описаны уточняющие детали некоторых особенностей Scala."
    } ,    
    {
      "title": "Документы",
      "url": "/scalaworkbook/docs/scaladoc/docstrings.html",
      "content": "Документы В этой главе описывается, как правильно писать строки документации и как использовать все доступные функции scaladoc. Scaladoc расширяет возможности Markdown дополнительными функциями, такими как ссылки на определения API. Это можно использовать из статической документации и постов в блогах для создания смешиваемого контента. Куда поместить строки документации Комментарии Scaladoc идут перед элементами, к которым они относятся, в специальном блоке комментариев, который начинается с /** и заканчивается */, например: /** Комментарий начинается здесь. * Левая \"звезда\", за которой следует пробел в каждой строке, * позволяет продолжить комментарий. * * Даже на пустых строках разрыва абзаца. * * Обратите внимание, что '*' в каждой строке выровнена * со вторым '*' в '/**' так, чтобы * левое поле находилось в том же столбце, где * первая строка и последующие. * * Комментарий закрывается с помощью '*' и обратного слэша. * * Если используются теги Scaladoc (@param, @group и т.д.), * не забудьте поместить их в отдельные строки без предшествующих им строк. * * Например: * * Рассчитать квадрат заданного числа * * @param d the Double to square * @return the result of squaring d */ def square(d: Double): Double = d * d В приведенном выше примере комментарий Scaladoc связан с методом square, поскольку он находится в исходном коде прямо перед ним. Комментарии Scoladoc могут идти перед полями, методами, классами, трейтами, объектами. На данный момент scaladoc не поддерживает прямое решение для документирования пакетов. На гитхабе есть специальный issue, где можно проверить текущий статус проблемы. Для первичных конструкторов класса, которые в Scala совпадают с определением самого класса, тег @constructor используется для указания комментария, помещаемого в документацию первичных конструкторов, а не в обзор класса. Теги Scoladoc использует теги @&lt;tagname&gt; для предоставления определенных подробностей полей в комментариях. Теги включают: Теги, специфичные для класса @constructor помещенный в комментарий класса, будет описывать первичный конструктор. Теги, специфичные для метода @return для детализации возвращаемого значения из метода (по одному на метод). Теги метода, конструктора и/или класса @throws какие исключения (если есть) может генерировать метод или конструктор. @param детализация параметра метода или конструктора, предоставляется по одному @param для каждого параметра метода/конструктора. @tparam детализация параметра типа для метода, конструктора или класса. Указывается по одному для каждого параметра типа. Теги использования @see ссылки на другие источники информации, такие как ссылки на внешние документы или связанные объекты в документации. @note добавление примечания о предварительных или последующих условиях или любых других заметных ограничениях или ожиданиях. @example предоставление примера кода или соответствующей документации. Теги группировки Эти теги хорошо подходят для больших типов или пакетов со многими элементами. Они позволяют организовать страницу Scoladoc в отдельные разделы, каждый из которых отображается отдельно в выбранном порядке. Эти теги не включены по умолчанию! Необходимо передать флаг -groups в Scaladoc, чтобы включить их. В sbt это обычно выглядит примерно так: Compile / doc / scalacOptions ++= Seq( \"-groups\" ) Каждый раздел должен иметь идентификатор из одного слова, который используется во всех этих тегах, как показано ниже в group. По умолчанию этот идентификатор отображается как заголовок раздела документации, но можно использовать @groupname, чтобы указать более длинный заголовок. Как правило, необходимо поместить @groupprio (и, возможно, @groupname и @groupdesc) в Scaladoc для самого пакета/trait/класса/объекта, описывая все группы и их порядок. Затем поместить @group в Scoladoc для каждого члена, указав, в какой группе он находится. Члены, у которых нет тега @group, будут перечислены в результирующей документации как “Ungrouped”. @group &lt;group&gt; - пометить сущность как члена &lt;group&gt; группы. @groupname &lt;group&gt; &lt;name&gt; - указание необязательного имени для группы. &lt;name&gt; отображается как заголовок группы перед её описанием. @groupdesc &lt;group&gt; &lt;description&gt; - добавление необязательного описания для отображения под именем группы. Поддерживает многострочный форматированный текст. @groupprio &lt;group&gt; &lt;priority&gt; - управление порядком группы на странице. По умолчанию 0. Несгруппированные элементы имеют неявный приоритет 1000. Используются значения от 0 до 999, чтобы задать положение относительно других групп. Низкие значения появятся перед высокими значениями. Другие теги @author - предоставление информации об авторе для следующего объекта. @version - версия системы или API, частью которой является этот объект. @since - похож на @version, но определяет систему или API, в котором эта сущность была впервые определена. @deprecated - помечает объект как устаревший, предоставляя как замену реализации, которую следует использовать, так и версию/дату, когда этот объект устарел. @syntax &lt;name&gt; - позволяет изменить парсер для docstring. Синтаксис по умолчанию — markdown, однако можно изменить его с помощью этой директивы. В настоящее время доступны синтаксисы markdown или wiki. Пример использования: @syntax wiki. Макросы @define &lt;name&gt; &lt;definition&gt; позволяет использовать $name в других комментариях Scaladoc в том же исходном файле, который будет заменен на &lt;definition&gt;. Если комментарий не предоставляется для объекта на текущем уровне наследования, но предоставляется для переопределенного объекта на более высоком уровне иерархии наследования, будет использоваться комментарий из суперкласса. Аналогично, если @param, @tparam, @return и другие теги сущностей опущены, но доступны из суперкласса, эти комментарии будут использоваться. Явный Для явного наследования комментариев используется тег @inheritdoc. Разметка Scaladoc предоставляет два анализатора синтаксиса: markdown (по умолчанию) или wikidoc. В Scaladoc по-прежнему можно встраивать теги HTML (как и в Javadoc), но в большинстве случаев это не обязательно, поскольку вместо этого может использоваться разметка. Markdown Markdown использует вариант commonmark с двумя пользовательскими расширениями: wikidoc - ссылки для удобства wikidoc - кодовые блоки с синтаксисом фигурных скобок Wikidoc Wikidoc — это синтаксис, используемый для scala2 scaladoc. Он поддерживается из-за многих существующих исходных кодов, однако не рекомендуется его использование в новых проектах. Синтаксис вики можно включить с помощью глобального флага -comment-syntax wiki или с помощью @syntax wiki директивы в строке документации. Некоторые из стандартных доступных разметки: `monospace` ''italic text'' '''bold text''' __underline__ ^superscript^ ,,subscript,, [[entity link]], e.g. [[scala.collection.Seq]] [[https://external.link External Link]], e.g. [[https://scala-lang.org Scala Language Site]] Другие примечания по форматированию Абзацы начинаются с одной (или нескольких) пустых строк. * на полях для комментария допустимо (и должно быть включено), но в противном случае строка должна быть пустой. Заголовки определяются окружающими символами = с большим количеством = для обозначающих подзаголовков. Например =Heading=, ==Sub-Heading== и т.д. Блоки списка представляют собой последовательность элементов списка с одинаковым стилем и уровнем, без прерываний от других стилей блоков. Неупорядоченные списки можно маркировать с помощью -, нумерованные списки можно обозначать с помощью 1., i., I. или a. для различных стилей нумерации. В обоих случаях должно быть дополнительное пространство впереди, а большее пространство создает подуровень. Разметка для блоков списка выглядит так: /** Вот неупорядоченный список: * * - Первый элемент * - Второй элемент * - Подпункт ко второму * - Еще один подпункт * - Третий пункт * * Вот упорядоченный список: * * 1. Первый пронумерованный элемент * 1. Второй номер позиции * i. Подпункт ко второму * i. Еще один подпункт * 1. Третий пункт */ Связывание с API Scaladoc позволяет ссылаться на документацию по API с помощью ссылок в стиле Wiki. Связать с scala.collection.immutable.List так же просто, как [[scala.collection.immutable.List]]. Для получения дополнительной информации о точном синтаксисе см. Ссылки. Пример Пример сгенеренной документации Scaladoc References: Scaladoc Guide"
    } ,    
    {
      "title": "Enums",
      "url": "/scalaworkbook/docs/modeling/enums.html",
      "content": "Enums Перечисление (an enumeration) может быть использовано для определения типа, состоящего из конечного набора именованных значений (в разделе, посвященном моделированию ФП, будут показаны дополнительные возможности enums). Базовые перечисления используются для определения наборов констант, таких как месяцы в году, дни в неделе, направления, такие как север/юг/восток/запад, и многое другое. В качестве примера, рассмотрим перечисления, определяющие наборы атрибутов, связанных с пиццами: enum CrustSize: case Small, Medium, Large enum CrustType: case Thin, Thick, Regular enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions Для использования в коде enum необходимо импортировать: import CrustSize.* val currentCrustSize = Small Значения enum-ов можно сравнивать и использовать в матчинге: if (currentCrustSize == Small) println(\"If you buy a large pizza, you'll get a prize!\") // If you buy a large pizza, you'll get a prize! currentCrustSize match case Small =&gt; println(\"small\") case Medium =&gt; println(\"medium\") case Large =&gt; println(\"large\") // small Параметризованные перечисления Перечисления могут иметь параметры конструктора: enum Color(val rgb: Int): case Red extends Color(0xFF0000) case Green extends Color(0x00FF00) case Blue extends Color(0x0000FF) Методы, определенные для enum Значения enum соответствуют уникальным целым числам. Целое число, связанное со значением перечисления, возвращается методом ordinal: val red = Color.Red // red: Color = Red red.ordinal // res2: Int = 0 Сопутствующий объект перечисления определяет также три служебных метода. Метод valueOf получает значение enum по его имени. Метод values возвращает все значения enum, определенные в перечислении, в виде Array. Метод fromOrdinal получает значение перечисления по его порядковому (Int) значению. Color.valueOf(\"Blue\") Color.values Color.fromOrdinal(0) Перечисления могут содержать параметры и методы: В перечисление можно добавить свои собственные определения. Пример: enum Planet(mass: Double, radius: Double): private final val G = 6.67300E-11 def surfaceGravity = G * mass / (radius * radius) def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity case Mercury extends Planet(3.303e+23, 2.4397e6) case Venus extends Planet(4.869e+24, 6.0518e6) case Earth extends Planet(5.976e+24, 6.37814e6) case Mars extends Planet(6.421e+23, 3.3972e6) case Jupiter extends Planet(1.9e+27, 7.1492e7) case Saturn extends Planet(5.688e+26, 6.0268e7) case Uranus extends Planet(8.686e+25, 2.5559e7) case Neptune extends Planet(1.024e+26, 2.4746e7) end Planet Сопутствующий объект Также возможно определить явный сопутствующий объект для перечисления: object Planet: def main(args: Array[String]) = val earthWeight = args(0).toDouble val mass = earthWeight / Earth.surfaceGravity for p &lt;- values do println(s\"Your weight on $p is ${p.surfaceWeight(mass)}\") end Planet Ограничения для enum case Объявления case-enum аналогичны вторичным конструкторам: их область действия находится за пределами шаблона enum, несмотря на то, что они объявлены внутри него. Это означает, что объявления case enum не могут получить доступ к внутренним членам класса enum. Точно так же объявления case enum не могут напрямую ссылаться на члены сопутствующего объекта перечисления, даже если они импортированы (напрямую или путем переименования). Например: import Planet.* enum Planet(mass: Double, radius: Double): private final val (mercuryMass, mercuryRadius) = (3.303e+23, 2.4397e6) case Mercury extends Planet(mercuryMass, mercuryRadius) // нет доступа case Venus extends Planet(venusMass, venusRadius) // невалидная ссылка case Earth extends Planet(Planet.earthMass, Planet.earthRadius) // ok object Planet: private final val (venusMass, venusRadius) = (4.869e+24, 6.0518e6) private final val (earthMass, earthRadius) = (5.976e+24, 6.37814e6) end Planet Поля, на которые ссылается Mercury, невидимы. А на поля, на которые ссылается Venus, нельзя ссылаться напрямую (используя import Planet.*). Необходимо использовать косвенную ссылку, например, продемонстрированную с помощью Earth. Совместимость с Java enums Если необходимо использовать определенные в Scala перечисления в качестве перечислений Java, можно сделать это, расширив класс java.lang.Enum (который импортируется по умолчанию) следующим образом: enum Color extends Enum[Color] { case Red, Green, Blue } Параметр типа берется из определения Java enum и должен совпадать с типом перечисления. Нет необходимости предоставлять аргументы конструктора (как определено в документах Java API) для java.lang.Enum при его расширении — компилятор генерирует их автоматически. После определения Color его можно использовать так же, как если бы использовался Java enum: Color.Red.compareTo(Color.Green) References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects Scala 3 Reference"
    } ,    
    {
      "title": "Eta расширение",
      "url": "/scalaworkbook/docs/functions/eta.html",
      "content": "Eta расширение Если посмотреть на Scaladoc для метода map в классах коллекций Scala, то можно увидеть, что метод определен для приема функции: def map[B](f: (A) =&gt; B): List[B] ----------- Действительно, в Scaladoc сказано: “f — это функция, применяемая к каждому элементу”. Но, несмотря на это, каким-то образом в map можно передать метод, и он все еще работает: def times10(i: Int) = i * 10 List(1, 2, 3).map(times10) // res0: List[Int] = List(10, 20, 30) Как это работает? Как можно передать метод в map, который ожидает функцию? Технология, стоящая за этим, известна как Eta Expansion. Она преобразует выражение типа метода в эквивалентное выражение типа функции, и делает это легко и незаметно. Различия между методами и функциями Исторически методы были частью определения класса, хотя в Scala 3 методы могут быть вне классов, такие как определения верхнего уровня и методы расширения. В отличие от методов, функции сами по себе являются полноценными объектами, что делает их объектами первого класса. Их синтаксис также отличается. В этом примере показано, как задать метод и функцию, которые выполняют одну и ту же задачу, определяя, является ли заданное целое число четным: def isEvenMethod(i: Int) = i % 2 == 0 // метод val isEvenFunction = (i: Int) =&gt; i % 2 == 0 // функция Функция действительно является объектом, поэтому ее можно использовать так же, как и любую другую переменную, например, помещая в список: val functions = List(isEvenFunction) И наоборот, технически метод не является объектом, поэтому в Scala 2 метод нельзя было поместить в список, по крайней мере, напрямую, как показано в этом примере: // В этом примере показано сообщение об ошибке в Scala 2 val methods = List(isEvenMethod) ^ error: missing argument list for method isEvenMethod Unapplied methods are only converted to functions when a function type is expected. You can make this conversion explicit by writing `isEvenMethod _` or `isEvenMethod(_)` instead of `isEvenMethod`. Как показано в этом сообщении об ошибке, в Scala 2 существует ручной способ преобразования метода в функцию, но важной частью для Scala 3 является то, что технология Eta Expansion улучшена, поэтому теперь, когда попытаться использовать метод в качестве переменной, он просто работает — не нужно самостоятельно выполнять ручное преобразование: val functions = List(isEvenFunction) val methods = List(isEvenMethod) Важно отметить следующее: Eta Expansion — технология Scala, позволяющая использовать методы так же, как и функции Технология была улучшена в Scala 3, чтобы быть почти полностью бесшовной References: Scala3 book"
    } ,    
    {
      "title": "Предложения export",
      "url": "/scalaworkbook/docs/details/export-causes.html",
      "content": "Предложения export Предложение export определяет псевдонимы для выбранных членов объекта. Например: class BitMap class InkJet class Printer: type PrinterType def print(bits: BitMap): Unit = println(\"Printer.print()\") def status: List[String] = ??? class Scanner: def scan(): BitMap = println(\"Scanner.scan()\") BitMap() def status: List[String] = ??? class Copier: private val printUnit = new Printer { type PrinterType = InkJet } private val scanUnit = new Scanner export scanUnit.scan export printUnit.{status as _, *} def status: List[String] = printUnit.status ++ scanUnit.status Два пункта export определяют следующие псевдонимы экспорта в классе Copier: final def scan(): BitMap = scanUnit.scan() final def print(bits: BitMap): Unit = printUnit.print(bits) final type PrinterType = printUnit.PrinterType Доступ к ним возможен как изнутри Copier, так и снаружи: val copier = new Copier // copier: Copier = repl.MdocSession$App$Copier@4c403b64 copier.print(copier.scan()) // Scanner.scan() // Printer.print() Предложение export имеет тот же формат, что и предложение импорта. Его общая форма: export path . { sel_1, ..., sel_n } Оно состоит из выражения квалификатора path, которое должно быть стабильным идентификатором и за которым следует один или несколько селекторов sel_i, определяющих, что получает псевдоним. Селекторы могут быть одной из следующих форм: Простой селектор x создает псевдонимы для всех подходящих членов path с именем x. Селектор переименования x as y создает псевдонимы для всех подходящих членов path, которым присвоено имя x, но псевдониму присваивается имя y вместо x. Пропускающий селектор x as _ предотвращает создание псевдонима x. Given селектор given x содержит необязательную привязку к типу x. Он создает псевдонимы для всех подходящих экземпляров given, которые соответствуют либо x, либо Any если x опущен, за исключением членов, которые названы предыдущим простым селектором, переименованием или пропуском. Селектор с подстановочным знаком * создает псевдонимы для всех подходящих членов path, за исключением экземпляров given, синтетических элементов, созданных компилятором, и тех членов, которые названы предыдущим простым селектором, переименованием или пропуском. Замечания: также включены подходящие прокси-конструкторы, даже если они являются синтетическими членами. элементы, созданные export, также включаются. Они создаются компилятором, но не считаются синтетическими. Элемент имеет право на export, если выполняются все следующие условия: его владелец не является базовым классом класса (объекта или trait-а), содержащего предложение export, элемент не переопределяет конкретное определение, владельцем которого является базовый класс класса, содержащего предложение export. он доступен в разделе export, это не конструктор и не часть (синтетического) класса объекта, это given экземпляр (объявленный с помощью given) тогда и только тогда, когда экспорт осуществляется из given селектора. Возникает ошибка времени компиляции, если простой селектор или селектор переименования не идентифицирует какие-либо подходящие элементы. Члены типа получают псевдонимы в соответствии с определениями типов, а члены-термины - в соответствии с определениями методов. Псевдонимы экспорта копируют параметры типа и значения элементов, на которые они ссылаются. Псевдонимы экспорта всегда final. Псевдонимы given экземпляров снова определяются как given. Псевдонимы расширений снова определяются как расширения. Псевдонимы встроенных методов или значений снова определяются как inline. Других модификаторов, которые можно присвоить псевдониму, нет. Это имеет следующие последствия для переопределения: Псевдонимы экспорта нельзя переопределить, поскольку они являются final. Псевдонимы экспорта не могут переопределять конкретные члены в базовых классах, поскольку они не помечены override. Однако псевдонимы экспорта могут реализовывать отложенные члены базовых классов. Псевдонимы экспорта для определений общедоступных значений, доступ к которым осуществляется без ссылки на private значения в пути к квалификатору, помечаются компилятором как “стабильные”, а их типы результатов являются одноэлементными типами определений с псевдонимами. Это означает, что их можно использовать как часть путей стабильных идентификаторов, хотя технически они являются методами. Например, следующее допустимо: class C { type T } object O { val c: C = ... } export O.c def f: c.T = ... Ограничения: Предложения экспорта могут появляться в классах или на верхнем уровне. Предложение экспорта не может появиться как оператор в блоке. Если предложение экспорта содержит подстановочный знак или селектор given, его квалификатору path запрещается ссылаться на пакет. Это связано с тем, что еще неизвестно, как безопасно отслеживать зависимости по шаблону от пакета для целей инкрементной компиляции. Переименование экспорта скрывает непереименованные экспорты, соответствующие целевому имени. Например, следующее предложение будет недействительным, поскольку B скрыто переименованием A as B. export {A as B, B} // error: B уже скрыто Переименования в предложении экспорта должны иметь попарно разные целевые имена. Например, следующий пункт будет недействительным: export {A as C, B as C} // error: дублированное переименование Простое переименование экспорта, например export status as stat пока не поддерживаются. Оно нарушило бы ограничение, что экспортируемый объект не может быть уже членом объекта, содержащего экспорт. Это ограничение может быть снято в будущем. References: Scala 3 Reference"
    } ,    
    {
      "title": "Методы расширения",
      "url": "/scalaworkbook/docs/methods/extension-methods.html",
      "content": "Методы расширения Основная цель методов расширения (extension methods) - позволить добавлять новые функциональные возможности в закрытые классы. Представим, что у нас есть класс Circle, но мы не можем изменить его исходный код. Например, он может быть определен следующим образом в сторонней библиотеке: case class Circle(x: Double, y: Double, radius: Double) Если необходимо добавить методы в этот класс, можно их определить как методы расширения, например: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 def diameter: Double = c.radius * 2 def area: Double = math.Pi * c.radius * c.radius Ключевое слово extension объявляет о намерении определить один или несколько методов расширения для параметра, заключенного в круглые скобки. Как показано в примере выше, параметры типа Circle затем могут быть использованы в теле методов расширения. Теперь, если есть экземпляр Circle с именем aCircle, можно вызвать эти методы следующим образом: val aCircle = Circle(0.0, 0.0, 1.0) // aCircle: Circle = Circle(x = 0.0, y = 0.0, radius = 1.0) aCircle.circumference // res0: Double = 6.283185307179586 aCircle.diameter // res1: Double = 2.0 aCircle.area // res2: Double = 3.141592653589793 Более подробно методы расширения раскрыты в соответствующей главе раздела “Абстракции”. References: Scala3 book, Method Features"
    } ,    
    {
      "title": "Доп. материалы",
      "url": "/scalaworkbook/extra.html",
      "content": "Дополнительные материалы Scala Scala 3, официальная документация Community Преимущества 3-й версии Scala Особенности Scala3 Сравнение с другими языками программирования Scala для Java-разработчиков Scala для JavaScript-разработчиков Scala для Python-разработчиков Упражнения на Scala 2: exercism.org на Scala 2: Tour of Scala на Scala 2: A Tour of Scala на Scala 2: scala-exercises Книги Список книг Programming in Scala, Fifth Edition by Martin Odersky, Lex Spoon, Bill Venners, and Frank Sommers на Scala 2: Hello Scala by Alexander Alvin на Scala 2: Functional Programming by Alexander Alvin на Scala 2: Scala Cookbook by Alexander Alvin на Scala 2: Scala for the Impatient by Cay Horstmann на Scala 2: Scala &amp; Design Patterns: Exploring Language Expressivity by Frederik Skeel Løkke Статьи … Видео лекции Introduction to Programming and Problem Solving Using Scala Object-Orientation, Abstraction, and Data Structures Using Scala Курсы …"
    } ,    
    {
      "title": "Foldable",
      "url": "/scalaworkbook/typeclass/monad/foldable.html",
      "content": "Foldable Операция fold позволяет агрегировать. Она берет начальный элемент и объединяет его с типом Foldable, следуя способу, предоставленному методом f. Fold может использоваться для реализации reduce. Разница с reduce заключается в том, что начальный элемент является либо идентификатором операции, указанной в f, что означает элемент, который не изменяет значение, например, пустая строка \"\" для операции конкатенации строк или 0 для операции + в типе Int. Можно реализовать версию reduce, в которой начальный элемент — это просто первый элемент, который будет объединен в fold, если есть доступ, например, к функции head. Примеры Foldable Реализации Foldable в различных библиотеках References: Tour of Scala"
    } ,    
    {
      "title": "Моделирование ФП",
      "url": "/scalaworkbook/docs/modeling/fp.html",
      "content": "Моделирование ФП В этой главе представлено введение в моделирование предметной области с использованием функционального программирования (ФП). При моделировании с помощью ФП обычно используются следующие конструкции Scala: Enums Case classes Traits Введение В ФП данные и операции над этими данными — это две разные вещи; их необязательно инкапсулировать вместе, как в ООП. Концепция аналогична числовой алгебре. Когда вы думаете о целых числах, значения которых больше или равны нулю, то у вас есть набор возможных значений, который выглядит следующим образом: 0, 1, 2 ... Int.MaxValue Игнорируя деление целых чисел, возможные операции над этими значениями такие: +, -, * Схема ФП реализуется аналогичным образом: описывается свой набор значений (данные) описываются операции, которые работают с этими значениями (функции) Как будет видно, рассуждения о программах в этом стиле сильно отличаются от объектно-ориентированного программирования. Отделение функциональности от данных позволяет проверять свои данные, не беспокоясь о поведении. В этой главе мы смоделируем данные и операции для “пиццы” в пиццерии. Будет показано, как реализовать часть “данных” модели Scala/ФП, а затем - несколько различных способов организации операций с этими данными. Моделирование данных В Scala достаточно просто описать модель данных: если необходимо смоделировать данные с различными вариантами, то используется конструкция enum если необходимо только сгруппировать сущности (или нужен более детальный контроль), то используются case class-ы Описание вариантов Данные, которые просто состоят из различных вариантов, таких как размер корочки, тип корочки и начинка, кратко моделируются с помощью конструкции enum: enum CrustSize: case Small, Medium, Large enum CrustType: case Thin, Thick, Regular enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions Типы данных, которые описывают различные варианты (например, CrustSize), также иногда называют типами суммы (sum types). Описание основных данных Пиццу можно рассматривать как составной контейнер с различными атрибутами, указанными выше. Мы можем использовать case class, чтобы описать, что пицца состоит из размеров корки, типа корки и, возможно, нескольких начинок: import CrustSize.* import CrustType.* import Topping.* case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) Типы данных, объединяющие несколько компонентов (например, Pizza), также иногда называют типами продуктов (product types). И все. Это модель данных для системы доставки пиццы в стиле ФП. Решение очень лаконично, поскольку оно не требует объединения модели данных с операциями с пиццей. Модель данных легко читается, как объявление дизайна для реляционной базы данных. Также очень легко создавать значения нашей модели данных и проверять их: val myFavPizza = Pizza(Small, Regular, Seq(Cheese, Pepperoni)) // myFavPizza: Pizza = Pizza( // crustSize = Small, // crustType = Regular, // toppings = List(Cheese, Pepperoni) // ) println(myFavPizza.crustType) // Regular Подробнее о модели данных Таким же образом можно было бы смоделировать всю систему заказа пиццы. Вот несколько других case class-ов, которые используются для моделирования такой системы: case class Address( street1: String, street2: Option[String], city: String, state: String, zipCode: String ) case class Customer( name: String, phone: String, address: Address ) case class Order( pizzas: Seq[Pizza], customer: Customer ) “Узкие доменные объекты” В своей книге Functional and Reactive Domain Modeling, Debasish Ghosh утверждает, что там, где специалисты по ООП описывают свои классы как “широкие модели предметной области”, которые инкапсулируют данные и поведение, модели данных ФП можно рассматривать как “узкие объекты предметной области”. Это связано с тем, что, как показано выше, модели данных определяются как case class-ы с атрибутами, но без поведения, что приводит к коротким и лаконичным структурам данных. Моделирование операций Возникает интересный вопрос: поскольку ФП отделяет данные от операций над этими данными, то как эти операции реализуются в Scala? Ответ на самом деле довольно прост: пишутся функции/методы, работающие со значениями смоделированных данных. Например, можно определить функцию, которая вычисляет цену пиццы. def pizzaPrice(p: Pizza): Double = p match case Pizza(crustSize, crustType, toppings) =&gt; val base = 6.00 val crust = crustPrice(crustSize, crustType) val tops = toppings.map(toppingPrice).sum base + crust + tops Можно заметить, что реализация функции просто повторяет форму данных: поскольку Pizza является case class-ом, используется сопоставление с образцом для извлечения компонентов, а затем вызываются вспомогательные функции для вычисления отдельных цен. def toppingPrice(t: Topping): Double = t match case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 Точно так же, поскольку Topping является перечислением, используется сопоставление с образцом, чтобы разделить варианты. Сыр и лук продаются по 50 центов за штуку, остальные — по 75. def crustPrice(s: CrustSize, t: CrustType): Double = (s, t) match case (Small | Medium, _) =&gt; 0.25 // игнорируем значение t case (Large, Thin) =&gt; 0.50 case (Large, Regular) =&gt; 0.75 case (Large, Thick) =&gt; 1.00 Чтобы рассчитать цену корки, мы одновременно сопоставляем образцы как по размеру, так и по типу корки. Важным моментом во всех показанных выше функциях является то, что они являются чистыми функциями (pure functions): они не изменяют данные и не имеют других побочных эффектов (таких, как выдача исключений или запись в файл). Всё, что они делают - это просто получают значения и вычисляют результат. Как организовать функциональность? При реализации функции расчета цены пиццы, описанной выше, не было сказано, где ее определять. В Scala 3 вполне допустимо определить функцию на верхнем уровне файла. Тем не менее язык предоставляет множество отличных инструментов для организации логики в различных пространствах имен и модулях. Существует несколько способов реализации и организации поведения: определить функции в сопутствующих объектах (companion object) использовать модульный стиль программирования использовать подход “функциональных объектов” определить функциональность в методах расширения Эти различные решения показаны в оставшейся части этого раздела. Companion Object Первый подход — определить поведение (функции) в сопутствующем объекте. Как обсуждалось в разделе “Companion objects”, сопутствующий объект — это объект с тем же именем, что и у класса, и объявленный в том же файле, что и класс. При таком подходе в дополнение к enum или case class также определяется companion object с таким же именем, который содержит поведение (функции). case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) // companion object для кейс класса Pizza object Pizza: def price(p: Pizza): Double = ... // тоже самое, что и pizzaPrice enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions // companion object для перечисления Topping object Topping: def price(t: Topping): Double = t match // тоже самое, что и toppingPrice case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 При таком подходе можно создать Pizza и вычислить ее цену следующим образом: val pizza1 = Pizza(Small, Thin, Seq(Cheese, Onions)) Pizza.price(pizza1) Группировка функциональности с помощью сопутствующих объектов имеет несколько преимуществ: связывает функциональность с данными и облегчает их поиск программистам (и компилятору). создает пространство имен и, например, позволяет использовать price в качестве имени метода, не полагаясь на перегрузку. реализация Topping.price может получить доступ к значениям перечисления, таким как Cheese, без необходимости их импорта. Однако также есть несколько компромиссов, которые следует учитывать: модель данных тесно связывается с функциональностью. В частности, сопутствующий объект должен быть определен в том же файле, что и case class. неясно, где определять такие функции, как crustPrice, которые с одинаковым успехом можно поместить в сопутствующий объект CrustSize или CrustType. Модули Второй способ организации поведения — использование “модульного” подхода. В книге “Программирование на Scala” модуль определяется как “небольшая часть программы с четко определенным интерфейсом и скрытой реализацией”. Давайте посмотрим, что это значит. Создание интерфейса PizzaService Первое, о чем следует подумать, — это “поведение” Pizza. Делая это, определяем trait PizzaServiceInterface следующим образом: trait PizzaServiceInterface: def price(p: Pizza): Double def addTopping(p: Pizza, t: Topping): Pizza def removeAllToppings(p: Pizza): Pizza def updateCrustSize(p: Pizza, cs: CrustSize): Pizza def updateCrustType(p: Pizza, ct: CrustType): Pizza Как показано, каждый метод принимает Pizza в качестве входного параметра вместе с другими параметрами, а затем возвращает экземпляр Pizza в качестве результата. Когда пишется такой чистый интерфейс, можно думать о нем как о контракте, в котором говорится: “Все неабстрактные классы, расширяющие этот trait, должны предоставлять реализацию этих сервисов”. На этом этапе также можно представить, что вы являетесь потребителем этого API. Когда вы это сделаете, будет полезно набросать некоторый пример “потребительского” кода, чтобы убедиться, что API выглядит так, как хотелось: val p = Pizza(Small, Thin, Seq(Cheese)) val p1 = addTopping(p, Pepperoni) val p2 = addTopping(p1, Onions) val p3 = updateCrustType(p2, Thick) val p4 = updateCrustSize(p3, Large) Если с этим кодом все в порядке, как правило, можно начать набрасывать другой API, например API для заказов, но, поскольку сейчас рассматривается только Pizza, перейдем к созданию конкретной реализации этого интерфейса. Обратите внимание, что обычно это двухэтапный процесс. На первом шаге набрасывается контракт API в качестве интерфейса. На втором шаге создается конкретная реализация этого интерфейса. В некоторых случаях в конечном итоге создается несколько конкретных реализаций базового интерфейса. Создание конкретной реализации Теперь, когда известно, как выглядит PizzaServiceInterface, можно создать конкретную реализацию, написав тело для всех методов, определенных в интерфейсе: object PizzaService extends PizzaServiceInterface: def price(p: Pizza): Double = p match case Pizza(crustSize, crustType, toppings) =&gt; val base = 6.00 val crust = crustPrice(crustSize, crustType) val tops = toppings.map(toppingPrice).sum base + crust + tops def addTopping(p: Pizza, t: Topping): Pizza = p.copy(toppings = p.toppings :+ t) def removeAllToppings(p: Pizza): Pizza = p.copy(toppings = Seq.empty) def updateCrustSize(p: Pizza, cs: CrustSize): Pizza = p.copy(crustSize = cs) def updateCrustType(p: Pizza, ct: CrustType): Pizza = p.copy(crustType = ct) private def toppingPrice(t: Topping): Double = t match case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 private def crustPrice(s: CrustSize, t: CrustType): Double = (s, t) match case (Small | Medium, _) =&gt; 0.25 case (Large, Thin) =&gt; 0.50 case (Large, Regular) =&gt; 0.75 case (Large, Thick) =&gt; 1.00 end PizzaService Хотя двухэтапный процесс создания интерфейса с последующей реализацией не всегда необходим, явное продумывание API и его использования — хороший подход. Когда все готово, можно использовать Pizza и PizzaService: import PizzaService.* val p = Pizza(Small, Thin, Seq(Cheese)) // p: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese)) val p1 = addTopping(p, Pepperoni) // p1: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese, Pepperoni)) val p2 = addTopping(p1, Onions) // p2: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese, Pepperoni, Onions)) val p3 = updateCrustType(p2, Thick) // p3: Pizza = Pizza(crustSize = Small, crustType = Thick, toppings = List(Cheese, Pepperoni, Onions)) val p4 = updateCrustSize(p3, Large) // p4: Pizza = Pizza(crustSize = Large, crustType = Thick, toppings = List(Cheese, Pepperoni, Onions)) println(price(p4)) // 8.75 Функциональные объекты В книге “Программирование на Scala” авторы определяют термин “Функциональные объекты” как “объекты, которые не имеют никакого изменяемого состояния”. Это также относится к типам в scala.collection.immutable. Например, методы в List не изменяют внутреннего состояния, а вместо этого создают в результате копию List. Об этом подходе можно думать, как о “гибридном дизайне ФП/ООП”, потому что: данные моделируются, используя неизменяемые case class-ы. определяется поведение (методы) того же типа, что и данные. поведение реализуется как чистые функции: они не изменяют никакого внутреннего состояния; скорее - возвращают копию. Это действительно гибридный подход: как и в дизайне ООП, методы инкапсулированы в класс с данными, но, как это обычно бывает в дизайне ФП, методы реализованы как чистые функции, которые данные не изменяют. Пример Используя этот подход, можно напрямую реализовать функциональность пиццы в case class: case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ): // операции этой модели данных def price: Double = ... // такая же имплементация, как и выше в PizzaService.price def addTopping(t: Topping): Pizza = this.copy(toppings = this.toppings :+ t) def removeAllToppings: Pizza = this.copy(toppings = Seq.empty) def updateCrustSize(cs: CrustSize): Pizza = this.copy(crustSize = cs) def updateCrustType(ct: CrustType): Pizza = this.copy(crustType = ct) Обратите внимание, что в отличие от предыдущих подходов, поскольку это методы класса Pizza, они не принимают ссылку Pizza в качестве входного параметра. Вместо этого у них есть собственная ссылка на текущий экземпляр пиццы - this. Теперь можно использовать этот новый дизайн следующим образом: Pizza(Small, Thin, Seq(Cheese)) .addTopping(Pepperoni) .updateCrustType(Thick) .price Методы расширения Методы расширения - подход, который находится где-то между первым (определение функций в сопутствующем объекте) и последним (определение функций как методов самого типа). Методы расширения позволяют создавать API, похожий на API функционального объекта, без необходимости определять функции как методы самого типа. Это может иметь несколько преимуществ: модель данных снова очень лаконична и не упоминает никакого поведения. можно задним числом развить функциональность типов дополнительными методами, не изменяя исходного определения. помимо сопутствующих объектов или прямых методов типов, методы расширения могут быть определены извне в другом файле. Вернемся к примеру: case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) extension (p: Pizza) def price: Double = pizzaPrice(p) // имплементация выше def addTopping(t: Topping): Pizza = p.copy(toppings = p.toppings :+ t) def removeAllToppings: Pizza = p.copy(toppings = Seq.empty) def updateCrustSize(cs: CrustSize): Pizza = p.copy(crustSize = cs) def updateCrustType(ct: CrustType): Pizza = p.copy(crustType = ct) В приведенном выше коде различные методы для пиццы определяются как методы расширения (extension methods). Код extension (p: Pizza) говорит о том, что мы хотим сделать методы доступными для экземпляров Pizza, и в дальнейшем ссылаемся на экземпляр, который расширяем, как p. Таким образом, получается тот же API, что и раньше: Pizza(Small, Thin, Seq(Cheese)) .addTopping(Pepperoni) .updateCrustType(Thick) .price При этом методы расширения можно определить в любом другом модуле. Как правило, если вы являетесь разработчиком модели данных, вы определяете свои методы расширения в сопутствующем объекте. Таким образом, они уже доступны всем пользователям. В противном случае методы расширения должны быть импортированы явно, чтобы их можно было использовать. Резюме функционального подхода Определение модели данных в Scala/ФП, как правило, простое: моделируются варианты данных с помощью enum-ов и составных данных с помощью case class-ов. Затем, чтобы смоделировать поведение, определяются функции, которые работают со значениями модели данных. Были рассмотрены разные способы организации функций: можно поместить методы в сопутствующие объекты можно использовать модульный стиль программирования, разделяющий интерфейс и реализацию можно использовать подход “функциональных объектов” и хранить методы в определенном типе данных можно использовать методы расширения, чтобы снабдить модель данных функциональностью References: Scala3 book, domain modeling fp Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Функц. программирование",
      "url": "/scalaworkbook/docs/fp.html",
      "content": "Функциональное программирование Scala позволяет писать код в стиле объектно-ориентированного программирования (ООП), функционального программирования (ФП), а также в гибридном стиле — используя комбинацию обоих подходов. По словам Мартина Одерского, суть Scala - это слияние функционального и объектно-ориентированного программирования в типизированной среде: функции для логики объекты для модульности В этой главе дается краткое введение в несколько основных концепций функционального программирования: что такое функциональное программирование? неизменяемые значения чистые функции функции - это значения функциональная обработка ошибок Функциональное программирование - это огромная тема, поэтому здесь будут даны только вводные понятия. Более подробная информация будет раскрыта в отдельной документации. References: Scala3 book"
    } ,    
    {
      "title": "Обработка ошибок",
      "url": "/scalaworkbook/docs/fp/functional-error-handling.html",
      "content": "Функциональная обработка ошибок Функциональное программирование похоже на написание ряда алгебраических уравнений, и поскольку алгебра не имеет null значений или исключений, эти функции не используются в ФП. Это поднимает интересный вопрос: что делать в ситуациях, когда в коде ООП обычно используются null значение или исключение? Решение Scala заключается в использовании конструкций, подобных классам Option/Some/None. Примечание: классы Some и None являются подклассами Option вместо того чтобы многократно повторять “Option/Some/None”, следующий текст обычно просто ссылается на “Option” или “классы Option” Первый пример Хотя этот первый пример не имеет дело со значениями null, это хороший способ познакомиться с классами Option. Представим, что нужно написать метод, который упрощает преобразование строк в целочисленные значения. И нужен элегантный способ обработки исключения, которое возникает, когда метод получает строку типа \"Hello\" вместо \"1\". Первое предположение о таком методе может выглядеть следующим образом: def makeInt(s: String): Int = try Integer.parseInt(s.trim) catch case e: Exception =&gt; 0 Если преобразование работает, метод возвращает правильное значение Int, но в случае сбоя метод возвращает 0. Для некоторых целей это может быть хорошо, но не совсем точно. Например, метод мог получить \"0\", но мог также получить \"foo\", \"bar\" или бесконечное количество других строк, которые выдадут исключение. Это реальная проблема: как определить, когда метод действительно получил \"0\", а когда получил что-то еще? При таком подходе нет способа узнать правильный ответ наверняка. Использование Option/Some/None Распространенным решением этой проблемы в Scala является использование классов, известных как Option, Some и None. Классы Some и None являются подклассами Option, поэтому решение работает следующим образом: объявляется, что makeInt возвращает тип Option если makeInt получает строку, которую он может преобразовать в Int, ответ помещается внутрь Some если makeInt получает строку, которую не может преобразовать, то возвращает None Вот доработанная версия makeInt: def makeInt(s: String): Option[Int] = try Some(Integer.parseInt(s.trim)) catch case e: Exception =&gt; None Этот код можно прочитать следующим образом: “Когда данная строка преобразуется в целое число, верните значение Int, заключенное в Some, например Some(1). Когда строка не может быть преобразована в целое число и генерируется исключение, метод возвращает значение None.” Эти примеры показывают, как работает makeInt: val a = makeInt(\"1\") // a: Option[Int] = Some(value = 1) val b = makeInt(\"one\") // b: Option[Int] = None Как показано, строка \"1\" приводится к Some(1), а строка \"one\" - к None. В этом суть альтернативного подхода к обработке ошибок. Данная техника используется для того, чтобы методы могли возвращать значения вместо исключений. В других ситуациях значения Option также используются для замены null значений. Примечание: этот подход используется во всех классах библиотеки Scala, а также в сторонних библиотеках Scala ключевым моментом примера является то, что функциональные методы не генерируют исключения; вместо этого они возвращают такие значения, как Option Потребитель makeInt Теперь представим, что мы являемся потребителем метода makeInt. Известно, что он возвращает подкласс Option[Int], поэтому возникает вопрос: как работать с этими возвращаемыми типами? Есть два распространенных ответа, в зависимости от потребностей: использование match выражений использование for выражений Использование match выражений Одним из возможных решений является использование выражения match: makeInt(x) match case Some(i) =&gt; println(i) case None =&gt; println(\"That didn’t work.\") В этом примере, если x можно преобразовать в Int, вычисляется выражение в правой части первого предложения case; если x не может быть преобразован в Int, оценивается выражение в правой части второго предложения case. Использование for выражений Другим распространенным решением является использование выражения for, то есть комбинации for/yield. Например, представим, что необходимо преобразовать три строки в целочисленные значения, а затем сложить их. Решение задачи с использованием выражения for: val y = for a &lt;- makeInt(stringA) b &lt;- makeInt(stringB) c &lt;- makeInt(stringC) yield a + b + c После выполнения этого выражения y может принять одно из двух значений: если все три строки конвертируются в значения Int, y будет равно Some[Int], т. е. целым числом, обернутым внутри Some если какая-либо из трех строк не может быть преобразована в Int, y равен None Это можно проверить на примере: val stringA = \"1\" val stringB = \"2\" val stringC = \"3\" val y = for a &lt;- makeInt(stringA) b &lt;- makeInt(stringB) c &lt;- makeInt(stringC) yield a + b + c // y: Option[Int] = Some(value = 6) Чтобы увидеть негативный кейс, достаточно изменить любую из строк на что-то, что нельзя преобразовать в целое число. В этом случае y равно None: y: Option[Int] = None Восприятие Option, как контейнера Для лучшего восприятия Option, его можно представить как контейнер: Some представляет собой контейнер с одним элементов None не является контейнером, в нем ничего нет Если предпочтительнее думать об Option как о ящике, то None подобен пустому ящику. Что-то в нём могло быть, но нет. Использование Option для замены null Возвращаясь к значениям null, место, где null значение может незаметно проникнуть в код, — класс, подобный этому: class Address( var street1: String, var street2: String, var city: String, var state: String, var zip: String ) Хотя каждый адрес имеет значение street1, значение street2 не является обязательным. В результате полю street2 можно присвоить значение null: val santa = Address( \"1 Main Street\", null, \"North Pole\", \"Alaska\", \"99705\" ) Исторически сложилось так, что в этой ситуации разработчики использовали пустые строки и значения null, оба из которых “взламывают” решения основной проблемы: street2 - необязательное поле. В Scala и других современных языках правильное решение состоит в том, чтобы заранее объявить, что street2 является необязательным: class Address( var street1: String, var street2: Option[String], var city: String, var state: String, var zip: String ) Теперь можно написать более точный код: val santa = Address( \"1 Main Street\", None, \"North Pole\", \"Alaska\", \"99705\" ) или так: val santa = Address( \"123 Main Street\", Some(\"Apt. 2B\"), \"Talkeetna\", \"Alaska\", \"99676\" ) Option — не единственное решение В этом разделе основное внимание уделялось Option классам, но у Scala есть несколько других альтернатив. Например, три класса, известные как Try/Success/Failure, работают также, но (а) эти классы в основном используются, когда код может генерировать исключения, и (б) желательно использовать класс Failure, потому что он дает доступ к сообщению об исключении. Например, классы Try обычно используются при написании методов, которые взаимодействуют с файлами, базами данных или интернет-службами, поскольку эти функции могут легко создавать исключения. Краткое ревью Краткое ревью: функциональные программисты не используют null значения основной заменой null значениям является использование классов Option функциональные методы не выдают исключений; вместо этого они возвращают такие значения, как Option, Try или Either распространенными способами работы со значениями Option являются выражения match и for Option можно рассматривать как контейнеры с одним элементом (Some) и без элементов (None) Option также можно использовать для дополнительных параметров конструктора или метода References: Scala3 book"
    } ,    
    {
      "title": "Функции - это значения",
      "url": "/scalaworkbook/docs/fp/functions-are-values.html",
      "content": "Функции - это значения Хотя каждый когда-либо созданный язык программирования, вероятно, позволяет писать чистые функции, вторая важная особенность ФП на Scala заключается в том, что функции можно создавать как значения, точно так же, как создаются значения String и Int. Эта особенность содержит много преимуществ, наиболее распространенными из которых являются: можно определять методы, принимающие в качестве параметров функции можно передавать функции в качестве параметров в методы Это было видно во многих местах предыдущих глав, когда демонстрировались такие методы, как map и filter: val nums = (1 to 10).toList // nums: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val doubles = nums.map(_ * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) val lessThanFive = nums.filter(_ &lt; 5) // lessThanFive: List[Int] = List(1, 2, 3, 4) В этих примерах анонимные функции передаются в map и filter. Анонимные функции также известны как лямбды. Помимо передачи анонимных функций в filter и map, в них также можно передать методы: def double(i: Int): Int = i * 2 def underFive(i: Int): Boolean = i &lt; 5 val doubles = nums.filter(underFive).map(double) // doubles: List[Int] = List(2, 4, 6, 8) Эта возможность обращаться с методами и функциями как со значениями — мощное свойство, предоставляемое языками функционального программирования. Технически функция, которая принимает другую функцию в качестве входного параметра, известна как функция высшего порядка. Функции, анонимные функции и методы В примерах выше анонимная функция это: _ * 2 Как было показано в обсуждении функций высшего порядка, _ * 2 - сокращенная версия синтаксиса: (i: Int) =&gt; i * 2 Такие функции называются “анонимными”, потому что им не присваивается определенное имя. Для того чтобы это имя задать, достаточно просто назначить его переменной: val double = (i: Int) =&gt; i * 2 Теперь появилась именованная функция, назначенная переменной double. Можно использовать эту функцию так же, как используется метод: double(2) // res2: Int = 4 В большинстве случаев не имеет значения, является ли double функцией или методом; Scala позволяет обращаться с ними одинаково. За кулисами технология Scala, которая позволяет обращаться с методами так же, как с функциями, известна как Eta Expansion. Эта способность беспрепятственно передавать функции в качестве переменных является отличительной чертой функциональных языков программирования, таких как Scala. И, как было видно на примерах map и filter, возможность передавать функции в другие функции помогает создавать код, который является кратким и при этом читабельным — выразительным. Вот еще несколько примеров: List(\"bob\", \"joe\").map(_.toUpperCase) // res4: List[String] = List(\"BOB\", \"JOE\") List(\"bob\", \"joe\").map(_.capitalize) // res5: List[String] = List(\"Bob\", \"Joe\") List(\"plum\", \"banana\").map(_.length) // res6: List[Int] = List(4, 6) val fruits = List(\"apple\", \"pear\") // fruits: List[String] = List(\"apple\", \"pear\") fruits.map(_.toUpperCase) // res7: List[String] = List(\"APPLE\", \"PEAR\") fruits.flatMap(_.toUpperCase) // res8: List[Char] = List('A', 'P', 'P', 'L', 'E', 'P', 'E', 'A', 'R') val nums = List(5, 1, 3, 11, 7) // nums: List[Int] = List(5, 1, 3, 11, 7) nums.map(_ * 2) // res9: List[Int] = List(10, 2, 6, 22, 14) nums.filter(_ &gt; 3) // res10: List[Int] = List(5, 11, 7) nums.takeWhile(_ &lt; 6) // res11: List[Int] = List(5, 1, 3) nums.sortWith(_ &lt; _) // res12: List[Int] = List(1, 3, 5, 7, 11) nums.sortWith(_ &gt; _) // res13: List[Int] = List(11, 7, 5, 3, 1) nums.takeWhile(_ &lt; 6).sortWith(_ &lt; _) // res14: List[Int] = List(1, 3, 5) References: Scala3 book"
    } ,    
    {
      "title": "Функции",
      "url": "/scalaworkbook/docs/functions.html",
      "content": "Функции В этой главе представлены функции Scala. Рассматриваемые темы включают в себя анонимные функции (лямбды), переменные в функциях и функции высшего порядка (HOF - higher-order functions), в том числе способы создания собственных HOF. Функция высшего порядка (HOF) часто определяется как функция, которая принимает другие функции в качестве входных параметров или возвращает функцию в качестве ее значения. В Scala это возможно, потому что функции являются объектами первого класса. Ключевые моменты, которые здесь рассматриваются: как писать анонимные функции в виде небольших фрагментов кода как передать их в десятки HOF (методов) в классах коллекций, то есть в такие методы, как filter, map и т.д. как с помощью этих небольших фрагментов кода и HOF создать множество функциональных возможностей с помощью всего лишь небольшого кода что функциональные переменные - это просто анонимные функции, которые привязаны к переменной как написать методы, которые принимают функции в качестве входных параметров как вернуть функцию из метода как объявлять сигнатуры типов для функций использование одинакового синтаксиса для определения параметров функций, анонимных функций и функциональных переменных References: Scala3 book"
    } ,    
    {
      "title": "Functor",
      "url": "/scalaworkbook/typeclass/monad/functor.html",
      "content": "Functor Функтор — это преобразование из категории A в категорию B. Такие преобразования часто изображаются стрелкой: A -&gt; B (или через метод map). Функтор (F) в теории категорий должен следовать нескольким правилам: Все элементы A должны иметь результат в B Identity (тождественность): Если определен метод идентификации id такой, что: id(a) == a, тогда id(F) == F.map(id). Composition (композиция): Если определены два метода f и g, тогда F.map(f).map(g) == F.map(g(f(_))). Примеры функторов Реализации функторов в различных библиотеках References: Tour of Scala Algebird"
    } ,    
    {
      "title": "Generic параметры",
      "url": "/scalaworkbook/docs/methods/generic-parameter.html",
      "content": "Generic параметры Так же как и у обобщенных классов, у методов есть полиморфизм по типу, с таким же синтаксисом (параметр типа указывается в квадратных скобках сразу после названия метода). Пример: def listOfDuplicates[A](x: A, length: Int): List[A] = if length &lt; 1 then Nil else x :: listOfDuplicates(x, length - 1) listOfDuplicates[Int](3, 4) // res0: List[Int] = List(3, 3, 3, 3) listOfDuplicates(\"La\", 8) // res1: List[String] = List(\"La\", \"La\", \"La\", \"La\", \"La\", \"La\", \"La\", \"La\") Метод listOfDuplicates принимает параметр типа A и параметры значений x и length. Значение x имеет тип A. Если length &lt; 1 возвращается пустой список. В противном случае x добавляется к списку, возвращаемому через рекурсивный вызовов с length - 1. (Обратите внимание, что :: означает добавление элемента слева к списку справа). В первом вызове метода явно указывается параметр типа - [Int]. Поэтому первым аргументом должен быть Int и тип возвращаемого значения будет List[Int]. Во втором вызове показано, что не обязательно всегда явно указывать параметр типа. Часто компилятор сам может вывести тип исходя из контекста или типа передаваемых аргументов. В этом варианте \"La\" - это String, поэтому компилятор знает, что A должен быть String. References: Scala3 book, Method Features"
    } ,    
    {
      "title": "С чего начать?",
      "url": "/scalaworkbook/docs/start/getting-started.html",
      "content": "С чего начать? Scala без предварительной установки Чтобы сразу начать экспериментировать со Scala, используйте “Scastie” в своем браузере. Scastie — это онлайн-площадка, где можно поэкспериментировать с примерами Scala, чтобы увидеть, как все работает, с доступом ко всем компиляторам Scala и опубликованным библиотекам. Scastie поддерживает как Scala 3, так и Scala 2, но по умолчанию используется Scala 3. Установка Scala на компьютер Установка Scala означает установку различных инструментов командной строки, таких как компилятор Scala и инструменты сборки. Рекомендуется использовать инструмент установки “Coursier”, который автоматически устанавливает все зависимости, но также возможно каждый инструмент установить по отдельности вручную. Использование Scala Installer (рекомендованный путь) Установщик Scala — это инструмент Coursier, основная команда которого называется cs. Он гарантирует, что в системе установлены JVM и стандартные инструменты Scala. Установите его в своей системе, следуя следующим инструкциям. Наряду с JVM программа установки cs также устанавливает полезные инструменты командной строки: JDK (если его еще нет) Инструмент сборки sbt Ammonite, улучшенный REPL scalafmt, средство форматирования кода Scala scalac (компилятор Scala) scala (Scala REPL и средство запуска сценариев) Дополнительная информация о cs доступна по ссылке. …или вручную Для компиляции, запуска, тестирования и упаковки проекта Scala нужны только два инструмента: Java 8 или 11 и sbt. Чтобы установить их вручную: если не установлена Java 8 или 11, загрузите Java из Oracle Java 8, Oracle Java 11 или AdoptOpenJDK 8/11. Подробную информацию о совместимости Scala/Java см. в разделе Совместимость с JDK. установить sbt Создание проекта “Hello World” с помощью sbt Для создания проекта можно использовать командную строку или IDE. Использование командной строки sbt — это инструмент сборки для Scala. sbt компилирует, запускает и тестирует Scala код (Он также может публиковать библиотеки и выполнять множество других задач). Чтобы создать новый проект Scala с помощью sbt: cd в пустую папку. Запустите команду sbt new scala/scala3.g8, чтобы создать проект Scala 3. Она извлекает шаблон проекта из GitHub, а также создаёт папку target. При появлении запроса назовите приложение hello-world. Это создаст проект под этим названием. Будет сгенерировано следующее: - hello-world - project (sbt использует эту папку для собственных файлов) - build.properties - build.sbt (sbt's build definition file) - src - main - scala (здесь весь Scala code) - Main.scala (Точка входа в программу) &lt;-- это все, что сейчас нужно Дополнительную документацию по sbt можно найти в соответствующей главе и в официальной документации sbt. Открытие проекта в IDE Для открытия проекта желательно использовать IDE. Самые популярные из них — IntelliJ и VSCode. Оба предлагают богатые возможности, но также можно использовать множество других редакторов. Использование IntelliJ Загрузите и установите IntelliJ Community Edition. Установите plugin Scala, следуя инструкциям по установке. Откройте файл build.sbt, затем выберите Open as a project. Использование VSCode с metals Скачайте VSCode. Установите расширение Metals из Marketplace. Затем откройте каталог, содержащий файл build.sbt (это должен быть каталог hello-world). Когда будет предложено, выберите Import build. Metals — это “языковой сервер Scala”, обеспечивающий поддержку написания кода Scala в VS Code и других редакторах, таких как Atom, Sublime Text и других, с использованием протокола Language Server. Под капотом Metals взаимодействует со средством сборки с помощью Build Server Protocol (BSP). Подробнее о том, как работает Metals, см. “Написание Scala в VS Code, Vim, Emacs, Atom и Sublime Text с помощью Metals”. Исходный код Просмотрите эти два файла в своей IDE: build.sbt src/main/scala/Main.scala При запуске проекта на следующем шаге, конфигурация в build.sbt будет использована для запуска кода в src/main/scala/Main.scala. Запуск Hello World Код в Main.scala можно запускать из IDE, если удобно. Но также можно запустить приложение из терминала, выполнив следующие действия: cd в hello-world. Запустить sbt. Эта команда открывает sbt-консоль. В консоле введите ~run. ~ является необязательным, но заставляет sbt повторно запускаться при каждом сохранении файла, обеспечивая быстрый цикл редактирования/запуска/отладки. sbt также создаст директорию target, которую пока можно игнорировать. После окончания экспериментирования с проектом, нажмите [Enter], чтобы прервать команду run. Затем введите exit или нажмите [Ctrl+D], чтобы выйти из sbt и вернуться в командную строку. References: Scala, Getting started"
    } ,    
    {
      "title": "Hello, world!",
      "url": "/scalaworkbook/docs/hello_world.html",
      "content": "Hello, world! Пример Scala “Hello, world!” выглядит следующим образом. Сначала поместите этот код в файл с именем Hello.scala: @main def hello = println(\"Hello, world!\") В этом коде hello - это метод. Он определен с помощью def и объявлен как метод “main” с аннотацией @main. Он выводит строку “Hello, world!” в стандартный вывод (STDOUT) с использованием метода println. Затем скомпилируйте код с помощью scalac: &gt; scalac Hello.scala References: Scala3 book"
    } ,    
    {
      "title": "Функции высшего порядка",
      "url": "/scalaworkbook/docs/functions/hofs.html",
      "content": "Функции высшего порядка Функция высшего порядка (HOF - higher-order function) часто определяется как функция, которая принимает другие функции в качестве входных параметров или возвращает функцию в качестве результата. В Scala HOF возможны, потому что функции являются объектами первого класса. В качестве важного примечания: хотя в этом документе используется общепринятый термин “функция высшего порядка”, в Scala эта фраза применима как к методам, так и к функциям. Благодаря технологии Eta Expansion их, как правило, можно использовать в одних и тех же местах. От потребителя к разработчику В примерах, приведенных ранее в документации, было видно, как пользоваться методами, которые принимают другие функции в качестве входных параметров, например, map и filter. В следующих разделах будет показано, как создавать HOF, в том числе: как писать методы, принимающие функции в качестве входных параметров как возвращать функции из методов В процессе будет видно: синтаксис, который используется для определения входных параметров функции как вызвать функцию, если есть на нее ссылка В качестве полезного побочного эффекта, как только синтаксис станет привычным, его можно начать использовать для определения параметров функций, анонимных функций и функциональных переменных, а также станет легче читать Scaladoc для функций высшего порядка. Понимание Scaladoc метода filter Чтобы понять, как работают функции высшего порядка, рассмотрим пример: определим, какой тип функций принимает filter, взглянув на его Scaladoc. Вот определение filter в классе List[A]: def filter(p: (A) =&gt; Boolean): List[A] Это определение указывает на то, что filter - метод, который принимает параметр функции с именем p. По соглашению, p обозначает предикат, который представляет собой просто функцию, возвращающую Boolean. Таким образом, filter принимает предикат p в качестве входного параметра и возвращает List[A], где A - тип, содержащийся в списке; если filter вызывается для List[Int], то A - это тип Int. На данный момент, если не учитывать назначение метода filter, все, что известно, так это то, что алгоритм каким-то образом использует предикат p для создания и возврата List[A]. Если посмотреть конкретно на параметр функции p: p: (A) =&gt; Boolean, то эта часть описания filter означает, что любая передаваемая функция должна принимать тип A в качестве входного параметра и возвращать Boolean. Итак, если список представляет собой список List[Int], то можно заменить универсальный тип A на Int и прочитать эту подпись следующим образом: p: (Int) =&gt; Boolean. Поскольку isEven имеет такой же тип — преобразует входное значение Int в результирующее Boolean — его можно использовать с filter. Написание методов, которые принимают параметры функции Рассмотрим пример написания методов, которые принимают функции в качестве входных параметров. Для определенности, будем называть код, который пишется, методом, а код, принимаемый в качестве входного параметра, — функцией. Пример Чтобы создать метод, который принимает функцию в качестве параметра, необходимо: в списке параметров метода определить сигнатуру принимаемой функции использовать эту функцию внутри метода Чтобы продемонстрировать это, вот метод, который принимает входной параметр с именем f, где f — функция: def sayHello(f: () =&gt; Unit): Unit = f() Эта часть кода — сигнатура типа (type signature) — утверждает, что f является функцией, и определяет типы функций, которые будет принимать метод sayHello: f: () =&gt; Unit. Как это работает: f — имя входного параметра функции. Аналогично тому, как параметр String обычно называется s или параметр Int - i сигнатура типа f определяет тип функций, которые будет принимать метод часть () подписи f (слева от символа =&gt;) указывает на то, что f не принимает входных параметров часть сигнатуры Unit (справа от символа =&gt;) указывает на то, что функция f не должна возвращать осмысленный результат в теле метода sayHello (справа от символа =) оператор f() вызывает переданную функцию Теперь, когда sayHello определен, создадим функцию, соответствующую сигнатуре f, чтобы ее можно было проверить. Следующая функция не принимает входных параметров и ничего не возвращает, поэтому она соответствует сигнатуре типа f: def helloJoe(): Unit = println(\"Hello, Joe\") Поскольку сигнатуры типов совпадают, можно передать helloJoe в sayHello: sayHello(helloJoe) // Hello, Joe Был определен метод с именем sayHello, который принимает функцию в качестве входного параметра, а затем вызывает эту функцию в теле своего метода. sayHello может принимать разные функции Важно знать, что преимущество этого подхода заключается не в том, что sayHello может принимать одну функцию в качестве входного параметра; преимущество в том, что sayHello может принимать любую функцию, соответствующую сигнатуре f. Например, поскольку следующая функция не принимает входных параметров и ничего не возвращает, она также работает с sayHello: def bonjourJulien(): Unit = println(\"Bonjour, Julien\") sayHello(bonjourJulien) // Bonjour, Julien Рассмотрим ещё несколько примеров того, как определять сигнатуры различных типов для параметров функции. Общий синтаксис для определения входных параметров функции В методе: def sayHello(f: () =&gt; Unit): Unit сигнатурой типа для f является () =&gt; Unit. Это сигнатура означает “функцию, которая не принимает входных параметров и не возвращает ничего значимого (Unit)”. Вот сигнатура функции, которая принимает параметр String и возвращает Int: f: (String) =&gt; Int Какие функции принимают строку и возвращают целое число? Например, такие, как “длина строки” и контрольная сумма. Эта функция принимает два параметра Int и возвращает Int: f: (Int, Int) =&gt; Int Какие функции соответствуют данной сигнатуре? Любая функция, которая принимает два входных параметра Int и возвращает Int, соответствует этой сигнатуре, поэтому все “функции” ниже (точнее, методы) подходят: def add(a: Int, b: Int): Int = a + b def subtract(a: Int, b: Int): Int = a - b def multiply(a: Int, b: Int): Int = a * b Из примеров выше можно сделать вывод, что общий синтаксис сигнатуры функций такой: variableName: (parameterTypes ...) =&gt; returnType Поскольку функциональное программирование похоже на создание и объединение ряда алгебраических уравнений, обычно много думают о типах при разработке функций и приложений. Можно сказать, что «думают типами». Параметр функции вместе с другими параметрами Чтобы HOFs стали действительно полезными, им также нужны некоторые данные для работы. Для класса, подобного List, в его методе map уже есть данные для работы: элементы в List. Но для автономного приложения, у которого нет собственных данных, метод также должен принимать в качестве других входных параметров данные. Рассмотрим пример метода с именем executeNTimes, который имеет два входных параметра: функцию и Int: def executeNTimes(f: () =&gt; Unit, n: Int): Unit = for i &lt;- 1 to n do f() Как видно из кода, executeNTimes выполняет функцию f n раз. Поскольку простой цикл for, подобный этому, не имеет возвращаемого значения, executeNTimes возвращает Unit. Чтобы протестировать executeNTimes, определим метод, соответствующий сигнатуре f: def helloWorld(): Unit = println(\"Hello, world\") Затем передадим этот метод в executeNTimes вместе с Int: executeNTimes(helloWorld, 3) // Hello, world // Hello, world // Hello, world Метод executeNTimes трижды выполняет функцию helloWorld. Столько параметров, сколько необходимо Методы могут усложняться по мере необходимости. Например, этот метод принимает функцию типа (Int, Int) =&gt; Int вместе с двумя входными параметрами: def executeAndPrint(f: (Int, Int) =&gt; Int, i: Int, j: Int): Unit = println(f(i, j)) Поскольку методы sum и multiply соответствуют сигнатуре f, их можно передать в executeAndPrint вместе с двумя значениями Int: def sum(x: Int, y: Int) = x + y def multiply(x: Int, y: Int) = x * y executeAndPrint(sum, 3, 11) // 14 executeAndPrint(multiply, 3, 9) // 27 Согласованность подписи типа функции Самое замечательное в изучении сигнатур типов функций Scala заключается в том, что синтаксис, используемый для определения входных параметров функции, — это тот же синтаксис, что используется для написания литералов функций. Например, если необходимо написать функцию, вычисляющую сумму двух целых чисел, её можно было бы написать так: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b Этот код состоит из сигнатуры типа: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----------------- входных параметров: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ------ и тела функции: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----- Согласованность Scala состоит в том, что тип функции: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----------------- совпадает с сигнатурой типа, используемого для определения входного параметра функции: def executeAndPrint(f: (Int, Int) =&gt; Int, ... ----------------- По мере освоения этого синтаксиса, становится привычным его использование для определения параметров функций, анонимных функций и функциональных переменных, а также становится легче читать Scaladoc для функций высшего порядка. References: Scala3 book"
    } ,    
    {
      "title": "Неизменяемые значения",
      "url": "/scalaworkbook/docs/fp/immutable-values.html",
      "content": "Неизменяемые значения В чистом функциональном программировании используются только неизменяемые значения. В Scala это означает: все переменные создаются как поля val используются только неизменяемые классы коллекций, такие как List, Vector и неизменяемые классы Map и Set Использование только неизменяемых переменных поднимает интересный вопрос: если все статично, как вообще что-то меняется? Когда дело доходит до использования коллекций, один из ответов заключается в том, что существующая коллекция не меняется; вместо этого функция применяется к коллекции, чтобы создать новую. Именно здесь вступают в действие функции высшего порядка, такие как map и filter. Например, представим, что есть список имен в нижнем регистре — List[String], и необходимо найти все имена, начинающиеся с буквы \"j\", чтобы затем сделать первые буквы заглавными. В ФП код будет выглядеть так: val a = List(\"jane\", \"jon\", \"mary\", \"joe\") // a: List[String] = List(\"jane\", \"jon\", \"mary\", \"joe\") val b = a.filter(_.startsWith(\"j\")) .map(_.capitalize) // b: List[String] = List(\"Jane\", \"Jon\", \"Joe\") Как показано, исходный список a не меняется. Вместо этого к a применяется функция фильтрации и преобразования, чтобы создать новую коллекцию, и результат присваивается неизменяемой переменной b. Точно так же в ФП не используются классы с изменяемыми параметрами конструктора var. В ФП создание такого класса не привествуется: class Person(var firstName: String, var lastName: String) Вместо этого обычно создаются case class-ы, чьи параметры конструктора по умолчанию неизменяемые (val): case class Person(firstName: String, lastName: String) Теперь можно создать экземпляр Person как поле val: val reginald = Person(\"Reginald\", \"Dwight\") // reginald: Person = Person(firstName = \"Reginald\", lastName = \"Dwight\") Затем, при необходимости внести изменения в данные, используется метод copy, который поставляется с case class-ом, чтобы “обновлять данные через создание копии”, например: val elton = reginald.copy( firstName = \"Elton\", lastName = \"John\" ) // elton: Person = Person(firstName = \"Elton\", lastName = \"John\") Существуют множество других приёмов работы с неизменяемыми коллекциями и переменными. В зависимости от задач вместо case class-ов можно создавать enum-ы, trait-ы или классы. Для более подробной информации См. главу “Моделирование данных”. References: Scala3 book"
    } ,    
    {
      "title": "Design Patterns",
      "url": "/scalaworkbook/design-patterns/",
      "content": "Design Patterns Шаблон проектирования обычно рассматривается как многоразовое решение часто встречающейся проблемы проектирования в объектно-ориентированном программном обеспечении. Проектное пространство Пространство шаблонов проектирования, представленное в таблице ниже, имеет два измерения: цель (purpose) и область применения (scope). Шаблоны целей могут быть классифицированы как creational, structural или behavioral. Порождающие шаблоны (creational) имеют дело с созданием объектов, в то время как структурные шаблоны (structural) имеют дело с составом классов или объектов. Поведенческие паттерны (behavioral) описывают взаимодействие объектов и часто распределение ответственности между объектами. Измерение области видимости определяет, “применяется ли шаблон в первую очередь к классам или к объектам”. Шаблоны классов имеют дело с отношениями между классами и их подклассами. Поскольку эти отношения определяются во время компиляции посредством наследования, они фиксированы и не могут изменяться во время выполнения. В шаблонах классов шаблон в целом содержится в одной иерархии классов. Объектные шаблоны, с другой стороны, имеют дело с отношениями между объектами, такими как композиция и делегирование. Это означает, что связь может изменяться во время выполнения. В шаблонах объектов комбинированное поведение шаблона распределяется между несколькими объектами во время выполнения. Scope \\ Purpose Creational Structural Behavioral Class Factory Method Adapter(class) Interpreter Template Method Object Abstract Factory Builder Prototype Singleton Adapter(object) Bridge Composite Decorator Facade Flyweight Proxy Chain of Responsibility Command Iterator Mediator Memento Observer State Strategy Visitor References: Scala &amp; Design Patterns by Frederik Skeel Løkke Design Patterns by Gamma, Helm, Johnson, and Vlissides"
    } ,    
    {
      "title": "Functional programming",
      "url": "/scalaworkbook/fp/",
      "content": "Functional programming Функциональное программирование - FP - это способ написания программных приложений, использующих только чистые функции и неизменяемые значения. Чистая функция означает, что (а) вывод функции зависит только от ее входных параметров и (б) функции не имеют побочных эффектов, таких как чтение пользовательского ввода или запись выходных данных и т.д. Рассмотрим основное отличие императивного программирования - IP от FP на примере вычислении суммы коллекции чисел. В IP подходе сумма чисел вычислялась бы так: def sum(ints: List[Int]): Int = var sum = 0 for i &lt;- ints do sum += i sum sum(List(1, 2, 3)) // res0: Int = 6 Этот код изменяет поле var в цикле for - использует изменяемое состояние. Подход FP может выглядеть так: def sum(xs: List[Int]): Int = xs match case Nil =&gt; 0 case x :: tail =&gt; x + sum(tail) sum(List(1, 2, 3)) // res2: Int = 6 В FP подходе не используется изменяемое состояние. В FP на Scala следует придерживаться следующих правил: не использовать null использовать только чистые функции использовать только val переменные не использовать class-ы, инкапсулирующие данные и поведение использовать if только в качестве выражений, а не операторов Несколько определений: Функция высшего порядка (Higher-Order Function - HOF) часто определяется как функция, которая принимает другие функции в качестве входных параметров или возвращает функцию в качестве результата. λ (“лямбда”) означает “анонимная функция”. Лямбда-исчисление (также записываемое как λ-исчисление) - это формальная система в математической логике для выражения вычислений, основанных на абстракции функций и применении с использованием привязки переменных и подстановки. References: Functional Programming by Alexander Alvin"
    } ,    
    {
      "title": "Type class",
      "url": "/scalaworkbook/typeclass/",
      "content": "Type class Класс типов (type class) — это абстрактный параметризованный тип, который позволяет добавлять новое поведение к любому закрытому типу данных без использования подтипов. Подробнее о классах типов описано в основной документации. References: Type classes in Scalaz Type classes in Cats Type classes in Algebird"
    } ,    
    {
      "title": "Обзор Scala",
      "url": "/scalaworkbook/docs/",
      "content": "Обзор Scala Цель этой документации - дать неофициальное описание языка Scala на русском языке. В ней относительно легко затрагиваются все темы Scala. Для получения дополнительной информации об описываемой теме внизу страницы даны ссылки на справочную документацию, в которой более подробно рассматриваются многие функции языка Scala. Scala - это красивый, выразительный язык программирования с чистым, современным синтаксисом, который обеспечивает безопасную систему статических типов. Он поддерживает как функциональное программирование, так и объектно-ориентированное программирование. Но основной акцент будет сделан именно на функциональном программировании. Особенности Scala 3 References: Scala home page Scala3 book"
    } ,    
    {
      "title": "Основная",
      "url": "/scalaworkbook/",
      "content": "Описание В справочнике изложены основные принципы разработки на Scala, в том числе с помощью популярных фреймворков. Код написан на версии Scala - 3.1.3. Обзор Scala Функциональная разработка на Scala Теория категорий в Scala Паттерны проектирования на Scala"
    } ,    
    {
      "title": "Inline",
      "url": "/scalaworkbook/docs/metaprogramming/inline.html",
      "content": "Inline Встраивание (inline) — это распространенный метод метапрограммирования во время компиляции, обычно используемый для оптимизации производительности. Концепция встраивания предоставляет собой точку входа в программирование с помощью макросов. Вводится inline как мягкий модификатор. Гарантируется, что встраивание происходит на самом деле, а не с “максимальной эффективностью”. Вводятся операции, которые гарантированно оцениваются во время компиляции. Inline Constants Простейшей формой встраивания является встраивание констант в программы: inline val pi = 3.141592653589793 inline val pie = \"🥧\" Использование ключевого слова inline в определениях значений гарантирует, что все ссылки на pi и pie являются встроенными: val pi2 = pi + pi // pi2: Double = 6.283185307179586 val pie2 = pie + pie // pie2: String = \"🥧🥧\" В приведенном выше коде ссылки pi и pie встроены. Затем компилятор применяет оптимизацию под названием “свертывание констант”, которая вычисляет результирующее значение pi2 и pie2 во время компиляции. Inline (Scala 3) vs. final (Scala 2) В Scala 2 использовался бы модификатор final в определении без возвращаемого типа: final val pi = 3.141592653589793 final val pie = \"🥧\" Модификатор final обеспечит, что pi и pie примет литеральный тип. Затем оптимизация распространения констант в компиляторе может выполнить встраивание для таких определений. Однако эта форма постоянного распространения не гарантируется. Scala 3.0 также поддерживает final val - inlining как встраивание с максимальной эффективностью для целей миграции. В настоящее время только константные выражения могут появляться в правой части определения встроенного значения. Таким образом, следующий код недействителен, хотя компилятор знает, что правая часть является постоянным значением времени компиляции: val pi = 3.141592653589793 inline val pi2 = pi + pi // error Обратите внимание, что при определении inline val pi добавление может быть вычислено во время компиляции. Это устраняет указанную выше ошибку и pi2 получает литеральный тип 6.283185307179586d. Inline Methods Также можно использовать модификатор inline для определения метода, который должен быть встроен в точку вызова: inline def logged[T](level: Int, message: =&gt; String)(inline op: T): T = println(s\"[$level]Computing $message\") val res = op println(s\"[$level]Result of $message: $res\") res Когда вызывается такой встроенный метод logged, его тело будет развернуто на месте вызова во время компиляции! То есть вызов logged будет заменен телом метода. Предоставленные аргументы статически заменяются параметрами logged, соответственно. Поэтому компилятор встраивает следующий вызов logged(logLevel, getMessage()) { computeSomething() } и переписывает его на: val level = logLevel def message = getMessage() println(s\"[$level]Computing $message\") val res = computeSomething() println(s\"[$level]Result of $message: $res\") res Встроенные методы всегда должны применяться полностью. Например, вызов logged[String](1, \"some message\") будет неправильно сформирован, и компилятор будет жаловаться на отсутствие аргументов. Однако можно передавать аргументы с подстановочными знаками. Например, logged[String](1, \"some message\")(_) Семантика встроенных методов Пример метода logged использует три разных типа параметров, иллюстрируя, как встраивание обрабатывает эти параметры: Параметры по значению. Компилятор создает val привязку для параметров по значению. Таким образом, выражение аргумента оценивается только один раз перед сокращением тела метода. Это видно по параметру level из примера. В некоторых случаях, когда аргументы являются чистыми постоянными значениями, привязка опускается и значение встраивается напрямую. Параметры по имени. Компилятор создает def привязку для параметров по имени. Таким образом, выражение аргумента оценивается каждый раз, когда оно используется, но код является общим. Это видно по методу message из примера. Встроенные параметры. Встроенные параметры не создают привязок и просто встраиваются. Таким образом, их код дублируется везде, где они используются. Это видно по параметру op из примера. Способ преобразования различных параметров гарантирует, что встраивание вызова не изменит его семантику. Это означает, что первоначальная обработка (разрешение перегрузки, неявный поиск и т. д.), выполняемая при вводе тела встроенного метода, не изменится при встроенном методе. Например, рассмотрим следующий код: class Logger: def log(x: Any): Unit = println(x) class RefinedLogger extends Logger: override def log(x: Any): Unit = println(\"Any: \" + x) def log(x: String): Unit = println(\"String: \" + x) inline def logged[T](logger: Logger, x: T): Unit = logger.log(x) Отдельная проверка типа logger.log(x) разрешает вызов метода Logger.log, который принимает аргумент типа Any. Теперь, учитывая следующий код: logged(new RefinedLogger, \"✔\") // Any: ✔ Он расширяется до: val logger = new RefinedLogger // logger: RefinedLogger = repl.MdocSession$App$RefinedLogger@65a1307b val x = \"✔\" // x: String = \"✔\" logger.log(x) // String: ✔ Несмотря на то, что теперь известно, что x - это String, вызов logger.log(x) по-прежнему разрешается в метод Logger.log, который принимает аргумент типа Any. Обратите внимание, что из-за позднего связывания фактический метод, вызываемый во время выполнения, будет переопределенным методом RefinedLogger.log. Встраивание сохраняет семантику. Независимо от того, определен ли logged как def или inline def, он выполняет одни и те же операции с некоторыми отличиями в производительности. Встроенные параметры Одним из важных применений встраивания является обеспечение постоянной оптимизации свертывания за пределами методов. Встроенные параметры не создают привязок, и их код дублируется везде, где они используются. inline def perimeter(inline radius: Double): Double = 2.0 * pi * radius В приведенном выше примере ожидается, что если radius известен статически, то все вычисления могут быть выполнены во время компиляции. Следующий вызов: perimeter(5.0) переписывается на: 2.0 * pi * 5.0 Затем встраивается pi (вначале принимаются inline val определения - radius): 2.0 * 3.141592653589793 * 5.0 Наконец, постоянно свернут до 31.4159265359 Встроенные параметры следует использовать только один раз. Нужно быть осторожным при использовании встроенного параметра более одного раза. Рассмотрим следующий код: inline def printPerimeter(inline radius: Double): Double = println(s\"Perimeter (r = $radius) = ${perimeter(radius)}\") Он отлично работает, когда передается константа или ссылка на val. printPerimeter(5.0) // встраивается как println(s\"Perimeter (r = ${5.0}) = ${31.4159265359}\") Но если передается большее выражение (возможно, с побочными эффектами), можно случайно дублировать работу. printPerimeter(longComputation()) // встраивается как println(s\"Perimeter (r = ${longComputation()}) = ${6.283185307179586 * longComputation()}\") Полезным применением встроенных параметров является предотвращение создания замыканий, вызванных использованием параметров по имени. inline def assert1(cond: Boolean, msg: =&gt; String) = if !cond then throw new Exception(msg) assert1(x, \"error1\") // is inlined as val cond = x def msg = \"error1\" if !cond then throw new Exception(msg) В приведенном выше примере видно, что использование параметра по имени приводит к локальному определению msg, которое выделяет замыкание перед проверкой условия. Если вместо этого использовать встроенный параметр, можно гарантировать, что условие будет проверено до того, как будет достигнут любой код, обрабатывающий исключение. В случае утверждения этот код никогда не должен быть достигнут. inline def assert2(cond: Boolean, inline msg: String) = if !cond then throw new Exception(msg) assert2(x, \"error2\") // is inlined as val cond = x if !cond then throw new Exception(\"error2\") В следующем примере показана разница в переводе между by-value, by-name и inline параметрами: inline def funkyAssertEquals(actual: Double, expected: =&gt; Double, inline delta: Double): Unit = if (actual - expected).abs &gt; delta then throw new AssertionError(s\"difference between ${expected} and ${actual} was larger than ${delta}\") funkyAssertEquals(computeActual(), computeExpected(), computeDelta()) // translates to // // val actual = computeActual() // def expected = computeExpected() // if (actual - expected).abs &gt; computeDelta() then // throw new AssertionError(s\"difference between ${expected} and ${actual} was larger than ${computeDelta()}\") Обычно встроенные параметры используются, когда необходимо распространить постоянные значения, чтобы обеспечить дальнейшую оптимизацию/сокращение. Рекурсивные встроенные методы Встроенные методы могут быть рекурсивными. Например, при вызове с постоянным n следующий метод power будет реализован прямым встроенным кодом без какого-либо цикла или рекурсии. inline def power(x: Double, n: Int): Double = if n == 0 then 1.0 else if n == 1 then x else val y = power(x, n / 2) if n % 2 == 0 then y * y else y * y * x power(expr, 10) // translates to // // val x = expr // val y1 = x * x // ^2 // val y2 = y1 * y1 // ^4 // val y3 = y2 * x // ^5 // y3 * y3 // ^10 Встроенные условия Если условием if является известная константа (true или false), то возможно, что после встраивания и сворачивания констант, условное выражение частично вычислится и сохранится только одна ветвь. Например, следующий метод power содержит некоторые условия if, которые потенциально могут развернуть рекурсию и удалить все вызовы методов. inline def power(x: Double, inline n: Int): Double = if (n == 0) 1.0 else if (n % 2 == 1) x * power(x, n - 1) else power(x * x, n / 2) Вызов power со статически известными константами приводит к следующему коду: power(2, 2) // первое встраивание val x = 2 if (2 == 0) 1.0 // мертвая ветка else if (2 % 2 == 1) x * power(x, 2 - 1) // мертвая ветка else power(x * x, 2 / 2) // частично свернулось до val x = 2 power(x * x, 1) Дальнейшие шаги встраивания: // дальнейшее встраивание val x = 2 val x2 = x * x if (1 == 0) 1.0 // мертвая ветка else if (1 % 2 == 1) x2 * power(x2, 1 - 1) else power(x2 * x2, 1 / 2) // мертвая ветка // частично свернулось до val x = 2 val x2 = x * x x2 * power(x2, 0) // дальнейшее встраивание val x = 2 val x2 = x * x x2 * { if (0 == 0) 1.0 else if (0 % 2 == 1) x * power(x, 0 - 1) // мертвая ветка else power(x * x, 0 / 2) // мертвая ветка } // частично свернулось до val x = 2 val x2 = x * x x2 * 1.0 Напротив, представим, что значение n неизвестно: power(2, unknownNumber) Руководствуясь встроенной аннотацией параметра, компилятор попытается развернуть рекурсию. Но безуспешно, так как параметр не известен статически. // первое встраивание val x = 2 if (unknownNumber == 0) 1.0 else if (unknownNumber % 2 == 1) x * power(x, unknownNumber - 1) else power(x * x, unknownNumber / 2) // дальнейшее встраивание val x = 2 if (unknownNumber == 0) 1.0 else if (unknownNumber % 2 == 1) x * { if (unknownNumber - 1 == 0) 1.0 else if ((unknownNumber - 1) % 2 == 1) x2 * power(x2, unknownNumber - 1 - 1) else power(x2 * x2, (unknownNumber - 1) / 2) } else { val x2 = x * x if (unknownNumber / 2 == 0) 1.0 else if ((unknownNumber / 2) % 2 == 1) x2 * power(x2, unknownNumber / 2 - 1) else power(x2 * x2, unknownNumber / 2 / 2) } // компиляция никогда не закончится ... Чтобы гарантировать, что ветвление действительно может быть выполнено во время компиляции, можно использовать inline if вариант if. Аннотирование условного выражения с помощью inline гарантирует, что условное выражение может быть уменьшено во время компиляции, и выдает ошибку, если условие не является статически известной константой. inline def power(x: Double, inline n: Int): Double = inline if (n == 0) 1.0 else inline if (n % 2 == 1) x * power(x, n - 1) else power(x * x, n / 2) power(2, 2) // Ok val unknownNumber = 2 power(2, unknownNumber) // error -- Error: ---------------------------------------------------------------------- |power(2, unknownNumber) |^^^^^^^^^^^^^^^^^^^^^^^ |Cannot reduce `inline if` because its condition is not a constant value: unknownNumber.==(0) | This location contains code that was inlined from rs$line$1:2 В прозрачном встроенном объекте inline if принудительно встраивает любое встроенное определение в его условие во время проверки типа. Переопределение встроенного метода Чтобы обеспечить правильное поведение при объединении статической функции inline def с динамической функцией интерфейсов и переопределении, необходимо наложить некоторые ограничения. Эффективно final Во-первых, все встроенные методы фактически являются final. Это гарантирует, что разрешение перегрузки во время компиляции будет вести себя так же, как во время выполнения. Сохранение подписи Во-вторых, переопределения должны иметь точно такую же сигнатуру, как и переопределенный метод, включая встроенные параметры. Это гарантирует, что семантика вызова одинакова для обоих методов. Сохраненные встроенные методы Можно реализовать или переопределить обычный метод с помощью встроенного метода. Рассмотрим следующий пример: trait Logger: def log(x: Any): Unit class PrintLogger extends Logger: inline def log(x: Any): Unit = println(x) Однако вызов метода log напрямую у PrintLogger приведет к встроенному коду, а его вызов на Logger — нет. Чтобы также допустить последнее, код log должен существовать во время выполнения. Это называется сохраненным встроенным методом. Например: val pl: PrintLogger = new PrintLogger val l: Logger = pl pl.log(\"msg\") // msg l.log(\"msg\") // msg Встроенные вызовы и динамически отправленные вызовы дают одинаковые результаты. Любой несохраненный inline def или val код всегда можно полностью инлайнить во всех местах вызовов. Следовательно, эти методы не понадобятся во время выполнения и могут быть удалены из байт-кода. Однако сохраненные встроенные методы должны быть совместимы со случаем, когда они не являются встроенными. В частности, сохраненные встроенные методы не могут принимать никаких встроенных параметров. Кроме того, inline if(как в примере power) не будет работать, так как if не может быть свёрнут в константу в сохраненном случае. Другие примеры включают конструкции метапрограммирования, которые имеют смысл только при встраивании. Абстрактные встроенные методы Также можно создавать абстрактные встроенные определения. trait InlineLogger: inline def log(inline x: Any): Unit class PrintLogger extends InlineLogger: inline def log(inline x: Any): Unit = println(x) Это заставляет реализацию log быть встроенным методом, а также позволяет использовать inline параметры. Парадоксально, но log на интерфейсе InlineLogger нельзя вызвать напрямую. Реализация метода неизвестна статически, и поэтому мы не знаем, что встраивать. Таким образом, вызов абстрактного встроенного метода приводит к ошибке. Пример: val pl: PrintLogger = new PrintLogger pl.log(\"msg\") val il: InlineLogger = pl il.log(\"msg\") |^^^^^^^^^^^^^ |Deferred inline method log in trait InlineLogger cannot be invoked Полезность абстрактных встроенных методов становится очевидной при использовании в другом встроенном методе: inline def logged(logger: InlineLogger, x: Any) = logger.log(x) Предположим, вызов для logged конкретного экземпляра PrintLogger: logged(new PrintLogger, \"🥧\") // inlined as val logger: PrintLogger = new PrintLogger logger.log(x) После встраивания вызов log девиртуализируется и становится известно, что он находится на PrintLogger. Поэтому и код log может быть встроен. Резюме встроенных методов Все inline методы являются final. Абстрактные inline методы могут быть реализованы только inline методами. Если inline метод переопределяет/реализует обычный метод, он должен быть сохранен, а сохраненные методы не могут иметь встроенных параметров. Абстрактные inline методы нельзя вызывать напрямую (за исключением встроенного кода). Отношение к @inline Scala 2 также определяет @inline аннотацию, которая используется в качестве подсказки для встроенного кода. Модификатор inline является более мощным вариантом, чем аннотация: расширение гарантирует лучшую эффективность, расширение происходит во внешнем интерфейсе, а не в бэкэнде, и расширение также применяется к рекурсивным методам. Определение константного выражения Правые части встроенных значений и аргументов для встроенных параметров должны быть константными выражениями в смысле, определенном SLS §6.24, включая специфичные для платформы расширения, такие как свертывание констант чисто числовых вычислений. Встроенное значение должно иметь литеральный тип, например 1 или true. inline val four = 4 // equivalent to inline val four: 4 = 4 Также возможно иметь встроенные значения типов, которые не имеют синтаксиса, например Short(4). trait InlineConstants: inline val myShort: Short object Constants extends InlineConstants: inline val myShort/*: Short(4)*/ = 4 Прозрачные встроенные методы Прозрачные встроенные строки (transparent inline) — это простое, но мощное расширение inline методов, открывающее множество вариантов использования метапрограммирования. Вызовы прозрачности позволяют встроенному фрагменту кода уточнять тип возвращаемого значения на основе точного типа встроенного выражения. Говоря языком Scala 2, прозрачность отражает суть “макросов белого ящика”. transparent inline def default(inline name: String): Any = inline if name == \"Int\" then 0 else inline if name == \"String\" then \"\" else ??? val n0: Int = default(\"Int\") // n0: Int = 0 val s0: String = default(\"String\") // s0: String = \"\" Обратите внимание, что даже если возвращаемый тип метода default — Any, первый вызов печатается как Int, а второй — как String. Тип возвращаемого значения представляет собой верхнюю границу типа внутри встроенного термина. Также можно было бы быть более точным и написать: transparent inline def default(inline name: String): 0 | \"\" = ... Хотя в этом примере кажется, что возвращаемый тип не нужен, он важен, когда встроенный метод является рекурсивным. Тип должен быть достаточно точным для рекурсии. Ещё пример: class A class B extends A: def m = true transparent inline def choose(b: Boolean): A = if b then new A else new B val obj1 = choose(true) // static type is A val obj2 = choose(false) // static type is B // obj1.m // compile-time error: `m` is not defined on `A` obj2.m // OK Здесь встроенный метод choose возвращает экземпляр любого из двух типов A или B. Если бы choose не был объявлен как transparent, результат его раскрытия всегда был бы типа A, даже если вычисляемое значение могло бы иметь подтип B. Встроенный метод является “черным ящиком” в том смысле, что детали его реализации не просачиваются. Но если указан модификатор transparent, расширение является типом расширенного тела. Если аргумент b равен true, то этот тип равен A, иначе — B. Следовательно, вызов m на obj2 пройдет проверку типов, поскольку obj2 имеет тот же тип, что и расширение choose(false), т.е. B. Прозрачные встроенные методы являются “белыми ящиками” в том смысле, что тип приложения такого метода может быть более специализированным, чем его объявленный возвращаемый тип, в зависимости от того, как расширяется метод. В следующем примере мы видим, как тип возвращаемого значения zero специализирован для одноэлементного типа 0, что позволяет приписать дополнению правильный тип 1. transparent inline def zero: Int = 0 val one: 1 = zero + 1 Прозрачные элементы влияют на двоичную совместимость Важно отметить, что изменение тела метода transparent inline def изменит способ его вызова. Это означает, что тело играет важную роль в совместимости двоичного кода и исходного кода этого интерфейса. Прозрачный и непрозрачный inline Как уже обсуждалось, прозрачные встроенные методы могут влиять на проверку типов в месте вызова. Технически это означает, что прозрачные встроенные методы должны быть расширены во время проверки типов программы. Другие встроенные методы встраиваются позже, когда программа полностью типизирована. Например, следующие две функции будут типизированы одинаково, но будут встроены в разное время. inline def f1: T = ... transparent inline def f2: T = (...): T Примечательным отличием является поведение transparent inline given. Если при встраивании такого определения сообщается об ошибке, это будет рассматриваться как неявное несоответствие поиска, и поиск будет продолжен. A transparent inline given может добавить описание типа в свой RHS (как в f2 предыдущем примере), чтобы избежать точного типа, но сохранить поведение поиска. С другой стороны, inline given принимается как неявное значение, а затем встраивается после ввода. Любая ошибка будет выдаваться как обычно. Встроенные match match выражение в теле определения метода inline может иметь префикс модификатора inline. Как и встроенные if, встроенные match гарантируют, что сопоставление с образцом может быть статически сокращено во время компиляции и сохраняется только одна ветвь. Если статической информации достаточно для однозначного выбора ветви, выражение сокращается до этой ветви и берется тип результата. Если нет, возникает ошибка времени компиляции, которая сообщает, что совпадение не может быть уменьшено. В приведенном ниже примере определяется встроенный метод с одним встроенным выражением соответствия, которое выбирает case на основе его статического типа: transparent inline def g(x: Any): Any = inline x match case x: String =&gt; (x, x) // Tuple2[String, String](x, x) case x: Double =&gt; x g(1.0d) // Has type 1.0d which is a subtype of Double // res5: Double = 1.0 // Has type 1.0d which is a subtype of Double g(\"test\") // Has type (String, String) // res6: Tuple2[String, String] = (\"test\", \"test\") x проверяется статически, и встроенное совпадение сокращается, возвращая соответствующее значение (со специализированным типом, потому что g объявлен transparent). Встроенные match предоставляют способ сопоставления статического типа некоторого выражения. Поскольку сопоставляется статический тип выражения, следующий код не будет компилироваться. val x: Any = \"test\" g(x) // error: // cannot reduce inline match with // scrutinee: this.x : (App0.this.x : Any) // patterns : case x @ _:String // case x @ _:Double // inline x match // ^ Значение x не помечено как inline и, как следствие, во время компиляции недостаточно информации о проверке, чтобы решить, какую ветвь выбрать. В примерах выше выполняется простой тест типа над объектом проверки. Тип может иметь более богатую структуру, как простой ADT ниже. toInt соответствует структуре числа в Чёрч-кодировке и вычисляет соответствующее целое число. trait Nat case object Zero extends Nat case class Succ[N &lt;: Nat](n: N) extends Nat transparent inline def toInt(n: Nat): Int = inline n match case Zero =&gt; 0 case Succ(n1) =&gt; toInt(n1) + 1 inline val natTwo = toInt(Succ(Succ(Zero))) val intTwo: 2 = natTwo Предполагается, что natTwo имеет одноэлементный тип 2. scala.compiletime Пакет scala.compiletime предоставляет полезные абстракции метапрограммирования, которые можно использовать в inline методах для обеспечения пользовательской семантики. Макросы Встраивание также является основным механизмом, используемым для написания макросов. Макросы позволяют управлять генерацией и анализом кода после встроенного вызова. inline def power(x: Double, inline n: Int) = ${ powerCode('x, 'n) } def powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] = ... Детали Дополнительные сведения о семантике inline см. в документе References: Scala 3 Macros Scala 3 Reference"
    } ,    
    {
      "title": "LazyList",
      "url": "/scalaworkbook/docs/collections/lazylist.html",
      "content": "LazyList Коллекции Scala также включают LazyList, который представляет собой ленивый неизменяемый связанный список. Он называется «ленивым» — или нестрогим — потому что вычисляет свои элементы только тогда, когда они необходимы. Поэтому ленивый список может быть бесконечно длинным. Обрабатываются только те элементы, которые запрашиваются. В остальном у ленивых списков те же параметры производительности, что и обычных. Если списки создаются с помощью оператора ::, то ленивые списки создаются схожей операцией #::. Вот простой пример ленивого списка с целыми числами 1, 2 и 3: val lazyList = 1 #:: 2 #:: 3 #:: LazyList.empty // lazyList: LazyList[Int] = LazyList(1, 2, 3) lazyList.toString // res0: String = \"LazyList(&lt;not computed&gt;)\" На первом месте в этом ленивом списке - 1, затем - 2 и 3. Но ни один из элементов здесь не выводится, потому что список еще не вычислен! Ленивые списки задуманы обрабатываться лениво, поэтому метод toString, не выводит всех элементов, не производя дополнительные вычисления. Ещё примеры: val x = LazyList.range(1, Int.MaxValue) x.take(1) x.take(5) x.map(_ + 1) LazyList начинает вычислять свои элементы только при вызове некоторых методов, например, foreach: x.take(1).foreach(println) // 1 Последовательность Фибоначчи Пример ленивого списка, содержащего последовательность Фибоначчи. def fibFrom(a: Int, b: Int): LazyList[Int] = a #:: fibFrom(b, a + b) Эта функция обманчиво проста. Первый элемент очевидно a, остальная часть - это последовательность Фибоначчи, начинающаяся с b, за которой следует a + b. Сложность состоит в том, чтобы вычислить эту последовательность, не вызывая бесконечной рекурсии. Если бы функция использовала :: вместо #::, то каждый вызов функции приводил бы к очередному вызову, вызывая тем самым бесконечную рекурсию. Но так как используется #::, то вычисление правой части не производится до тех пор, пока она не будет запрошена. Ниже приведены первые элементы последовательности Фибоначчи, начиная с двух едениц: val fibs = fibFrom(1, 1).take(7) // fibs: LazyList[Int] = LazyList(1, 1, 2, 3, 5, 8, 13) fibs.toList // res5: List[Int] = List(1, 1, 2, 3, 5, 8, 13) Детали Для получения дополнительной информации об использовании, преимуществах и недостатках строгих и нестрогих (ленивых) коллекций см. обсуждение “строгих” и “нестрогих” коллекций на странице “Архитектура Scala 2.13’s Collections”. References: Scala3 book Scala3 book, Collections Types Scala, Immutable collections"
    } ,    
    {
      "title": "Ссылки",
      "url": "/scalaworkbook/docs/scaladoc/linking.html",
      "content": "Связующая документация Основной синтаксис Определение ссылки выглядит следующим образом: [[scala.collection.immutable.List]]. Другими словами, определение ссылки представляет собой последовательность идентификаторов, разделенных знаком .. Идентификаторы также могут быть разделены с помощью #. По умолчанию идентификатор id ссылается на первую (в исходном порядке) сущность с именем id. Идентификатор может заканчиваться на $, что заставляет его ссылаться на значение (объект, значение, given); идентификатор также может заканчиваться на !, что заставляет его ссылаться на тип (класс, псевдоним типа, член типа). Ссылки разрешаются относительно текущего местоположения в источнике. То есть при документировании класса ссылки относятся к сущности, включающей класс (пакет, класс, объект); то же самое относится к документированию определений. Специальные символы в ссылках могут быть экранированы обратной косой чертой, что вместо этого делает их частью идентификаторов. Например, [[scala.collection.immutable\\.List]] ссылается на класс immutable.List, указанный в package scala.collection. Новый синтаксис Определение ссылок Scaladoc было расширено, чтобы сделать их более удобными для записи и чтения в исходном коде. Также целью было сблизить связь и синтаксис Scala. Новые функции: а) package может использоваться в качестве префикса для ссылки на прилагаемый пакет. Пример: package utils class C { def foo = \"foo\" } /** See also [[package.C]]. */ class D { def bar = \"bar\" } Ключевое слово package помогает сделать ссылки на прилагаемый пакет короче и немного более устойчивым к рефакторингу имен. б) this может использоваться в качестве префикса для ссылки на прилагаемый классоподобный пример: class C { def foo = \"foo\" /** This is not [[this.foo]], this is bar. */ def bar = \"bar\" } Использование здесь ключевого слова помогает сделать ссылки более привычными, а также помогает ссылкам пережить изменения имени класса. в) Обратные кавычки могут использоваться для экранирования идентификаторов. Пример: def `([.abusive.])` = ??? /** TODO: Figure out what [[`([.abusive.])`]] is. */ def foo = `([.abusive.])` Ранее (версии 2.x) для ссылки на такие идентификаторы в Scaladoc требовалось экранирование обратной косой чертой. Теперь (версии 3.x) Scaladoc позволяет использовать знакомую обратную кавычку Scala. Зачем сохранять синтаксис Wiki для ссылок? Есть несколько причин, по которым синтаксис Wiki сохранен для ссылок на документацию вместо повторного использования синтаксиса Markdown. Это: Безымянные ссылки в Markdown уродливы: [](definition) против [[definition]] Безусловно, большинство ссылок в документации безымянные. Должно быть очевидно, как их писать. Поиск локального члена конфликтует с фрагментами URL: [](#field) против [[#field]] Разрешение перегрузки противоречит синтаксису MD: [](meth(Int)) против [[meth(Int)]] Теперь, когда есть парсер для синтаксиса ссылок, можно разрешить пробелы внутри (в Scaladoc нужно было экранировать их косой чертой), но это не распознается как ссылка в Markdown: [](meth(Int, Float)) против [[meth(Int, Float)]] Ни одна из них не делает полностью невозможным использование стандартного синтаксиса ссылок Markdown, но они делают его гораздо более неуклюжим и уродливым, чем нужно. Кроме того, синтаксис ссылок Markdown даже не сохраняет никаких символов. References: Scaladoc Guide"
    } ,    
    {
      "title": "List",
      "url": "/scalaworkbook/docs/collections/list.html",
      "content": "List List представляет собой линейную неизменяемую последовательность. Каждый раз, когда в список добавляются или удаляются элементы, по сути создается новый список из существующего. Он обеспечивает быстрый (за постоянное время) доступ как к первому элементу, так и к остальному списку, а также быструю операцию добавления нового элемента в начало списка. Большинство оставшихся операции занимают линейное время исполнения. Создание списка Список можно создать различными способами: val ints = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) val names = List(\"Joel\", \"Chris\", \"Ed\") // names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") val namesAgain = \"Joel\" :: \"Chris\" :: \"Ed\" :: Nil // namesAgain: List[String] = List(\"Joel\", \"Chris\", \"Ed\") При желании тип списка можно объявить, хотя обычно в этом нет необходимости: val ints: List[Int] = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) val names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") // names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") Одно исключение — когда в коллекции смешанные типы; в этом случае тип желательно указывать явно: val things: List[Any] = List(1, \"two\", 3.0) // things: List[Any] = List(1, \"two\", 3.0) Добавление элементов в список Поскольку список неизменяем, в него нельзя добавлять новые элементы. Вместо этого создается новый список с добавленными к существующему списку элементами. Например, учитывая этот список: val a = List(1, 2, 3) Для добавления одного элемента используется метод ::, для добавления нескольких — :::, как показано здесь: val b = 0 :: a // b: List[Int] = List(0, 1, 2, 3) val c = List(-1, 0) ::: a // c: List[Int] = List(-1, 0, 1, 2, 3) Также можно добавить элементы в конец списка, но, поскольку список является односвязным, следует добавлять к нему элементы только в начало; добавление элементов в конец списка — относительно медленная операция, особенно при работе с большими последовательностями. Если необходимо добавлять к неизменяемой последовательности элементы в начало и конец, используйте Vector. Поскольку List является связанным списком, крайне нежелательно пытаться получить доступ к элементам больших списков по значению их индекса. Например, если есть List с миллионом элементов, доступ к такому элементу, как myList(999_999), займет относительно много времени, потому что этот запрос должен пройти почти через все элементы. Если есть большая коллекция и необходимо получать доступ к элементам по их индексу, вместо List используйте Vector или ArrayBuffer. Как запомнить названия методов В методах Scala символ : представляет сторону, на которой находится последовательность, поэтому, когда используется метод +:, список нужно указывать справа: 0 +: a // res2: List[Int] = List(0, 1, 2, 3) Аналогично, если используется :+, список должен быть слева: a :+ 4 // res3: List[Int] = List(1, 2, 3, 4) Кроме того, хорошей особенностью этих символических имен методов является то, что они стандартизированы. Те же имена методов используются с другими неизменяемыми последовательностями, такими как Seq и Vector. Также можно использовать несимволические имена методов для добавления элементов в начало (a.prepended(4)) или конец (a.appended(4)). Как пройтись по списку Представим, что есть список имён: val names = List(\"Joel\", \"Chris\", \"Ed\") Напечатать каждое имя можно следующим способом: for name &lt;- names do println(name) // Joel // Chris // Ed Преимуществом использования циклов for с коллекциями заключается в том, что Scala стандартизирован, и один и тот же подход работает со всеми последовательностями, включая Array, ArrayBuffer, List, Seq, Vector, Map, Set и т. д. Немного истории Список Scala подобен списку из языка программирования Lisp, который был впервые представлен в 1958 году. Действительно, в дополнение к привычному способу создания списка: val ints = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) точно такой же список можно создать следующим образом: val list = 1 :: 2 :: 3 :: Nil // list: List[Int] = List(1, 2, 3) Это работает, потому что List — односвязный список, оканчивающийся элементом Nil, а :: — это метод List, работающий как оператор “cons” в Lisp. References: Scala3 book Scala3 book, Collections Types Scala, Immutable collections"
    } ,    
    {
      "title": "Macros",
      "url": "/scalaworkbook/docs/metaprogramming/macros.html",
      "content": "Macros Встроенные методы предоставляют элегантную технику метапрограммирования, выполняя некоторые операции во время компиляции. Однако иногда встраивания недостаточно, и нужны более мощные способы анализа и синтеза программ во время компиляции. Макросы позволяют делать именно это: относиться к программам как к данным и манипулировать ими. Макросы рассматривают программы как значения С помощью макроса программы можно рассматривать как значения, что позволяет анализировать и генерировать их во время компиляции. Выражение Scala с типом T представлено экземпляром типа scala.quoted.Expr[T]. Более детально о типе Expr[T], а также различные способы анализа и построения экземпляров, будут раскрыты в главах Quoted Code и Reflection. Пока достаточно знать, что макросы — это метапрограммы, которые манипулируют выражениями типа Expr[T]. Следующая реализация макроса просто печатает выражение предоставленного аргумента: def inspectCode(x: Expr[Any])(using Quotes): Expr[Any] = println(x.show) x После печати выражения аргумента исходный аргумент возвращается как выражение Scala типа Expr[Any]. Как уже упоминалось в разделе Inline, встроенные методы предоставляют точку входа для определений макросов: inline def inspect(inline x: Any): Any = ${ inspectCode('x) } Все макросы определены с расширением inline def. Реализация этой точки входа всегда имеет одинаковую форму: они содержат только одну склейку ${ ... } склейка содержит единственный вызов метода, реализующего макрос (например inspectCode). вызов реализации макроса получает параметры в кавычках (то есть 'x вместо x) и контекстное Quotes. Вызов inspect макроса inspect(sys error \"abort\") выводит строковое представление выражения аргумента во время компиляции: scala.sys.error(\"abort\") Макросы и параметры типа Если у макроса есть параметры типа, реализация также должна о них знать. Точно так же, как scala.quoted.Expr[T] представляет выражение Scala типа T, scala.quoted.Type[T] используется для представления типа Scala T. inline def logged[T](inline x: T): T = ${ loggedCode('x) } def loggedCode[T](x: Expr[T])(using Type[T], Quotes): Expr[T] = ... И экземпляр Type[T], и контекст Quotes автоматически предоставляются склейкой в соответствующем встроенном методе (то есть logged) и могут использоваться реализацией макроса. Определение и использование макросов Ключевое различие между встраиванием и макросами заключается в способе их оценки. Встраивание работает, переписывая код и выполняя оптимизацию на основе правил, известных компилятору. С другой стороны, макрос выполняет написанный пользователем код, генерирующий код, до которого макрос расширяется. Технически компиляция встроенного кода ${ inspectCode('x) } вызывает метод inspectCode во время компиляции (через Java reflection), а затем метод inspectCode выполняется как обычный код. Чтобы иметь возможность выполнить inspectCode, нужно сначала скомпилировать его исходный код. Как следствие, мы не можем определить и использовать макрос в одном и том же классе/файле. Однако можно иметь определение макроса и его вызов в одном и том же проекте, если реализация макроса может быть скомпилирована первой. Приостановленные файлы Чтобы разрешить определение и использование макросов в одном и том же проекте, расширяются только те вызовы макросов, которые уже были скомпилированы. Для всех остальных (неизвестных) вызовов макросов компиляция файла приостанавливается. Приостановленные файлы компилируются только после успешной компиляции всех незаблокированных файлов. В некоторых случаях будут циклические зависимости, которые будут блокировать завершение компиляции. Чтобы получить больше информации о том, какие файлы приостановлены, можно использовать флаг компилятора -Xprint-suspension. Пример: статическая оценка power с помощью макросов Вспомним определение power из раздела Inline, которое специализировало вычисление xⁿ для статически известных значений n. inline def power(x: Double, inline n: Int): Double = inline if n == 0 then 1.0 else inline if n % 2 == 1 then x * power(x, n - 1) else power(x * x, n / 2) В оставшейся части этого раздела будет определен макрос, который вычисляет xⁿ для статически известных значений x и n. Хотя это также возможно с помощью inline, реализация с помощью макросов проиллюстрирует несколько вещей. inline def power(inline x: Double, inline n: Int) = ${ powerCode('x, 'n) } def powerCode( x: Expr[Double], n: Expr[Int] )(using Quotes): Expr[Double] = ... Простые выражения powerCode можно было бы реализовать следующим образом: def pow(x: Double, n: Int): Double = if n == 0 then 1 else x * pow(x, n - 1) def powerCode( x: Expr[Double], n: Expr[Int] )(using Quotes): Expr[Double] = val value: Double = pow(x.valueOrError, n.valueOrError) Expr(value) Здесь операция pow представляет собой простую функцию Scala, которая вычисляет значение xⁿ. Интересная часть заключается в том, как мы создаем и изучаем Expr-ы. Создание выражений из значений Давайте сначала посмотрим Expr.apply(value). Учитывая значение типа T, этот вызов вернет выражение, содержащее код, представляющий данное значение (то есть типа Expr[T]). Значение аргумента Expr вычисляется во время компиляции, во время выполнения нужно только создать экземпляр этого значения. Создание выражений из значений работает для всех примитивных типов, кортежей любой арности, Class, Array, Seq, Set, List, Map, Option, Either, BigInt, BigDecimal, StringContext. Другие типы также могут работать, если для них реализован ToExpr, как будет показано позже. Извлечение значений из выражений Второй метод, который используется при реализации powerCode - это Expr[T].valueOrError, имеющий эффект, противоположный Expr.apply. Он пытается извлечь значение типа T из выражения типа Expr[T]. Это может быть успешным только в том случае, если выражение непосредственно содержит код значения, в противном случае будет выдано исключение, которое остановит раскрытие макроса и сообщит, что выражение не соответствует значению. Вместо valueOrError, можно было бы также использовать операцию value, которая вернет Option. Таким образом, можно сообщить об ошибке с помощью пользовательского сообщения. ... (x.value, n.value) match case (Some(base), Some(exponent)) =&gt; pow(base, exponent) case (Some(_), _) =&gt; report.error(\"Expected a known value for the exponent, but was \" + n.show, n) case _ =&gt; report.error(\"Expected a known value for the base, but was \" + x.show, x) Кроме того, также можно использовать экстрактор Expr.unapply: ... (x, n) match case (Expr(base), Expr(exponent)) =&gt; pow(base, exponent) case (Expr(_), _) =&gt; ... case _ =&gt; ... Операции value, valueOrError и Expr.unapply будут работать для всех примитивных типов, кортежей любой арности, Option, Seq, Set, Map, Either и StringContext. Другие типы также могут работать, если для них реализован FromExpr, как будет показано позже. Отображение выражений В реализации inspectCode было видно, как преобразовать выражения в строковое представление исходного кода с помощью метода .show. Это может быть полезно для отладки реализации макросов: def debugPowerCode( x: Expr[Double], n: Expr[Int] )(using Quotes): Expr[Double] = println( s\"\"\"powerCode | x := ${x.show} | n := ${n.show}\"\"\".stripMargin) val code = powerCode(x, n) println(s\" code := ${code.show}\") code Работа с переменными аргументами Переменные аргументы в Scala представлены с помощью Seq, поэтому, когда пишется макрос с переменным аргументом, он будет передан как Expr[Seq[T]]. Можно восстановить каждый отдельный аргумент (типа Expr[T]) с помощью экстрактора scala.quoted.Varargs. import scala.quoted.Varargs inline def sumNow(inline nums: Int*): Int = ${ sumCode('nums) } def sumCode(nums: Expr[Seq[Int]])(using Quotes): Expr[Int] = nums match case Varargs(numberExprs) =&gt; // numberExprs: Seq[Expr[Int]] val numbers: Seq[Int] = numberExprs.map(_.valueOrError) Expr(numbers.sum) case _ =&gt; report.error( \"Expected explicit argument\" + \"Notation `args: _*` is not supported.\", numbersExpr) Экстрактор сопоставит вызов sumNow(1, 2, 3) и извлечет Seq[Expr[Int]], содержащий код каждого параметра. Но если попытаться сопоставить аргумент вызова sumNow(nums: _*), экстрактор не совпадет. Varargs также может быть использован в качестве конструктора. Varargs(Expr(1), Expr(2), Expr(3)) вернет Expr[Seq[Int]]. Сложные выражения Было показано, как создавать и распаковывать выражения, соответствующие простым значениям. Для работы с более сложными выражениями Scala предлагает различные средства метапрограммирования, начиная от дополнительные конструкторы, такие как Expr.apply, сопоставление с образцом в цитатах, reflection API; каждый из них усложняется и потенциально теряет гарантии безопасности. Обычно рекомендуется чаще использовать простые API. В оставшейся части этого раздела вводятся еще несколько дополнительных конструкторов и деструкторов, а в последующих главах представлены более продвинутые API. Коллекции Было показано, как преобразовать List[Int] в Expr[List[Int]] используя Expr.apply. Как насчет преобразования List[Expr[Int]] в Expr[List[Int]]? Упоминалось, что Varargs.apply может сделать это для последовательностей; аналогично, для других типов коллекций доступны соответствующие методы: Expr.ofList: преобразует List[Expr[T]] в Expr[List[T]] Expr.ofSeq: преобразует Seq[Expr[T]] в Expr[Seq[T]] (так же, как Varargs) Expr.ofTupleFromSeq: преобразует Seq[Expr[T]] в Expr[Tuple] Expr.ofTuple: преобразует (Expr[T1], ..., Expr[Tn]) в Expr[(T1, ..., Tn)] Простые блоки Конструктор Expr.block предоставляет простой способ создания блока кода { stat1; ...; statn; expr }. Его первые аргументы — это список со всеми операторами, а второй аргумент — выражение в конце блока. inline def test(inline ignore: Boolean, computation: =&gt; Unit): Boolean = ${ testCode('ignore, 'computation) } def testCode(ignore: Expr[Boolean], computation: Expr[Unit])(using Quotes) = if ignore.valueOrError then Expr(false) else Expr.block(List(computation), Expr(true)) Конструктор Expr.block полезен, когда необходимо сгенерировать код, содержащий несколько побочных эффектов. Вызов макроса test(false, EXPRESSION) будет генерировать { EXPRESSION; true}, в то время как вызов test(true, EXPRESSION) приведет к false. Простое сопоставление Этот метод Expr.matches можно использовать для проверки равенства одного выражения другому. С помощью этого метода можно было бы реализовать value операцию Expr[Boolean] следующим образом: def value(boolExpr: Expr[Boolean]): Option[Boolean] = if boolExpr.matches(Expr(true)) then Some(true) else if boolExpr.matches(Expr(false)) then Some(false) else None Его также можно использовать для сравнения двух написанных пользователем выражений. Обратите внимание, что matches выполняется только ограниченная нормализация, и хотя, например, Scala выражение 2 соответствует выражению { 2 }, это не относится к выражению { val x: Int = 2; x }. Произвольные выражения Можно создать произвольный код Scala Expr[T], заключив его в цитаты. Например, '{ ${expr}; true } сгенерирует Expr[Int] эквивалент Expr.block(List(expr), Expr(true)). В следующем разделе, посвященном Quoted Code, цитаты представлены более подробно. References: Scala 3 Guide Scala 3 Reference"
    } ,    
    {
      "title": "main методы",
      "url": "/scalaworkbook/docs/methods/main-methods.html",
      "content": "main методы Scala предлагает следующий способ определения программ, которые можно вызывать из командной строки: добавление аннотации @main к методу превращает его в точку входа исполняемой программы: @main def hello() = println(\"Hello, world\") Достаточно сохранить эту строку кода в файле с именем, например, Hello.scala (имя файла необязательно должно совпадать с именем метода) и скомпилировать его с помощью scalac: $ scalac Hello.scala Затем запустить с помощью scala: $ scala hello Hello, world Аннотированный метод @main может быть написан либо на верхнем уровне (как показано), либо внутри статически доступного объекта. В любом случае имя программы - это имя метода без каких-либо префиксов объектов. Аргументы командной строки Метод @main может обрабатывать аргументы командной строки с разными типами. Например, данный метод @main, который принимает параметры Int, String и дополнительные строковые параметры: @main def happyBirthday(age: Int, name: String, others: String*) = val suffix = (age % 100) match case 11 | 12 | 13 =&gt; \"th\" case _ =&gt; (age % 10) match case 1 =&gt; \"st\" case 2 =&gt; \"nd\" case 3 =&gt; \"rd\" case _ =&gt; \"th\" val sb = StringBuilder(s\"Happy $age$suffix birthday, $name\") for other &lt;- others do sb.append(\" and \").append(other) sb.toString После компиляции кода создается основная программа с именем happyBirthday, которая вызывается следующим образом: $ scala happyBirthday 23 Lisa Peter Happy 23rd Birthday, Lisa and Peter! Как показано, метод @main может иметь произвольное количество параметров. Для каждого типа параметра должен быть экземпляр scala.util.FromString, который преобразует аргумент из String в требуемый тип параметра. Также, как показано, список параметров основного метода может заканчиваться повторяющимся параметром типа String*, который принимает все оставшиеся аргументы, указанные в командной строке. Программа, реализованная с помощью метода @main, проверяет, что в командной строке достаточно аргументов для заполнения всех параметров, и что строки аргументов могут быть преобразованы в требуемые типы. Если проверка завершается неудачей, программа завершается с сообщением об ошибке: $ scala happyBirthday 22 Illegal command line after first argument: more arguments expected $ scala happyBirthday sixty Fred Illegal command line: java.lang.NumberFormatException: For input string: \"sixty\" Детали Компилятор Scala генерирует программу из @main метода f следующим образом: он создает класс с именем f в пакете, где был найден метод @main. класс имеет статический метод main с обычной сигнатурой Java main метода: принимает Array[String] в качестве аргумента и возвращает Unit. сгенерированный main метод вызывает метод f с аргументами, преобразованными с помощью методов в объекте scala.util.CommandLineParser. Например, приведенный выше метод happyBirthday генерирует дополнительный код, эквивалентный следующему классу: final class happyBirthday { import scala.util.{CommandLineParser as CLP} &lt;static&gt; def main(args: Array[String]): Unit = try happyBirthday( CLP.parseArgument[Int](args, 0), CLP.parseArgument[String](args, 1), CLP.parseRemainingArguments[String](args, 2)) catch { case error: CLP.ParseError =&gt; CLP.showError(error) } } Примечание: В этом сгенерированном коде модификатор &lt;static&gt; выражает, что main метод генерируется как статический метод класса happyBirthday. Эта функция недоступна для пользовательских программ в Scala. Вместо неё обычные “статические” члены генерируются в Scala с использованием object. @main методы — это рекомендуемый способ создания программ, вызываемых из командной строки в Scala 3. Они заменяют предыдущий подход, который заключался в создании объекта, расширяющего класс App. References: Scala3 book Scala3 book, main Methods Scala 3 Reference"
    } ,    
    {
      "title": "Maps",
      "url": "/scalaworkbook/docs/collections/maps.html",
      "content": "Maps Map — это итерируемая коллекция, состоящая из пар ключей и значений. В Scala есть как изменяемые, так и неизменяемые типы Map. В этом разделе показано, как использовать неизменяемый Map. Создание Map Неизменяемая Map создается следующим образом: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AZ\" -&gt; \"Arizona\" ) Перемещаться по элементам Map в цикле for можно следующим образом: for (k, v) &lt;- states do println(s\"key: $k, value: $v\") // key: AK, value: Alaska // key: AL, value: Alabama // key: AZ, value: Arizona Доступ к элементам Map Доступ к элементам Map осуществляется через указание в скобках значения ключа: val ak = states(\"AK\") // ak: String = \"Alaska\" val al = states(\"AL\") // al: String = \"Alabama\" На практике также используются такие методы, как keys, keySet, keysIterator, циклы for и функции высшего порядка, такие как map, для работы с ключами и значениями Map. Добавление элемента в Map При добавлении элементов в неизменяемую карту с помощью + и ++, создается новая карта: val a = Map(1 -&gt; \"one\") // a: Map[Int, String] = Map(1 -&gt; \"one\") val b = a + (2 -&gt; \"two\") // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") val c = b ++ Seq( 3 -&gt; \"three\", 4 -&gt; \"four\" ) // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\") Удаление элементов из Map Элементы удаляются с помощью методов - или --. В случае неизменяемой Map создается новый экземпляр, который нужно присвоить новой переменной: val a = Map( 1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\" ) // a: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\") val b = a - 4 // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\") val c = a - 4 - 3 // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") Обновление элементов в Map Чтобы обновить элементы на неизменяемой Map, используется метод update (или оператор +): val a = Map( 1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\" ) // a: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\") val b = a.updated(3, \"THREE!\") // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"THREE!\") val c = a + (2 -&gt; \"TWO...\") // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"TWO...\", 3 -&gt; \"three\") Перебор элементов в Map Элементы в Map можно перебрать с помощью цикла for, как и для остальных коллекций: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AZ\" -&gt; \"Arizona\" ) // states: Map[String, String] = Map( // \"AK\" -&gt; \"Alaska\", // \"AL\" -&gt; \"Alabama\", // \"AZ\" -&gt; \"Arizona\" // ) for (k, v) &lt;- states do println(s\"key: $k, value: $v\") // key: AK, value: Alaska // key: AL, value: Alabama // key: AZ, value: Arizona Существует много способов работы с ключами и значениями на Map. Общие методы Map включают foreach, map, keys и values. В Scala есть много других специализированных типов Map, включая CollisionProofHashMap, HashMap, LinkedHashMap, ListMap, SortedMap, TreeMap, WeakHashMap и другие. References: Scala3 book Scala3 book, Collections Types Scala, Immutable collections Scala, Mutable collections"
    } ,    
    {
      "title": "Match Types",
      "url": "/scalaworkbook/docs/type-system/match-types.html",
      "content": "Типы match Тип match сводится к одной из его правых частей, в зависимости от проверяемого типа. Например: type Elem[X] = X match case String =&gt; Char case Array[t] =&gt; t case Iterable[t] =&gt; t Матчинг определяет тип, который сокращается следующим образом: Elem[String] =:= Char Elem[Array[Int]] =:= Int Elem[List[Float]] =:= Float Elem[Nil.type] =:= Nothing Здесь под =:= подразумевается, что левая и правая стороны являются взаимными подтипами друг друга. В общем случае тип match имеет вид: S match { P1 =&gt; T1 ... Pn =&gt; Tn } где S, T1, ..., Tn - типы, а P1, ..., Pn - шаблоны типов. Переменные типа в шаблонах, как обычно, начинаются со строчной буквы. Типы match могут составлять часть определений рекурсивных типов. Пример: type LeafElem[X] = X match case String =&gt; Char case Array[t] =&gt; LeafElem[t] case Iterable[t] =&gt; LeafElem[t] case AnyVal =&gt; X Определения рекурсивного типа match также могут иметь верхнюю границу, например: type Concat[Xs &lt;: Tuple, +Ys &lt;: Tuple] &lt;: Tuple = Xs match case EmptyTuple =&gt; Ys case x *: xs =&gt; x *: Concat[xs, Ys] В этом определении известно, что каждый экземпляр Concat[A, B], редуцированный или нет, является подтипом Tuple. Это необходимо для проверки типа рекурсивного вызова x *: Concat[xs, Ys], поскольку *: требует в качестве правого операнда Tuple. Зависимая типизация Типы match можно использовать для определения методов с зависимыми типами. Например: def leafElem[X](x: X): LeafElem[X] = x match case x: String =&gt; x.charAt(0) case x: Array[t] =&gt; leafElem(x(0)) case x: Iterable[t] =&gt; leafElem(x.head) case x: AnyVal =&gt; x Результат: leafElem(Array(List(\"abc\"))) // res0: Char = 'a' Этот специальный режим ввода выражений match используется только при выполнении следующих условий: шаблоны выражений match не имеют условий (guards) тип проверяемого выражения match является подтипом типа match выражение match и тип match имеют одинаковое количество cases все шаблоны выражений match являются типизированными шаблонами, и эти типы относятся к соответствующим шаблонам типов как =:=. Termination Определения типов match могут быть рекурсивными, а это означает, что при сокращении типов match можно попасть в бесконечный цикл. Поскольку редукция связана с созданием подтипов, есть механизм обнаружения циклов. В результате следующее выдаст разумное сообщение об ошибке: type L[X] = X match case Int =&gt; L[X] def g[X]: L[X] = ??? | val x: Int = g[Int] | ^ | Recursion limit exceeded. | Maybe there is an illegal cyclic reference? | If that's not the case, you could also try to | increase the stacksize using the -Xss JVM option. | A recurring operation is (inner to outer): | | subtype LazyRef(Test.L[Int]) &lt;:&lt; Int Внутри компилятор Scala обнаруживает такие циклы, превращая выбранные переполнения стека в ошибки типов. Если во время создания подтипа происходит переполнение стека, исключение будет перехвачено и преобразовано в ошибку времени компиляции, указывающую на трассировку тестов подтипа, вызвавшую переполнение, без отображения полной трассировки стека. Match Types Variance Все позиции типа в типе match (проверяемые, шаблоны, тела) считаются инвариантными. References: Scala 3 Reference"
    } ,    
    {
      "title": "Metaprogramming",
      "url": "/scalaworkbook/docs/metaprogramming.html",
      "content": "Metaprogramming На следующих страницах представлен дизайн метапрограммирования в Scala. Он вводит следующие основные средства: inline функция позволяет помечать некоторые абстракции (значения и методы) как статически сводимые. Она обеспечивает точку входа для макросов и других утилит метапрограммирования. Операции времени компиляции предлагают дополнительные утилиты метапрограммирования, которые можно использовать в inline методах (например, для улучшения отчетов об ошибках) без необходимости определять макрос. Макросы построены на двух фундаментальных операциях: цитатах и склейках. Цитата преобразует программный код в данные, а именно в (древовидное) представление этого кода. Это выражается как '{...} для выражений, так и '[...] для типов. Склеивание, выраженное как ${ ... }, идет другим путем: оно преобразует представление программы в программный код. Вместе с inline, эти две абстракции позволяют программно конструировать код. Постановка во время выполнения. В то время как макросы создают код во время компиляции, постановка позволяет программам создавать новый код во время выполнения. Таким образом, генерация кода может зависеть не только от статических данных, но и от данных, доступных во время выполнения. Это разделяет оценку программы на две или более стадий. Следовательно, этот метод генеративного программирования называется “Многоэтапное программирование”. Постановка построена на тех же принципах, что и макросы. Он использует цитаты и склейки, но не включает inline. Рефлексия Цитаты — это представление кода в виде “черного ящика”. Они могут быть параметризованы и составлены с помощью склеивания, но их структура не может быть проанализирована извне. Отражение TASTy позволяет анализировать структуру кода, частично раскрывая тип представления фрагмента кода в стандартном API. Тип представления — это форма типизированного абстрактного синтаксического дерева, которое порождает TASTy моникер. TASTy Inspection Типизированные абстрактные синтаксические деревья сериализуются в специальном сжатом двоичном формате, хранящемся в .tasty файлах. Проверка TASTy позволяет загружать эти файлы и анализировать древовидную структуру их содержимого. References: Scala 3 Guide Scala 3 Reference"
    } ,    
    {
      "title": "Определение методов",
      "url": "/scalaworkbook/docs/methods/method-features.html",
      "content": "Определение методов Синтаксис простого метода выглядит следующим образом: def methodName(param1: Type1, param2: Type2): ReturnType = // здесь тело метода end methodName // опционально, можно не указывать В этом синтаксисе: ключевое слово def используется для определения метода для наименования методов согласно стандартам Scala используется camel case convention у параметров метода необходимо всегда указывать тип возвращаемый тип метода указывать необязательно методы могут состоять как только из одной строки, так и из нескольких строк метку окончания метода end methodName указывать необязательно, её рекомендуется указывать только для длинных методов Вот два примера однострочного метода с именем add, который принимает два входных параметра Int. Первая версия явно показывает возвращаемый тип метода - Int, а вторая - нет: def add(a: Int, b: Int): Int = a + b def add(a: Int, b: Int) = a + b У публичных методов рекомендуется всегда указывать тип возвращаемого значения. Объявление возвращаемого типа может упростить его понимание при просмотре кода другого человека или своего кода спустя некоторое время. Вызов методов Вызов методов прост: val x = add(1, 2) Коллекции Scala имеют десятки встроенных методов. Эти примеры показывают, как их вызывать: val x = List(1, 2, 3) // x: List[Int] = List(1, 2, 3) x.size // res1: Int = 3 x.contains(1) // res2: Boolean = true x.map(_ * 10) // res3: List[Int] = List(10, 20, 30) Внимание: size не принимает аргументов и возвращает количество элементов в списке метод contains принимает один аргумент — значение для поиска map принимает один аргумент - функцию; в данном случае в него передается анонимная функция Многострочные методы Если метод длиннее одной строки, начинайте тело метода со второй строки с отступом вправо: def addThenDouble(a: Int, b: Int): Int = val sum = a + b sum * 2 addThenDouble(1, 1) // res5: Int = 4 В этом методе: sum — неизменяемая локальная переменная; к ней нельзя получить доступ вне метода последняя строка удваивает значение sum - именно это значение возвращается из метода Обратите внимание, что нет необходимости в операторе return в конце метода. Поскольку почти все в Scala является выражением — то это означает, что каждая строка кода возвращает (или вычисляет) значение — нет необходимости использовать return. Это видно на примере того же метода, но в более сжатой форме: def addThenDouble(a: Int, b: Int): Int = (a + b) * 2 В теле метода можно использовать все возможности Scala: if/else выражения match выражения циклы while циклы for и for выражения присвоение переменных вызовы других методов определения других методов В качестве ещё одного примера многострочного метода, getStackTraceAsString преобразует свой входной параметр Throwable в правильно отформатированную строку: def getStackTraceAsString(t: Throwable): String = val sw = StringWriter() t.printStackTrace(PrintWriter(sw)) sw.toString В этом методе: в первой строке переменная sw принимает значение нового экземпляра StringWriter вторая строка сохраняет содержимое трассировки стека в StringWriter третья строка возвращает строковое представление трассировки стека Рекомендации о методах, которые не принимают параметров Когда метод не принимает параметров, говорят, что он имеет arity уровень 0 (arity-0). Аналогично, если метод принимает один параметр - это метод с arity-1. Когда создаются методы arity-0: если метод выполняет побочные эффекты, такие как вызов println, метод объявляется с пустыми скобками. если метод не выполняет побочных эффектов, например, получение размера коллекции, что аналогично доступу к полю в коллекции, круглые скобки опускаются. Например, этот метод выполняет побочный эффект, поэтому он объявлен с пустыми скобками: def speak() = println(\"hi\") При вызове метода нужно обязательно указывать круглые скобки, если он был объявлен с ними: speak // error: \"method speak must be called with () argument\" speak() // prints \"hi\" Хотя это всего лишь соглашение, его соблюдение значительно улучшает читаемость кода: с первого взгляда становится понятно, что метод с arity-0 имеет побочные эффекты. Использование if в качестве тела метода Поскольку выражения if/else возвращают значение, их можно использовать в качестве тела метода. Вот метод с именем isTruthy, реализующий Perl-определения true и false: def isTruthy(a: Any) = if a == 0 || a == \"\" || a == false then false else true Примеры показывают, как работает метод: isTruthy(0) // res6: Boolean = false isTruthy(\"\") // res7: Boolean = false isTruthy(\"hi\") // res8: Boolean = true isTruthy(1.0) // res9: Boolean = true Использование match в качестве тела метода Довольно часто в качестве тела метода используются match-выражения. Вот еще одна версия isTruthy, написанная с match выражением: def isTruthy(a: Matchable) = a match case 0 | \"\" | false =&gt; false case _ =&gt; true Этот метод работает точно так же, как и предыдущий, в котором использовалось выражение if/else. Вместо Any в качестве типа параметра используется Matchable, чтобы принять любое значение, поддерживающее сопоставление с образцом (pattern matching). Контроль видимости методов в классах В классах, объектах, trait-ах и enum-ах методы Scala по умолчанию общедоступны, поэтому созданный здесь экземпляр Dog может получить доступ к методу speak: class Dog: def speak() = println(\"Woof\") val d = new Dog // d: Dog = repl.MdocSession$App4$Dog@6b8b58c d.speak() // Woof Также методы можно помечать как private. Это делает их закрытыми в текущем классе, поэтому их нельзя вызвать или переопределить в подклассах: class Animal: private def breathe() = println(\"I’m breathing\") class Cat extends Animal: // this method won’t compile override def breathe() = println(\"Yo, I’m totally breathing\") Если необходимо сделать метод закрытым в текущем классе, но разрешить подклассам вызывать или переопределять его, метод помечается как protected, как показано в примере с методом speak: class Animal: private def breathe() = println(\"I’m breathing\") def walk() = breathe() println(\"I’m walking\") protected def speak() = println(\"Hello?\") class Cat extends Animal: override def speak() = println(\"Meow\") val cat = new Cat cat.walk() cat.speak() cat.breathe() // won’t compile because it’s private Настройка protected означает: к методу (или полю) могут обращаться другие экземпляры того же класса метод (или поле) не виден в текущем пакете он доступен для подклассов Методы в объектах Ранее было показано, что trait-ы и классы могут иметь методы. Ключевое слово object используется для создания одноэлементного класса, и object также может содержать методы. Это хороший способ сгруппировать набор “служебных” методов. Например, этот объект содержит набор методов, которые работают со строками: object StringUtils: def truncate(s: String, length: Int): String = s.take(length) def lettersAndNumbersOnly_?(s: String): Boolean = s.matches(\"[a-zA-Z0-9]+\") def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\") end StringUtils Вызов методов суперкласса Методы суперкласса можно вызвать через ключевое слово super., как показано в примере: class Animal: def speak() = println(\"Hello?\") class Cat extends Animal: override def speak() = super.speak() println(\"Meow\") val cat = new Cat // cat: Cat = repl.MdocSession$App11$Cat@1a58e10d cat.speak() // Hello? // Meow References: Scala3 book Scala3 book, Method Features"
    } ,    
    {
      "title": "Методы в коллекциях",
      "url": "/scalaworkbook/docs/collections/methods.html",
      "content": "Методы в коллекциях Важным преимуществом коллекций Scala является то, что они поставляются с десятками методов “из коробки”, которые доступны для неизменяемых и изменяемых типов коллекций. Больше нет необходимости писать пользовательские циклы for каждый раз, когда нужно работать с коллекцией. При переходе от одного проекта к другому, можно обнаружить, что используются одни и те же методы. В коллекциях доступны десятки методов, поэтому здесь показаны не все из них. Показаны только некоторые из наиболее часто используемых методов, в том числе: map filter foreach head tail take, takeWhile drop, dropWhile reduce Следующие методы работают со всеми типами последовательностей, включая List, Vector, ArrayBuffer и т. д.. Примеры рассмотрены на List-е, если не указано иное. Важно напомнить, что ни один из методов в List не изменяет список. Все они работают в функциональном стиле, то есть возвращают новую коллекцию с измененными результатами. Примеры распространенных методов Для общего представления в примерах ниже показаны некоторые из наиболее часто используемых методов коллекций. Вот несколько методов, которые не используют лямбда-выражения: val a = List(10, 20, 30, 40, 10) // a: List[Int] = List(10, 20, 30, 40, 10) a.distinct // res0: List[Int] = List(10, 20, 30, 40) a.drop(2) // res1: List[Int] = List(30, 40, 10) a.dropRight(2) // res2: List[Int] = List(10, 20, 30) a.head // res3: Int = 10 a.headOption // res4: Option[Int] = Some(value = 10) a.init // res5: List[Int] = List(10, 20, 30, 40) a.intersect(List(19,20,21)) // res6: List[Int] = List(20) a.last // res7: Int = 10 a.lastOption // res8: Option[Int] = Some(value = 10) a.slice(2,4) // res9: List[Int] = List(30, 40) a.tail // res10: List[Int] = List(20, 30, 40, 10) a.take(3) // res11: List[Int] = List(10, 20, 30) a.takeRight(2) // res12: List[Int] = List(40, 10) Функции высшего порядка и лямбда-выражения Далее будут показаны некоторые часто используемые функции высшего порядка (HOF), которые принимают лямбды (анонимные функции). Для начала приведем несколько вариантов лямбда-синтаксиса, начиная с самой длинной формы, поэтапно переходящей к наиболее сжатой: a.filter((i: Int) =&gt; i &lt; 25) // res13: List[Int] = List(10, 20, 10) a.filter((i) =&gt; i &lt; 25) // res14: List[Int] = List(10, 20, 10) a.filter(i =&gt; i &lt; 25) // res15: List[Int] = List(10, 20, 10) a.filter(_ &lt; 25) // res16: List[Int] = List(10, 20, 10) В этих примерах: Первый пример показывает самую длинную форму. Такое многословие требуется редко, только в самых сложных случаях. Компилятор знает, что a содержит Int, поэтому нет необходимости повторять это в функции. Если в функции только один параметр, например i, то скобки не нужны. В случае одного параметра, если он появляется в анонимной функции только раз, его можно заменить на _. В главе Анонимные функции представлена более подробная информация и примеры правил, связанных с сокращением лямбда-выражений. Примеры других HOF, использующих краткий лямбда-синтаксис: a.dropWhile(_ &lt; 25) // res17: List[Int] = List(30, 40, 10) a.filter(_ &gt; 35) // res18: List[Int] = List(40) a.filterNot(_ &lt; 25) // res19: List[Int] = List(30, 40) a.find(_ &gt; 20) // res20: Option[Int] = Some(value = 30) a.takeWhile(_ &lt; 30) // res21: List[Int] = List(10, 20) Важно отметить, что HOF также принимают в качестве параметров методы и функции, а не только лямбда-выражения. Вот несколько примеров, в которых используется метод с именем double. Снова показаны несколько вариантов лямбда-выражений: def double(i: Int) = i * 2 a.map(i =&gt; double(i)) // res22: List[Int] = List(20, 40, 60, 80, 20) a.map(double(_)) // res23: List[Int] = List(20, 40, 60, 80, 20) a.map(double) // res24: List[Int] = List(20, 40, 60, 80, 20) В последнем примере, когда анонимная функция состоит из одного вызова функции, принимающей один аргумент, нет необходимости указывать имя аргумента, поэтому даже _ не требуется. Наконец, HOF можно комбинировать: a.filter(_ &lt; 40) .takeWhile(_ &lt; 30) .map(_ * 10) // res25: List[Int] = List(100, 200) P.S. Пример призван показать только то, как принято последовательно вызывать функции на неизменяемых коллекциях. Его недостаток в том, что обход коллекции происходит целых три раза. Пример данных В следующих разделах используются следующие списки: val oneToTen = (1 to 10).toList // oneToTen: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val names = List(\"adam\", \"brandy\", \"chris\", \"david\") // names: List[String] = List(\"adam\", \"brandy\", \"chris\", \"david\") map Метод map проходит через каждый элемент в списке, применяя переданную функцию к элементу, по одному за раз; затем возвращается новый список с измененными элементами. Вот пример применения метода map к списку oneToTen: val doubles = oneToTen.map(_ * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) Также можно писать анонимные функции, используя более длинную форму, например: val doubles = oneToTen.map(i =&gt; i * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) Однако в этом документе будет всегда использоваться первая, более короткая форма. Вот еще несколько примеров применения метода map к oneToTen и names: val capNames = names.map(_.capitalize) // capNames: List[String] = List(\"Adam\", \"Brandy\", \"Chris\", \"David\") val nameLengthsMap = names.map(s =&gt; (s, s.length)).toMap // nameLengthsMap: Map[String, Int] = Map(\"adam\" -&gt; 4, \"brandy\" -&gt; 6, \"chris\" -&gt; 5, \"david\" -&gt; 5) val isLessThanFive = oneToTen.map(_ &lt; 5) // isLessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false) Как показано в последних двух примерах, совершенно законно (и распространено) использование map для возврата коллекции, которая имеет тип, отличный от исходного типа. filter Метод filter создает новый список, содержащий только те элементы, которые удовлетворяют предоставленному предикату. Предикат или условие — это функция, которая возвращает Boolean (true или false). Вот несколько примеров: val lessThanFive = oneToTen.filter(_ &lt; 5) // lessThanFive: List[Int] = List(1, 2, 3, 4) val evens = oneToTen.filter(_ % 2 == 0) // evens: List[Int] = List(2, 4, 6, 8, 10) val shortNames = names.filter(_.length &lt;= 4) // shortNames: List[String] = List(\"adam\") Отличительной особенностью функциональных методов коллекций является то, что их можно объединять вместе для решения задач. Например, в этом примере показано, как связать filter и map: oneToTen.filter(_ &lt; 4).map(_ * 10) // res26: List[Int] = List(10, 20, 30) Если filter используется перед map, flatMap или foreach, то для лучшей производительности он заменяется на withFilter, например, oneToTen.withFilter(_ &lt; 4).map(_ * 10) foreach Метод foreach используется для перебора всех элементов коллекции. Стоит обратить внимание, что foreach используется для побочных эффектов, таких как печать информации. Вот пример с names: names.foreach(println) // adam // brandy // chris // david head Метод head взят из Lisp и других более ранних языков функционального программирования. Он используется для доступа к первому элементу (головному (head) элементу) списка: oneToTen.head // res28: Int = 1 names.head // res29: String = \"adam\" String можно рассматривать как последовательность символов, т.е. строка также является коллекцией и имеет многие методы коллекций. Вот как head работает со строками: \"foo\".head // res30: Char = 'f' \"bar\".head // res31: Char = 'b' На пустой коллекции head выдает исключение: val emptyList = List[Int]() // emptyList: List[Int] = List() emptyList.head // java.util.NoSuchElementException: head of empty list // at scala.collection.immutable.Nil$.head(List.scala:662) // at scala.collection.immutable.Nil$.head(List.scala:661) // at repl.MdocSession$App.$init$$$anonfun$17(methods.md:252) Чтобы не натыкаться на исключение вместо head желательно использовать headOption, особенно при разработке в функциональном стиле: emptyList.headOption // res32: Option[Int] = None headOption не генерирует исключение, а возвращает тип Option со значением None. Более подробно о функциональном стиле программирования будет рассказано в соответствующей главе. tail Метод tail также взят из Lisp и используется для вывода всех элементов в списке после head. oneToTen.head // res33: Int = 1 oneToTen.tail // res34: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10) names.head // res35: String = \"adam\" names.tail // res36: List[String] = List(\"brandy\", \"chris\", \"david\") Так же, как и head, tail можно использовать со строками: \"foo\".tail // res37: String = \"oo\" \"bar\".tail // res38: String = \"ar\" tail выбрасывает исключение java.lang.UnsupportedOperationException, если список пуст, поэтому, как и в случае с head и headOption, существует также метод tailOption, который предпочтительнее в функциональном программировании. Список матчится, поэтому можно использовать такие выражения: val x :: xs = names // x: String = \"adam\" // xs: List[String] = List(\"brandy\", \"chris\", \"david\") x - это head списка, а xs - tail. Подобный pattern matching полезен во многих случаях, например, при написании метода суммирования с использованием рекурсии: def sum(list: List[Int]): Int = list match case Nil =&gt; 0 case x :: xs =&gt; x + sum(xs) take, takeRight, takeWhile Методы take, takeRight и takeWhile предоставляют удобный способ “брать” (take) элементы из списка для создания нового. Примеры take и takeRight: oneToTen.take(1) // res39: List[Int] = List(1) oneToTen.take(2) // res40: List[Int] = List(1, 2) oneToTen.takeRight(1) // res41: List[Int] = List(10) oneToTen.takeRight(2) // res42: List[Int] = List(9, 10) Обратите внимание, как эти методы работают с «пограничными» случаями, когда запрашивается больше элементов, чем есть в последовательности, или запрашивается ноль элементов: oneToTen.take(Int.MaxValue) // res43: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.takeRight(Int.MaxValue) // res44: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.take(0) // res45: List[Int] = List() oneToTen.takeRight(0) // res46: List[Int] = List() А это takeWhile, который работает с функцией-предикатом: oneToTen.takeWhile(_ &lt; 5) // res47: List[Int] = List(1, 2, 3, 4) names.takeWhile(_.length &lt; 5) // res48: List[String] = List(\"adam\") drop, dropRight, dropWhile drop, dropRight и dropWhile удаляют элементы из списка и, по сути, противоположны своим аналогам “take”. Вот некоторые примеры: oneToTen.drop(1) // res49: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.drop(5) // res50: List[Int] = List(6, 7, 8, 9, 10) oneToTen.dropRight(8) // res51: List[Int] = List(1, 2) oneToTen.dropRight(7) // res52: List[Int] = List(1, 2, 3) Пограничные случаи: oneToTen.drop(Int.MaxValue) // res53: List[Int] = List() oneToTen.dropRight(Int.MaxValue) // res54: List[Int] = List() oneToTen.drop(0) // res55: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.dropRight(0) // res56: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) А это dropWhile, который работает с функцией-предикатом: oneToTen.dropWhile(_ &lt; 5) // res57: List[Int] = List(5, 6, 7, 8, 9, 10) names.dropWhile(_ != \"chris\") // res58: List[String] = List(\"chris\", \"david\") reduce Метод reduce позволяет свертывать коллекцию до одного агрегируемого значения. Он принимает функцию (или анонимную функцию) и последовательно применяет эту функцию к элементам в списке. Лучший способ объяснить reduce — создать небольшой вспомогательный метод. Например, метод add, который складывает вместе два целых числа, а также предоставляет хороший вывод отладочной информации: def add(x: Int, y: Int): Int = val theSum = x + y println(s\"received $x and $y, their sum is $theSum\") theSum Рассмотрим список: val a = List(1,2,3,4) вот что происходит, когда в reduce передается метод add: a.reduce(add) // received 1 and 2, their sum is 3 // received 3 and 3, their sum is 6 // received 6 and 4, their sum is 10 // res59: Int = 10 Как видно из результата, функция reduce использует add для сокращения списка a до единственного значения, в данном случае — суммы всех чисел в списке. reduce можно использовать с анонимными функциями: a.reduce(_ + _) // res60: Int = 10 Аналогично можно использовать другие функции, например, перемножение всех чисел: a.reduce(_ * _) // res61: Int = 24 Дальнейшее изучение коллекций В коллекциях Scala есть десятки дополнительных методов, которые избавят от необходимости писать еще один цикл for. Более подробную информацию о коллекциях Scala см. в разделе Изменяемые и неизменяемые коллекции и Архитектура коллекций Scala. А также в API. В качестве последнего примечания, при использовании Java-кода в проекте Scala, коллекции Java можно преобразовать в коллекции Scala. После этого, их можно использовать в выражениях for, а также воспользоваться преимуществами методов функциональных коллекций Scala. Более подробную информацию можно найти в разделе Взаимодействие с Java. References: Scala3 book Scala3 book, Collections Methods Изменяемые и неизменяемые коллекции Архитектура коллекций Scala collections API"
    } ,    
    {
      "title": "Методы",
      "url": "/scalaworkbook/docs/methods.html",
      "content": "Методы Scala classes, case classes, case objects, traits, enums, и objects могут содержать методы. Кроме того, они могут быть определены вне любой из перечисленных конструкций. Методы являются определениями “верхнего уровня”, поскольку не вложены в другое определение. Проще говоря, методы теперь могут быть определены где угодно. В Scala методы обладают множеством особенностей, в том числе: Несколько групп параметров (partially-applied functions) Методы с неопределенным количеством параметров (vararg parameters) Параметры по имени (by-name parameters) Функция в качестве параметра Generic параметры Значения параметров по умолчанию Контекстные параметры inline методы и многое другое References: Scala3 book"
    } ,    
    {
      "title": "Моделирование данных",
      "url": "/scalaworkbook/docs/modeling.html",
      "content": "Моделирование данных В этой главе показано моделирование данных с помощью Scala 3: Конструкции для моделирования: Классы (Classes) Объекты (Objects) Сопутствующие объекты (Companion objects) Трейты (Traits) Абстрактные классы (Abstract classes) Перечисления (Enums) Case classes и Case objects в разделе “Моделирование ООП” рассматриваются атрибуты и поведение моделирования в стиле объектно-ориентированного программирования (ООП) в разделе “Моделирование ФП” рассматривается моделирование предметной области в стиле функционального программирования (ФП) References: Scala3 book"
    } ,    
    {
      "title": "Monad",
      "url": "/scalaworkbook/typeclass/monad/monad.html",
      "content": "Monad Монада (monad) - это Functor и Applicative с дополнительной функцией: flatten (сведение: F[F[A]] -&gt; F[A]). Что позволяет определить flatMap — map, за которой следует flatten. Для Monad должны соблюдаться следующие законы: identities: flatMap(apply(x))(fn) == fn(x) flatMap(m)(apply _) == m associativity на flatMap: flatMap(flatMap(m)(f))(g) == flatMap(m) { x =&gt; flatMap(f(x))(g) } Примеры монад Реализации монад в различных библиотеках References: Tour of Scala Algebird"
    } ,    
    {
      "title": "Monad's group",
      "url": "/scalaworkbook/typeclass/monad.html",
      "content": "Monad’s group References:"
    } ,    
    {
      "title": "Monoid",
      "url": "/scalaworkbook/typeclass/monoid/monoid.html",
      "content": "Monoid Моноид (monoid) — это полугруппа с единичным элементом. Более формально: (M, +) является моноидом для заданного множества M и операции +, если удовлетворяет следующим свойствам для любых x, y, z ∈ M: Closure (замыкание): x + y ∈ M Associativity (ассоциативность): (x + y) + z = x + (y + z) Identity (тождественность): существует e ∈ M такое, что e + x = x + e = x Также говорится, что M — моноид относительно +. Примеры моноидов Натуральные числа N являются моноидами относительно сложения (0 является identity элементом) N являются моноидами относительно умножения (1 является identity элементом) Строки образуют моноид относительно конкатенации (\"\" является identity элементом) Реализации моноидов в различных библиотеках References: Algebird"
    } ,    
    {
      "title": "Monoid's group",
      "url": "/scalaworkbook/typeclass/monoid.html",
      "content": "Monoid’s group References:"
    } ,    
    {
      "title": "Именованные параметры",
      "url": "/scalaworkbook/docs/methods/named-parameters.html",
      "content": "Именованные параметры При вызове метода при желании можно использовать имена параметров. Например, makeConnection также можно вызывать следующими способами: def makeConnection(timeout: Int = 5_000, protocol: String = \"http\") = println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\") makeConnection(timeout=10_000) // timeout = 10000, protocol = http makeConnection(protocol=\"https\") // timeout = 5000, protocol = https makeConnection(timeout=10_000, protocol=\"https\") // timeout = 10000, protocol = https makeConnection(protocol=\"https\", timeout=10_000) // timeout = 10000, protocol = https Именованные параметры особенно полезны, когда несколько параметров метода имеют один и тот же тип. Без помощи IDE очень сложно понять, какие параметры установлены в значение true или false, и поэтому код может быть трудночитаемым: engage(true, true, true, false) Гораздо более понятным выглядит использование именованных переменных: engage( speedIsSet = true, directionIsSet = true, picardSaidMakeItSo = true, turnedOffParkingBrake = false ) References: Scala3 book, Method Features"
    } ,    
    {
      "title": "Next",
      "url": "/scalaworkbook/fp/next.html",
      "content": "Next References: Type classes in Scalaz Type classes in Cats Type classes in Algebird"
    } ,    
    {
      "title": "Objects",
      "url": "/scalaworkbook/docs/modeling/objects.html",
      "content": "Objects В Scala ключевое слово object создает одноэлементный объект (singleton). Другими словами, объект определяет класс, который имеет ровно один экземпляр. Он инициализируется лениво, когда ссылаются на его элементы, аналогично lazy val. Объекты в Scala позволяют группировать методы и поля в одном пространстве имен, аналогично тому, как используются статические члены класса в Java, Javascript (ES6) или @staticmethod в Python. Объекты имеют несколько применений: Они используются для создания коллекций служебных методов. companion object - это объект, имеющий то же имя, что и класс, с которым он совместно использует файл. В этой ситуации класс называется companion class. Они используются для имплементации traits для создания модулей. Объявление объекта аналогично объявлению класса. Вот пример объекта StringUtils, который содержит набор методов для работы со строками: object StringUtils: def truncate(s: String, length: Int): String = s.take(length) def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\") def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty Поскольку StringUtils является одноэлементным, его методы могут вызываться непосредственно в объекте: StringUtils.truncate(\"Chuck Bartowski\", 5) // res0: String = \"Chuck\" Импорт в Scala очень гибкий и позволяет импортировать все члены объекта: import StringUtils.* truncate(\"Chuck Bartowski\", 5) // res1: String = \"Chuck\" containsWhitespace(\"Sarah Walker\") // res2: Boolean = true isNullOrEmpty(\"John Casey\") // res3: Boolean = false Можно импортировать только часть методов: import StringUtils.{truncate, containsWhitespace} truncate(\"Charles Carmichael\", 7) containsWhitespace(\"Captain Awesome\") isNullOrEmpty(\"Morgan Grimes\") // Not found: isNullOrEmpty (error) Объекты также могут иметь поля, к которым можно обратиться, как к статистическим методам: object MathConstants: val PI = 3.14159 val E = 2.71828 println(MathConstants.PI) // 3.14159 References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Моделирование ООП",
      "url": "/scalaworkbook/docs/modeling/oop.html",
      "content": "Моделирование ООП Введение Scala предоставляет все необходимые инструменты для объектно-ориентированного проектирования: Traits позволяют указывать (абстрактные) интерфейсы, а также конкретные реализации. Mixin Composition предоставляет инструменты для создания компонентов из более мелких деталей. Классы могут реализовывать интерфейсы, заданные traits. Экземпляры классов могут иметь свое собственное приватное состояние. Subtyping позволяет использовать экземпляр одного класса там, где ожидается экземпляр его суперкласса. Модификаторы доступа позволяют управлять, к каким членам класса можно получить доступ с помощью какой части кода. Traits Возможно, в отличие от других языков программирования с поддержкой ООП таких, как Java, основным инструментом декомпозиции в Scala являются не классы, а traits. Они могут служить для описания абстрактных интерфейсов, таких как: trait Showable: def show: String , а также могут содержать конкретные реализации: trait Showable: def show: String def showHtml = \"&lt;p&gt;\" + show + \"&lt;/p&gt;\" На примере видно, что метод showHtml определяется в терминах абстрактного метода show. Odersky и Zenger представляют сервис-ориентированную компонентную модель и рассматривают: абстрактные члены как требуемые службы: их все еще необходимо реализовать в подклассе. конкретные члены как предоставляемые услуги: они предоставляются подклассу. Это видно на примере со Showable: определяя класс Document, который расширяет Showable, все еще нужно определить show, но showHtml уже предоставляется: class Document(text: String) extends Showable: def show = text Абстрактные методы Абстрактными в trait могут оставаться не только методы. trait может содержать: абстрактные методы (def m(): T) абстрактные переменные (val x: T) абстрактные типы (type T), потенциально с ограничениями (type T &lt;: S) абстрактные given (given t: T) - подробнее об given в следующих главах Каждая из вышеперечисленных функций может быть использована для определения той или иной формы требований к реализатору trait. Mixin Composition Кроме того, что trait-ы могут содержать абстрактные и конкретные определения, Scala также предоставляет мощный способ создания нескольких trait: структура, которую часто называют смешанной композицией. Предположим, что следующие два (потенциально независимо определенные) trait-а: trait GreetingService: def translate(text: String): String def sayHello = translate(\"Hello\") trait TranslationService: def translate(text: String): String = \"...\" Чтобы скомпоновать два сервиса, можно просто создать новый trait, расширяющий их: trait ComposedService extends GreetingService, TranslationService Абстрактные элементы в одном trait-е (например, translate в GreetingService) автоматически сопоставляются с конкретными элементами в другом trait-е. Это работает не только с методами, как в этом примере, но и со всеми другими абстрактными членами, упомянутыми выше (то есть типами, переменными и т.д.). Классы trait-ы отлично подходят для модуляции компонентов и описания интерфейсов (обязательных и предоставляемых). Но в какой-то момент возникнет необходимость создавать их экземпляры. При разработке программного обеспечения в Scala часто бывает полезно рассмотреть возможность использования классов только на начальных этапах модели наследования: Traits - T1, T2, T3 Composed traits - S extends T1, T2, S extends T2, T3 Classes - C extends S, T3 Instances - C() Это еще более актуально в Scala 3, где trait-ы теперь также могут принимать параметры конструктора, что еще больше устраняет необходимость в классах. Определение класса Подобно trait-ам, классы могут расширять несколько trait-ов (но только один суперкласс): class MyService(name: String) extends ComposedService, Showable: def show = s\"$name says $sayHello\" Subtyping Экземпляр MyService создается следующим образом: val s1: MyService = MyService(\"Service 1\") С помощью подтипов экземпляр s1 можно использовать везде, где ожидается любое из расширенных свойств: val s2: GreetingService = s1 val s3: TranslationService = s1 val s4: Showable = s1 // ... и т.п. ... Планирование расширения Как упоминалось ранее, можно расширить еще один класс: class Person(name: String) class SoftwareDeveloper(name: String, favoriteLang: String) extends Person(name) Однако, поскольку trait-ы разработаны как основное средство декомпозиции, класс, определенный в одном файле, не может быть расширен в другом файле. Чтобы разрешить это, базовый класс должен быть помечен как открытый: open class Person(name: String) Маркировка классов с помощью open - это новая функция Scala 3. Необходимость явно помечать классы как открытые позволяет избежать многих распространенных ошибок в ООП. В частности, это требует, чтобы разработчики библиотек явно планировали расширение и, например, документировали классы, помеченные как открытые. Пример: // File Writer.scala package p open class Writer[T]: /** Sends to stdout, can be overridden */ def send(x: T) = println(x) /** Sends all arguments using `send` */ def sendAll(xs: T*) = xs.foreach(send) end Writer // File EncryptedWriter.scala package p class EncryptedWriter[T: Encryptable] extends Writer[T]: override def send(x: T) = super.send(encrypt(x)) Открытый класс обычно поставляется с некоторой документацией, описывающей внутренние шаблоны вызовов между методами класса, а также хуки, которые можно переопределить. Это называется контрактом расширения класса (extension contract). Он отличается от внешнего контракта (external contract) между классом и его пользователями. Классы без модификатора open все же могут быть расширены, но только при соблюдении хотя бы одного из двух альтернативных условий: Расширяющий класс находится в том же исходном файле, что и расширенный класс. В этом случае расширение обычно является внутренним вопросом реализации. Для класса расширения включена языковая функция adhocExtensions. Обычно она включается предложением импорта в исходном файле расширения: import scala.language.adhocExtensions Кроме того, эту функцию можно включить с помощью опции компилятора -language:adhocExtensions. Если эта функция не включена, компилятор выдаст “feature” warning. Подробности об open классах. Экземпляры и приватное изменяемое состояние Как и в других языках с поддержкой ООП, trait-ы и классы в Scala могут определять изменяемые поля: class Counter: private var currentCount = 0 def tick(): Unit = currentCount += 1 def count: Int = currentCount Каждый экземпляр класса Counter имеет собственное приватное состояние, которое можно наблюдать только через метод count, как показано в следующем примере: val c1 = Counter() c1.count // res1: Int = 0 c1.tick() c1.tick() c1.count // res4: Int = 2 Модификаторы доступа По умолчанию все определения элементов в Scala являются общедоступными. Чтобы скрыть детали реализации, можно определить элементы (методы, поля, типы и т.д.) как private или protected. Таким образом можно контролировать, как к ним обращаются или как их переопределяют. Закрытые (private) члены видны только самому классу/trait-у и его сопутствующему объекту. Защищенные (protected) члены также видны подклассам класса. Дополнительный пример: сервис-ориентированный дизайн Далее будут проиллюстрированы некоторые расширенные возможности Scala и показано, как их можно использовать для структурирования более крупных программных компонентов. Примеры взяты из статьи Мартина Одерски и Маттиаса Зенгера Масштабируемые компонентные абстракции. Пример в первую очередь предназначен для демонстрации того, как использовать несколько функций типа для создания более крупных компонентов. Цель состоит в том, чтобы определить программный компонент с семейством типов, которые могут быть уточнены позже при реализации компонента. Конкретно, следующий код определяет компонент SubjectObserver как trait с двумя членами абстрактного типа, S (для субъектов) и O (для наблюдателей): trait SubjectObserver: type S &lt;: Subject type O &lt;: Observer trait Subject { self: S =&gt; private var observers: List[O] = List() def subscribe(obs: O): Unit = observers = obs :: observers def publish() = for obs &lt;- observers do obs.notify(this) } trait Observer { def notify(sub: S): Unit } Есть несколько вещей, которые нуждаются в объяснении. Члены абстрактного типа Тип объявления S &lt;: Subject говорит, что внутри trait SubjectObserver можно ссылаться на некоторый неизвестный (то есть абстрактный) тип, который называется S. Однако этот тип не является полностью неизвестным: мы знаем, по крайней мере, что это какой-то подтип Subject. Все trait-ы и классы, расширяющие SubjectObserver, могут свободно выбирать любой тип для S, если выбранный тип является подтипом Subject. Часть &lt;: Subject декларации также упоминается как верхняя граница на S. Вложенные trait-ы В рамках trait-а SubjectObserver определяются два других trait-а. trait Observer, который определяет только один абстрактный метод notify с одним аргументом типа S. Как будет видно, важно, чтобы аргумент имел тип S, а не тип Subject. Второй trait, Subject, определяет одно приватное поле observers для хранения всех наблюдателей, подписавшихся на этот конкретный объект. Подписка на объект просто сохраняет объект в списке. Опять же, тип параметра obs - это O, а не Observer. Аннотации собственного типа Наконец, что означает self: S =&gt; в trait-е Subject? Это называется аннотацией собственного типа. И требует, чтобы подтипы Subject также были подтипами S. Это необходимо, чтобы иметь возможность вызывать obs.notify с this в качестве аргумента, поскольку для этого требуется значение типа S. Если бы S был конкретным типом, аннотацию собственного типа можно было бы заменить на trait Subject, расширяющий S. Реализация компонента Теперь можно реализовать вышеуказанный компонент и определить члены абстрактного типа как конкретные типы: object SensorReader extends SubjectObserver: type S = Sensor type O = Display class Sensor(val label: String) extends Subject: private var currentValue = 0.0 def value = currentValue def changeValue(v: Double) = currentValue = v publish() class Display extends Observer: def notify(sub: Sensor) = println(s\"${sub.label} has value ${sub.value}\") В частности, мы определяем singleton object SensorReader, который расширяет SubjectObserver. В реализации SensorReader говорится, что type S теперь определяется как type Sensor, а type O определяется как type Display. И Sensor, и Display определяются как вложенные классы в SensorReader, реализующие trait-ы Subject и Observer соответственно. Помимо того, что этот код является примером сервис-ориентированного дизайна, он также освещает многие аспекты объектно-ориентированного программирования: Класс Sensor вводит свое собственное частное состояние (currentValue) и инкапсулирует изменение состояния за методом changeValue. Реализация changeValue использует метод publish, определенный в родительском trait-е. Класс Display расширяет trait Observer и реализует отсутствующий метод notify. Важно отметить, что реализация notify может безопасно получить доступ только к label и value sub, поскольку мы изначально объявили параметр типа S. Использование компонента Наконец, следующий код иллюстрирует, как использовать компонент SensorReader: import SensorReader.* // настройка сети val s1 = Sensor(\"sensor1\") val s2 = Sensor(\"sensor2\") val d1 = Display() val d2 = Display() s1.subscribe(d1) s1.subscribe(d2) s2.subscribe(d1) // распространение обновлений по сети s1.changeValue(2) // sensor1 has value 2.0 // sensor1 has value 2.0 s2.changeValue(3) // sensor2 has value 3.0 Имея под рукой все утилиты объектно-ориентированного программирования, в следующем разделе будет продемонстрировано, как разрабатывать программы в функциональном стиле. References: Scala3 book, domain modeling oop Scala3 book, taste modeling Scala3 book, taste objects Odersky and Zenger. Scalable component abstractions Scala 3 Reference, Open classes"
    } ,    
    {
      "title": "Пакеты и импорт",
      "url": "/scalaworkbook/docs/packaging.html",
      "content": "Пакеты и импорт Scala использует packages для создания пространств имен, которые позволяют модульно разбивать программы. Scala поддерживает стиль именования пакетов, используемый в Java, а также нотацию пространства имен “фигурные скобки”, используемую такими языками, как C++ и C#. Подход Scala к импорту похож на Java, но более гибкий. С помощью Scala можно: импортировать пакеты, классы, объекты, trait-ы и методы размещать операторы импорта в любом месте скрывать и переименовывать участников при импорте Эти особенности демонстрируются в следующих примерах. Создание пакета Пакеты создаются путем объявления одного или нескольких имен пакетов в начале файла Scala. Например, если ваше доменное имя acme.com и вы работаете с пакетом model приложения с именем myapp, объявление пакета выглядит следующим образом: package com.acme.myapp.model class Person ... По соглашению все имена пакетов должны быть строчными, а формальным соглашением об именах является &lt;top-level-domain&gt;.&lt;domain-name&gt;.&lt;project-name&gt;.&lt;module-name&gt;. Хотя это и не обязательно, имена пакетов обычно совпадают с именами иерархии каталогов. Поэтому, если следовать этому соглашению, класс Person в этом проекте будет найден в файле MyApp/src/main/scala/com/acme/myapp/model/Person.scala. Использование нескольких пакетов в одном файле Показанный выше синтаксис применяется ко всему исходному файлу: все определения в файле Person.scala принадлежат пакету com.acme.myapp.model в соответствии с package в начале файла. В качестве альтернативы можно написать package, которые применяются только к содержащимся в них определениям: package users: package administrators: // полное имя пакета - users.administrators class AdminUser // полное имя файла - users.administrators.AdminUser package normalusers: // полное имя пакета - users.normalusers class NormalUser // полное имя файла - users.normalusers.NormalUser Обратите внимание, что за именами пакетов следует двоеточие, а определения внутри пакета имеют отступ. Преимущество этого подхода заключается в том, что он допускает вложение пакетов и обеспечивает более очевидный контроль над областью действия и инкапсуляцией, особенно в пределах одного файла. Операторы импорта Операторы импорта используются для доступа к сущностям в других пакетах. Операторы импорта делятся на две основные категории: импорт классов, trait-ов, объектов, функций и методов импорт given предложений Первая категория операторов импорта аналогична тому, что использует Java, с немного другим синтаксисом, обеспечивающим большую гибкость. Пример: import users.* // импортируется все из пакета `users` import users.User // импортируется только класс `User` import users.{User, UserPreferences} // импортируются только два члена пакета import users.{UserPreferences as UPrefs} // переименование импортированного члена Эти примеры предназначены для того, чтобы дать представление о том, как работает первая категория операторов import. Более подробно они объясняются в следующих подразделах. Операторы импорта также используются для импорта given экземпляров в область видимости. Они обсуждаются в конце этой главы. import не требуется для доступа к членам одного и того же пакета. Импорт одного или нескольких членов В Scala импортировать один элемент из пакета можно следующим образом: import scala.concurrent.Future несколько: import scala.concurrent.Future import scala.concurrent.Promise import scala.concurrent.blocking При импорте нескольких элементов можно импортировать их более лаконично: import scala.concurrent.{Future, Promise, blocking} Если необходимо импортировать все из пакета scala.concurrent, используется такой синтаксис: import scala.concurrent.* Переименование элементов при импорте Иногда необходимо переименовать объекты при их импорте, чтобы избежать конфликтов имен. Например, если нужно использовать Scala класс List вместе с java.util.List, то можно переименовать java.util.List при импорте: import java.util.{List as JavaList} Теперь имя JavaList можно использовать для ссылки на класс java.util.List и использовать List для ссылки на Scala класс List. Также можно переименовывать несколько элементов одновременно, используя следующий синтаксис: import java.util.{Date as JDate, HashMap as JHashMap, *} В этой строке кода говорится следующее: “Переименуйте классы Date и HashMap, как показано, и импортируйте все остальное из пакета java.util, не переименовывая”. Скрытие членов при импорте При импорте часть объектов можно скрывать. Следующий оператор импорта скрывает класс java.util.Random, в то время как все остальное в пакете java.util импортируется: import java.util.{Random as _, *} Если попытаться получить доступ к классу Random, то выдается ошибка, но есть доступ ко всем остальным членам пакета java.util: val r = new Random // не скомпилируется new ArrayList // доступ есть Скрытие нескольких элементов Чтобы скрыть в import несколько элементов, их можно перечислить перед использованием *: import java.util.{List as _, Map as _, Set as _, *} Перечисленные классы скрыты, но можно использовать все остальное в java.util: val arr = new ArrayList[String] // arr: ArrayList[String] = [] Поскольку эти Java классы скрыты, можно использовать классы Scala List, Set и Map без конфликта имен: val a = List(1, 2, 3) // a: List[Int] = List(1, 2, 3) val b = Set(1, 2, 3) // b: Set[Int] = Set(1, 2, 3) val c = Map(1 -&gt; 1, 2 -&gt; 2) // c: Map[Int, Int] = Map(1 -&gt; 1, 2 -&gt; 2) Импорт можно использовать в любом месте В Scala операторы импорта могут быть объявлены где угодно. Их можно использовать в верхней части файла исходного кода: package foo import scala.util.Random class ClassA: def printRandom: val r = new Random // класс Random здесь доступен // ещё код... Также операторы импорта можно использовать ближе к тому месту, где они необходимы: package foo class ClassA: import scala.util.Random // внутри ClassA def printRandom { val r = new Random // ещё код... class ClassB: // класс Random здесь невидим val r = new Random // этот код не скомпилится “Статический” импорт Если необходимо импортировать элементы способом, аналогичным подходу «статического импорта» в Java, то есть для того, чтобы напрямую обращаться к членам класса, не добавляя к ним префикс с именем класса, используется следующий подход. Синтаксис для импорта всех статических членов Java класса Math: import java.lang.Math.* Теперь можно получить доступ к статическим методам класса Math, таким как sin и cos, без необходимости предварять их именем класса: import java.lang.Math.* val a = sin(0) // a: Double = 0.0 val b = cos(PI) // b: Double = -1.0 Пакеты, импортированные по умолчанию Два пакета неявно импортируются во все файлы исходного кода: java.lang.* scala.* Члены object Predef также импортируются по умолчанию. Например, такие классы, как List, Vector, Map и т. д. можно использовать явно, не импортируя их - они доступны, потому что определены в object Predef Обработка конфликтов имен Если необходимо импортировать что-то из корня проекта и возникает конфликт имен, достаточно просто добавить к имени пакета префикс _root_: package accounts import _root_.accounts.* Импорт given Как будет показано в главе “Контекстные абстракции”, для импорта экземпляров given используется специальная форма оператора import. Базовая форма показана в этом примере: object A: class TC given tc as TC def f(using TC) = ??? object B: import A.* // import all non-given members import A.given // import the given instance В этом коде предложение import A.* объекта B импортирует все элементы A, кроме given экземпляра tc. И наоборот, второй импорт, import A.given, импортирует только given экземпляр. Два предложения импорта также могут быть объединены в одно: object B: import A.{given, *} Селектор с подстановочным знаком * помещает в область видимости все определения, кроме given, тогда как селектор выше помещает в область действия все данные, включая те, которые являются результатом расширений. Эти правила имеют два основных преимущества: более понятно, откуда берутся данные given. В частности, невозможно скрыть импортированные given в длинном списке других импортируемых подстановочных знаков. есть возможность импортировать все given, не импортируя ничего другого. Это особенно важно, поскольку given могут быть анонимными, поэтому обычное использование именованного импорта нецелесообразно. Импорт по типу Поскольку given-ы могут быть анонимными, не всегда практично импортировать их по имени, и вместо этого обычно используется импорт подстановочных знаков. Импорт по типу предоставляет собой более конкретную альтернативу импорту с подстановочными знаками, делая понятным то, что импортируется. Этот код импортирует из A любой given тип, соответствующий TC: import A.{given TC} Если импортируется только один given, то фигурные скобки можно опустить: import A.given TC Импорт данных нескольких типов T1,...,Tn выражается несколькими given селекторами: import A.{given T1, ..., given Tn} Импорт всех given экземпляров параметризованного типа достигается аргументами с подстановочными знаками. Например, есть такой объект: object Instances: given intOrd as Ordering[Int] given listOrd[T: Ordering] as Ordering[List[T]] given ec as ExecutionContext = ... given im as Monoid[Int] Оператор import ниже импортирует экземпляры intOrd, listOrd и ec, но пропускает экземпляр im, поскольку он не соответствует ни одному из указанных шаблонов: import Instances.{given Ordering[?], given ExecutionContext} Импорт по типу можно смешивать с импортом по имени. Если оба присутствуют в предложении import, импорт по типу идет последним. Например, это предложение импорта импортирует im, intOrd и listOrd, но не включает ec: import Instances.{im, given Ordering[?]} Пример В качестве конкретного примера представим, что у нас есть объект MonthConversions, который содержит два определения given: object MonthConversions: trait MonthConverter[A]: def convert(a: A): String given intMonthConverter: MonthConverter[Int] with def convert(i: Int): String = i match case 1 =&gt; \"January\" case 2 =&gt; \"February\" case _ =&gt; \"Other\" given stringMonthConverter: MonthConverter[String] with def convert(s: String): String = s match case \"jan\" =&gt; \"January\" case \"feb\" =&gt; \"February\" case _ =&gt; \"Other\" Чтобы импортировать эти given-ы в текущую область, используем два оператора import: import MonthConversions.* import MonthConversions.given MonthConverter[?] Теперь создаем метод, использующий эти экземпляры: def genericMonthConverter[A](a: A)(using monthConverter: MonthConverter[A]): String = monthConverter.convert(a) Вызов метода: genericMonthConverter(1) // res1: String = \"January\" genericMonthConverter(\"jan\") // res2: String = \"January\" Как уже упоминалось ранее, одно из ключевых преимуществ синтаксиса “import given” состоит в том, чтобы прояснить, откуда берутся данные в области действия, и в import операторах выше ясно, что данные поступают из объекта MonthConversions. References: Scala3 book"
    } ,    
    {
      "title": "Распаковка параметров",
      "url": "/scalaworkbook/docs/details/parameter-untupling.html",
      "content": "Распаковка параметров Допустим есть список кортежей, например: val xs: List[(Int, Int)] = List((1, 2), (3, 4)) и необходимо изменить xs в List[Int], чтобы каждая пара чисел была сопоставлена с их суммой. Ранее лучший способ сделать это - с помощью декомпозиции сопоставления с образцом: xs map { case (x, y) =&gt; x + y } Хотя это правильно, это также неудобно и сбивает с толку, поскольку case предполагает, что сопоставление с образцом может завершиться ошибкой. Как более короткая и понятная альтернатива, Scala 3 теперь позволяет xs.map { (x, y) =&gt; x + y } // res0: List[Int] = List(3, 7) или, что то же самое: xs.map(_ + _) // res1: List[Int] = List(3, 7) а также def combine(i: Int, j: Int) = i + j xs.map(combine) // res2: List[Int] = List(3, 7) Как правило, значение функции с n &gt; 1 параметрами упаковывается в функциональный тип формы ((T_1, ..., T_n)) =&gt; U, если это ожидаемый тип. Параметр кортежа декомпозируется, и его элементы передаются непосредственно базовой функции. Более конкретно, адаптация применяется к несовпадающему списку формальных параметров. В частности, адаптация не является преобразованием между типами функций. Поэтому не принимается: val combiner: (Int, Int) =&gt; Int = _ + _ xs.map(combiner) // error: // Found: (repl.MdocSession.App.combiner : (Int, Int) =&gt; Int) // Required: ((Int, Int)) =&gt; Nothing // xs.map(combiner) // ^^^^^^^^ Значение функции должно быть явно сложены: xs.map(combiner.tupled) // res4: List[Int] = List(3, 7) Преобразование может быть предусмотрено в пользовательском коде: import scala.language.implicitConversions transparent inline implicit def `fallback untupling`(f: (Int, Int) =&gt; Int): ((Int, Int)) =&gt; Int = p =&gt; f(p._1, p._2) // use specialized apply instead of unspecialized `tupled` xs.map(combiner) Попытка распаковки параметров предпринимается до применения преобразований, поэтому преобразование области действия не может нарушить распаковку. References: Scala 3 Reference Scala 3 Reference - Details"
    } ,    
    {
      "title": "Каррирование",
      "url": "/scalaworkbook/docs/methods/partially-applied-functions.html",
      "content": "Каррирование В методе можно указывать несколько групп параметров. При указании только части групп параметров возвращается частично определенная функция. Пример: def sum(a: Int)(b: Int): Int = a + b def add2(b: Int): Int = sum(2)(b) sum(42)(42) // res0: Int = 84 add2(42) // res1: Int = 44 References: Scala3 book, Method Features"
    } ,    
    {
      "title": "Экстракторы",
      "url": "/scalaworkbook/docs/details/pattern-matching.html",
      "content": "Сопоставление с образцом Экстракторы Экстракторы — это объекты, которые предоставляют метод unapply или unapplySeq: def unapply[A](x: T)(implicit x: B): U def unapplySeq[A](x: T)(implicit x: B): U Экстракторы, предоставляющие метод unapply, называются экстракторами с фиксированной арностью. Экстракторы, предоставляющие метод unapplySeq, называются экстракторами с переменным числом параметров. Экстракторы с фиксированной арностью Экстракторы с фиксированной арностью предоставляют следующую подпись: def unapply[A](x: T)(implicit x: B): U Тип U соответствует одному из следующих совпадений: Логическое совпадение Соответствие продукта Или U соответствует типу R: type R = { def isEmpty: Boolean def get: S } и S соответствует одному из следующих совпадений: одно совпадение совпадение по имени Первая форма unapply имеет более высокий приоритет, а одиночное совпадение имеет более высокий приоритет, чем сопоставление на основе имени. Использование экстрактора с фиксированной арностью применяется, если выполняется одно из следующих условий: U = true экстрактор используется в качестве соответствия продукта U = Some[T] (для совместимости со Scala 2) U &lt;: R, а также U &lt;: { def isEmpty: false } Логическое совпадение Пример: object Even: def unapply(s: String): Boolean = s.size % 2 == 0 \"even\" match case s @ Even() =&gt; println(s\"$s has an even number of characters\") case s =&gt; println(s\"$s has an odd number of characters\") // even has an even number of characters Соответствие продукта Пример: class FirstChars(s: String) extends Product: def _1 = s.charAt(0) def _2 = s.charAt(1) // Not used by pattern matching: Product is only used as a marker trait. def canEqual(that: Any): Boolean = ??? def productArity: Int = ??? def productElement(n: Int): Any = ??? object FirstChars: def unapply(s: String): FirstChars = new FirstChars(s) \"Hi!\" match case FirstChars(char1, char2) =&gt; println(s\"First: $char1; Second: $char2\") // First: H; Second: i Одиночное совпадение Пример: class Nat(val x: Int): def get: Int = x def isEmpty = x &lt; 0 object Nat: def unapply(x: Int): Nat = new Nat(x) 5 match case Nat(n) =&gt; println(s\"$n is a natural number\") case _ =&gt; () // 5 is a natural number Совпадение по имени Пример: object ProdEmpty: def _1: Int = ??? def _2: String = ??? def isEmpty = true def unapply(s: String): this.type = this def get = this \"\" match case ProdEmpty(_, _) =&gt; ??? case _ =&gt; println(\"not ProdEmpty\") // not ProdEmpty Экстракторы с переменным числом параметров Экстракторы с переменным числом параметров предоставляют следующую сигнатуру: def unapplySeq[A](x: T)(implicit x: B): U Тип U соответствует одному из следующих совпадений: соответствие последовательности соответствие последовательности продуктов Или U соответствует типу R: type R = { def isEmpty: Boolean def get: S } и S соответствует одному из двух совпадений выше. Соответствие последовательности имеет более высокий приоритет, чем соответствие последовательности продуктов. Использование экстрактора с переменным числом параметров применяется, если выполняется одно из следующих условий: экстрактор используется непосредственно как соответствие последовательности или соответствие продукта последовательности U = Some[T] (для совместимости со Scala 2) U &lt;: R, а также U &lt;: { def isEmpty: false } Совпадение последовательности Пример: object CharList: def unapplySeq(s: String): Option[Seq[Char]] = Some(s.toList) \"example\" match case CharList(c1, c2, c3, c4, _, _, _) =&gt; println(s\"$c1,$c2,$c3,$c4\") case _ =&gt; println(\"Expected *exactly* 7 characters!\") // e,x,a,m Соответствие последовательности продуктов Пример: class Foo(val name: String, val children: Int*) object Foo: def unapplySeq(f: Foo): Option[(String, Seq[Int])] = Some((f.name, f.children)) def foo(f: Foo): Unit = f match case Foo(name, x, y, ns*) =&gt; println(s\"name = $name, x = $x, y = $y, ns = $ns\") case Foo(name, ns*) =&gt; println(s\"name = $name, ns = $ns\") foo(new Foo(\"first\", 2)) // name = first, ns = ArraySeq(2) foo(new Foo(\"first\", 2, 3)) // name = first, x = 2, y = 3, ns = ArraySeq() foo(new Foo(\"first\", 2, 3, 4)) // name = first, x = 2, y = 3, ns = ArraySeq(4) References: Scala 3 Reference"
    } ,      
    {
      "title": "Полимор. типы функций",
      "url": "/scalaworkbook/docs/type-system/polymorphic-function-types.html",
      "content": "Полиморфные типы функций Полиморфный тип функции — это тип функции, который принимает параметры типа. Например: // полиморфный метод: def foo[A](xs: List[A]): List[A] = xs.reverse // полиморфное значение функции: val bar: [A] =&gt; List[A] =&gt; List[A] // ^^^^^^^^^^^^^^^^^^^^^^^^^ // полиморфный тип функции = [A] =&gt; (xs: List[A]) =&gt; foo[A](xs) В Scala есть полиморфные методы, т.е. методы, которые принимают параметры типа. Метод foo является примером метода, принимающим параметр типа A. Теперь полиморфные методы можно превратить в значения полиморфных функций, как указано выше, которые можно передавать в качестве параметров другим функциям или возвращать в качестве результатов. Тип значения bar - [A] =&gt; List[A] =&gt; List[A] описывает значения функций, которые принимают тип A в качестве параметра, затем принимают список List[A] и возвращают список того же типа List[A]. Подробнее Пример использования Полиморфный тип функции особенно полезен, когда от вызывающего метода требуется предоставить функцию, которая должна быть полиморфной, что означает, что она должна принимать произвольные типы как часть своих входных данных. Например, рассмотрим ситуацию, когда есть тип данных для представления выражений простого языка (состоящего только из переменных и приложений функций) в строго типизированном виде: enum Expr[A]: case Var(name: String) case Apply[A, B](fun: Expr[B =&gt; A], arg: Expr[B]) extends Expr[A] Желательно предоставить пользователям способ отображать функцию на все непосредственные подвыражения данного Expr. Это требует, чтобы данная функция была полиморфной, поскольку каждое подвыражение может иметь свой тип. Вот как это реализовать с помощью полиморфных типов функций: def mapSubexpressions[A](e: Expr[A])(f: [B] =&gt; Expr[B] =&gt; Expr[B]): Expr[A] = e match case Apply(fun, arg) =&gt; Apply(f(fun), f(arg)) case Var(n) =&gt; Var(n) А вот как использовать эту функцию для переноса каждого подвыражения в данное выражение с вызовом некоторой функции wrap, определенной как переменная: val e0 = Apply(Var(\"f\"), Var(\"a\")) val e1 = mapSubexpressions(e0)([B] =&gt; (se: Expr[B]) =&gt; Apply(Var[B =&gt; B](\"wrap\"), se)) println(e1) // Apply(Apply(Var(wrap),Var(f)),Apply(Var(wrap),Var(a))) Связь с лямбда-выражениями типа Полиморфные типы функций не следует путать с лямбда-типами. В то время как первое описывает тип полиморфного значения, второе является фактическим значением функции на уровне типа. Хороший способ понять разницу — заметить, что лямбда-выражения типов применяются в типах, тогда как полиморфные функции применяются в терминах: можно было бы вызвать приведенную выше функцию bar, передав ей аргумент типа bar[Int] в теле метода. С другой стороны, при наличии лямбда-типа, такого как type F = [A] =&gt;&gt; List[A], можно было бы вызвать F внутри выражения типа, как в type Bar = F[Int]. References: Scala 3 Reference"
    } ,    
    {
      "title": "Чистые функции",
      "url": "/scalaworkbook/docs/fp/pure-functions.html",
      "content": "Чистые функции Еще одна концепция, которую Scala предлагает для помощи в написании функционального кода, — это возможность писать чистые функции. Чистая функция (pure function) может быть определена следующим образом: функция f является чистой, если при одних и тех же входных данных x она всегда возвращает один и тот же результат f(x) результат функции зависит только от входных данных и её реализации чистые функции только вычисляют результат, ничего не меняя за пределами этих функций Из этого следует: чистая функция не изменяет свои входные параметры она не мутирует какое-либо скрытое состояние у неё нет “черных ходов”: он не читает данные из внешнего мира (включая консоль, веб-сервисы, базы данных, файлы и т. д.) и не записывает данные вовне В результате этого определения каждый раз, когда вызывается чистая функция с одним и тем же входным значением (значениями), всегда будет выдаваться один и тот же результат. Например, можно вызывать функцию double бесконечное число раз с входным значением 2, и всегда получать результат 4. Примеры чистых функций Учитывая это определение, методы в пакете scala.math._ являются чистыми функциями: abs ceil max Эти методы String также являются чистыми функциями: isEmpty length substring Большинство методов в классах коллекций Scala также работают как чистые функции, включая drop, filter, map и многие другие. В Scala функции и методы почти полностью взаимозаменяемы, поэтому, хотя здесь используется общепринятый отраслевой термин “чистая функция”, этот термин можно использовать как для описания функций, так и методов. Как методы могут использоваться подобно функциям описано в главе Eta расширение. Примеры “нечистых” функций И наоборот, следующие функции “нечисты” (impure), потому что они нарушают определение pure function: println — методы, взаимодействующие с консолью, файлами, базами данных, веб-сервисами и т. д., “нечисты” currentTimeMillis — все методы, связанные с датой и временем, “нечисты”, потому что их вывод зависит от чего-то другого, кроме входных параметров sys.error — методы генерации исключений “нечисты”, потому что они не “просто возвращают результат” “Нечистые” функции часто делают одну или несколько из следующих вещей: читают из скрытого состояния, т.е. обращаются к параметрам и данным, не переданным в функцию явным образом в качестве входных параметров запись в скрытое состояние изменяют заданные им параметры или изменяют скрытые переменные, например, поля в содержащем их классе выполняют какой-либо ввод-вывод с внешним миром В общем, следует остерегаться функций с возвращаемым типом Unit. Поскольку эти функции ничего не возвращают, логически единственная причина, по которой они когда-либо вызываются, - это достижение какого-то побочного эффекта. Как следствие, часто использование этих функций является “нечистым”. Но нечистые функции все же необходимы… Конечно, приложение не очень полезно, если оно не может читать или писать во внешний мир, поэтому рекомендуется следующее: Напишите ядро вашего приложения, используя только “чистые” функции, а затем напишите “нечистую” “оболочку” вокруг этого ядра для взаимодействия с внешним миром. Как кто-то однажды сказал, это все равно, что положить слой нечистой глазури на чистый торт. Важно отметить, что есть способы сделать “нечистое” взаимодействие с внешним миром более “чистым”. Например, можно услышать об использовании IO монады для обработки ввода-вывода. Эти темы выходят за рамки данного документа, поэтому для простоты можно думать, что ФП приложения имеют ядро из “чистых” функций, которые объединены с другими функциями для взаимодействия с внешним миром. Написание “чистых” функций Примечание: в этом разделе для обозначения методов Scala часто используется общепринятый в отрасли термин “чистая функция”. Для написания чистых функций на Scala, достаточно писать их, используя синтаксис методов Scala (хотя также можно использовать и синтаксис функций Scala). Например, вот чистая функция, которая удваивает заданное ей входное значение: def double(i: Int): Int = i * 2 Вот чистая функция, которая вычисляет сумму списка целых чисел с использованием рекурсии: def sum(xs: List[Int]): Int = xs match case Nil =&gt; 0 case head :: tail =&gt; head + sum(tail) Вышеописанные функции соответствуют определению “чистых”. Ключевые моменты Первым ключевым моментом этого раздела является определение чистой функции: Чистая функция — это функция, которая зависит только от своих объявленных входных данных и своей реализации для получения результата. Она только вычисляет свой результат, не завися от внешнего мира и не изменяя его. Второй ключевой момент заключается в том, что каждое реальное приложение взаимодействует с внешним миром. Таким образом, упрощенный способ представления о функциональных программах состоит в том, что они состоят из ядра чистых функций, которые обернуты другими функциями, взаимодействующими с внешним миром. References: Scala3 book"
    } ,    
    {
      "title": "Queue",
      "url": "/scalaworkbook/docs/collections/queue.html",
      "content": "Queue Очередь (Queue) - это последовательность с FIFO (первым пришёл — первым ушёл). Элемент добавляется в очередь с помощью метода enqueue (или enqueueAll - для добавления коллекции в очередь) и достается из очереди используя метод dequeue. Эти операции выполняются за постоянное время. Вот как можно создать пустую неизменяемую очередь: import scala.collection.immutable.Queue val empty = Queue[Int]() // empty: Queue[Int] = Queue() val has1 = empty.enqueue(1) // has1: Queue[Int] = Queue(1) val has123 = has1.enqueueAll(List(2, 3)) // has123: Queue[Int] = Queue(1, 2, 3) val (element, has23) = has123.dequeue // element: Int = 1 // has23: Queue[Int] = Queue(2, 3) Обратите внимание, что dequeue возвращает пару, состоящую из удаленного элемента и остальной части очереди. Изменяемая очередь References: Scala, Immutable collections Scala, Mutable collections"
    } ,    
    {
      "title": "Quoted Code",
      "url": "/scalaworkbook/docs/metaprogramming/quoted-code.html",
      "content": "Quoted Code Кодовые блоки Блок кода в кавычках '{ ... } синтаксически похож на строковую кавычку \" ... \" с той разницей, что первая содержит типизированный код. Чтобы вставить код в другой код, можно использовать синтаксис $expr или ${ expr }, где expr имеет тип Expr[T]. Интуитивно понятно, что код непосредственно внутри кавычки ('{ ... }) сейчас не выполняется, в то время как код внутри склейки (${ ... }) оценивается и результаты встраиваются в окружающее выражение. val msg = Expr(\"Hello\") val printHello = '{ print($msg) } println(printHello.show) // print(\"Hello\") Как правило, цитаты задерживают выполнение, в то время как склейка делает это раньше окружающего кода. Из-за некоторых технических соображений непосредственно внутри inline определений, которые называются макросами, разрешены только склейки верхнего уровня. Можно написать цитату внутри цитаты, но этот шаблон не распространен при написании макросов. Согласованность уровней Нельзя просто написать любой произвольный код в цитатах и в склейках, так как одна часть программы будет жить во время компиляции, а другая — во время выполнения. Рассмотрим следующий плохо сконструированный код: def myBadCounter1(using Quotes): Expr[Int] = { var x = 0 '{ x += 1; x } } Проблема с этим кодом в том, что x существует во время компиляции, но затем мы пытаемся использовать его после завершения компиляции (возможно, даже на другой машине). Ясно, что невозможно получить доступ к его значению и обновить x. Теперь рассмотрим двойную версию, где определяется переменная во время выполнения и происходит попытка получить к ней доступ во время компиляции: def myBadCounter2(using Quotes): Expr[Int] = '{ var x = 0 ${ x += 1; 'x } } Ясно, что это не должно работать, так как переменная еще не существует. Чтобы убедиться, что нельзя писать программы, которые содержат такого рода проблемы, виды ссылок, разрешенных в области цитат, ограничиваются. Вводятся уровни как количество цитат за вычетом количества склеек, окружающих выражение или определение. // level 0 '{ // level 1 var x = 0 ${ // level 0 x += 1 'x // level 1 } } Система разрешает ссылки на глобальные определения, например, println на любом уровне, но ограничивает ссылки на локальные определения. Доступ к локальному определению возможен только в том случае, если оно задано на том же уровне, что и его ссылка. Это позволит поймать ошибки в myBadCounter1 и myBadCounter2. Несмотря на то, что нельзя ссылаться на переменную внутри цитаты, все же можно передать ее текущее значение через кавычку, подняв значение до выражения с помощью Expr.apply. Дженерики При использовании параметров типа или других видов абстрактных типов с кодом в кавычках потребуется явно отслеживать некоторые из этих типов. Scala использует семантику стертых типов для своих дженериков. Это означает, что типы удаляются из программы при компиляции, и среде выполнения не нужно отслеживать все типы во время выполнения. Рассмотрим следующий код: def evalAndUse[T](x: Expr[T])(using Quotes) = '{ val x2: T = $x // error ... // use x2 } Здесь будет получено сообщение об ошибке, сообщающее, что не хватает контекстного параметра Type[T]. Это можно легко исправить, написав: def evalAndUse[T](x: Expr[T])(using Type[T])(using Quotes) = '{ val x2: T = $x ... // use x2 } Код будет эквивалентен такой более подробной версии: def evalAndUse[T](x: Expr[T])(using t: Type[T])(using Quotes) = '{ val x2: t.Underlying = $x ... // use x2 } Обратите внимание, что у Type вызывается член типа Underlying, который ссылается на тип, хранящийся в Type; в данном случае t.Underlying есть T. Даже если Type используется неявно, как правило, лучше оставить его контекстуальным, так как некоторые изменения внутри цитаты могут потребовать этого. Менее подробная версия обычно является лучшим способом написания типов, поскольку ее намного проще читать. В некоторых случаях не будет статически известен тип внутри Type и нужно будет использовать t.Underlying для ссылки на него. Когда нужен этот дополнительный Type параметр? когда тип является абстрактным и используется на уровне выше текущего Когда добавляется контекстный параметр Type в метод, он либо получается из другого параметра контекста, либо неявно с помощью вызова Type.of: evalAndUse(Expr(3)) // эквивалентно: evalAndUse[Int](Expr(3))(using Type.of[Int]) Не каждый тип можно использовать в качестве параметра Type.of[..] из коробки. Например, нельзя восстановить абстрактные типы, которые уже были стерты: def evalAndUse[T](x: Expr[T])(using Quotes) = given Type[T] = Type.of[T] // error '{ val x2: T = $x ... // use x2 } Но можно написать более сложные типы, которые зависят от этих абстрактных типов. Например, если ищем или явно создаем Type[List[T]], то системе потребуется Type[T] в текущем контексте для компиляции. Хороший код должен добавлять Types только к параметрам контекста и никогда не использовать их явно. Однако явное использование полезно при отладке, хотя и достигается за счет краткости и ясности. ToExpr Метод Expr.apply использует экземпляры ToExpr для создания выражения, которое создаст копию значения. object Expr: def apply[T](x: T)(using Quotes, ToExpr[T]): Expr[T] = summon[ToExpr[T]].apply(x) ToExpr определяется следующим образом: trait ToExpr[T]: def apply(x: T)(using Quotes): Expr[T] Метод ToExpr.apply примет значение T и сгенерирует код, который создаст копию этого значения во время выполнения. Можно определить собственные ToExpr-ы, например: given ToExpr[Boolean] with { def apply(x: Boolean)(using Quotes) = if x then '{true} else '{false} } given ToExpr[StringContext] with { def apply(stringContext: StringContext)(using Quotes) = val parts = Varargs(stringContext.parts.map(Expr(_))) '{ StringContext($parts: _*) } } Конструктор Varargs просто создает Expr[Seq[T]], который можно эффективно склеить как varargs. В общем, любую последовательность $mySeq: _* можно соединить, чтобы соединить ее как varargs. Шаблоны цитат Цитаты также можно использовать для проверки эквивалентности одного выражения другому или для деконструкции выражения на части. Соответствие точному выражению Самое простое, что можно сделать, - это проверить, соответствует ли выражение другому известному выражению. Пример: def valueOfBoolean(x: Expr[Boolean])(using Quotes): Option[Boolean] = x match case '{ true } =&gt; Some(true) case '{ false } =&gt; Some(false) case _ =&gt; None def valueOfBooleanOption(x: Expr[Option[Boolean]])(using Quotes): Option[Option[Boolean]] = x match case '{ Some(true) } =&gt; Some(Some(true)) case '{ Some(false) } =&gt; Some(Some(false)) case '{ None } =&gt; Some(None) case _ =&gt; None Соответствующее частичное выражение Для большей компактности, можно сопоставить часть выражения, используя склейку ($), чтобы сматчить произвольный код и извлечь его. def valueOfBooleanOption(x: Expr[Option[Boolean]])(using Quotes): Option[Option[Boolean]] = x match case '{ Some($boolExpr) } =&gt; Some(valueOfBoolean(boolExpr)) case '{ None } =&gt; Some(None) case _ =&gt; None Соответствие типов выражений Также можно сопоставлять код произвольного типа T. Ниже матчится $x типа T и на выходе получается x типа Expr[T]. def exprOfOption[T: Type](x: Expr[Option[T]])(using Quotes): Option[Expr[T]] = x match case '{ Some($x) } =&gt; Some(x) // x: Expr[T] case '{ None } =&gt; Some(None) case _ =&gt; None Также можно проверить тип выражения: def valueOf(x: Expr[Any])(using Quotes): Option[Any] = x match case '{ $x: Boolean } =&gt; valueOfBoolean(x) // x: Expr[Boolean] case '{ $x: Option[Boolean] } =&gt; valueOfBooleanOption(x) // x: Expr[Option[Boolean]] case _ =&gt; None Или аналогично для частичного выражения: case '{ Some($x: Boolean) } =&gt; // x: Expr[Boolean] Соответствующий приемник методов Когда желательно сопоставить получателя метода, нужно явно указать его тип: case '{ ($ls: List[Int]).sum } =&gt; Если бы было написано $ls.sum, то нельзя было бы узнать тип ls и метод sum, который вызывается. Другой распространенный случай, когда нужны аннотации типов, — это инфиксные операции: case '{ ($x: Int) + ($y: Int) } =&gt; case '{ ($x: Double) + ($y: Double) } =&gt; case ... Сопоставление типов До сих пор предполагалось, что типы внутри паттернов цитат будут известны статически. Шаблоны цитат также допускают общие типы и экзистенциальные типы. Общие типы в шаблонах Рассмотрим функцию exprOfOption: def exprOfOption[T: Type](x: Expr[Option[T]])(using Quotes): Option[Expr[T]] = x match case '{ Some($x: T) } =&gt; Some(x) // x: Expr[T] // ^^^ type ascription with generic type T ... Обратите внимание, что на этот раз T добавлен в шаблон явно, хотя его можно было бы вывести. Ссылаясь на универсальный тип T в шаблоне, в области видимости должен быть доступен given Type[T]. Это означает, что $x: T будет матчиться, только если x имеет тип Expr[T]. В данном конкретном случае это условие всегда будет истинным. Теперь рассмотрим следующий вариант, где x - необязательное значение со (статически) неизвестным типом элемента: def exprOfOptionOf[T: Type](x: Expr[Option[Any]])(using Quotes): Option[Expr[T]] = x match case '{ Some($x: T) } =&gt; Some(x) // x: Expr[T] case _ =&gt; None На этот раз шаблон будет соответствовать только в том случае, если Some($x: T) - тип .OptionSome[T] exprOfOptionOf[Int]('{ Some(3) }) // Some('{3}) exprOfOptionOf[Int]('{ Some(\"a\") }) // None Переменные типа в шаблонах Код в кавычках может содержать типы, неизвестные вне кавычек. Можно сопоставить их, используя переменные типа шаблона. Как и в обычном шаблоне, переменные типа записываются с использованием имен нижнего регистра. def exprOptionToList(x: Expr[Option[Any]])(using Quotes): Option[Expr[List[Any]]] = x match case '{ Some($x: t) } =&gt; // ^^^ this binds the type `t` in the body of the case Some('{ List[t]($x) }) // x: Expr[List[t]] case '{ None } =&gt; Some('{ Nil }) case _ =&gt; None Шаблон $x: t будет соответствовать выражению любого типа и t будет привязан к типу шаблона. Эта переменная типа доступна только в правой части case. В этом примере переменная используется для построения списка List[t]($x)(List($x) тоже сработает). Поскольку это тип, который неизвестен статически, нужен given Type[t] в области видимости. К счастью, приведенный шаблон автоматически это предоставит. Простой шаблон case '{ $expr: tpe } =&gt; очень полезен, если необходимо знать точный тип выражения. val expr: Expr[Option[Int]] = ... expr match case '{ $expr: tpe } =&gt; Type.show[tpe] // could be: Option[Int], Some[Int], None, Option[1], Option[2], ... '{ val x: tpe = $expr; x } // binds the value without widening the type ... В некоторых случаях необходимо определить переменную шаблона, на которую ссылаются несколько раз или имеющую некоторые ограничения типа. Для этого можно создать переменные шаблона в начале шаблона, используя type t переменную шаблона типа. /** * Use: Converts a redundant `list.map(f).map(g)` to only use one call * to `map`: `list.map(y =&gt; g(f(y)))`. */ def fuseMap[T: Type](x: Expr[List[T]])(using Quotes): Expr[List[T]] = x match { case '{ type u type v ($ls: List[`u`]) .map($f: `u` =&gt; `v`) .map($g: `v` =&gt; T) } =&gt; '{ $ls.map(y =&gt; $g($f(y))) } case _ =&gt; x } Здесь определяются две переменные типа u и v, а затем к ним идет обращение. Обращение идет не напрямую u или v (без обратных кавычек), потому что они будут интерпретироваться как переменные нового типа с тем же именем переменной. Эта нотация следует обычному синтаксису шаблонов стабильных идентификаторов (stable identifier patterns). Кроме того, если переменная типа должна быть ограничена, можно добавить ограничения непосредственно к определению типа case '{ type u &lt;: AnyRef; ... } =&gt;: Обратите внимание, что предыдущий случай также может быть записан как case '{ ($ls: List[u]).map[v]($f).map[T]($g) =&gt;. Quote types patterns Типы, представленные с помощью Type[T], можно сопоставить с помощью шаблона case '[...] =&gt;. def mirrorFields[T: Type](using Quotes): List[String] = Type.of[T] match case '[field *: fields] =&gt; Type.show[field] :: mirrorFields[fields] case '[EmptyTuple] =&gt; Nil case _ =&gt; compiletime.error(\"Expected known tuple but got: \" + Type.show[T]) mirrorFields[EmptyTuple] // Nil mirrorFields[(Int, String, Int)] // List(\"Int\", \"String\", \"Int\") mirrorFields[Tuple] // error: Expected known tuple but got: Tuple Как и в случае выражений шаблонов в кавычках, переменные типа представлены с использованием имен нижнего регистра. FromExpr Методы Expr.value, Expr.valueOrError и Expr.unapply используют экземпляры FromExpr для извлечения значения, если это возможно. extension [T](expr: Expr[T]): def value(using Quotes)(using fromExpr: FromExpr[T]): Option[T] = fromExpr.unapply(expr) def valueOrError(using Quotes)(using fromExpr: FromExpr[T]): T = fromExpr.unapply(expr).getOrElse(eport.throwError(\"...\", expr)) end extension object Expr: def unapply[T](expr: Expr[T])(using Quotes)(using fromExpr: FromExpr[T]): Option[T] = fromExpr.unapply(expr) FromExpr определяется следующим образом: trait FromExpr[T]: def unapply(x: Expr[T])(using Quotes): Option[T] Метод FromExpr.unapply примет значение x и сгенерирует код, который создаст копию этого значения во время выполнения. Можно определить собственные FromExprs следующим образом: given FromExpr[Boolean] with { def unapply(x: Expr[Boolean])(using Quotes): Option[Boolean] = x match case '{ true } =&gt; Some(true) case '{ false } =&gt; Some(false) case _ =&gt; None } given FromExpr[StringContext] with { def unapply(x: Expr[StringContext])(using Quotes): Option[StringContext] = x match { case '{ new StringContext(${Varargs(Exprs(args))}: _*) } =&gt; Some(StringContext(args: _*)) case '{ StringContext(${Varargs(Exprs(args))}: _*) } =&gt; Some(StringContext(args: _*)) case _ =&gt; None } } Стоит обратить внимание на то, что были рассмотрены два случая StringContext. Поскольку это объект case class, его можно создать с помощью new StringContext или StringContext.apply из объекта-компаньона. Также был использован Varargs экстрактор для сопоставления аргументов типа Expr[Seq[String]] с Seq[Expr[String]]. Затем был использован Exprs, чтобы сопоставить известные константы в Seq[Expr[String]] для получения Seq[String]. Цитаты Quotes - основная точка входа для создания всех цитат. Этот контекст обычно просто передается через контекстные абстракции (using и ?=&gt;). Каждая область цитаты будет иметь свой собственный Quotes. Новые области вводятся каждый раз, когда вводится соединение (${ ... }). Хотя кажется, что splice принимает выражение в качестве аргумента, на самом деле он принимает Quotes ?=&gt; Expr[T]. Следовательно, можно было бы написать это явно как ${ (using q) =&gt; ... }. Это может быть полезно при отладке, чтобы избежать создания имен для этих областей. Метод scala.quoted.quotes обеспечивает простой способ использования Quotes без его именования. Обычно он импортируется вместе с Quotes используя import scala.quoted.*. ${ (using q1) =&gt; body(using q1) } // equivalent to ${ body(using quotes) } Предупреждение: если вы явно назовете Quotes quotes, вы перетрёте это определение. Когда пишется splice верхнего уровня в макросе, вызывается что-то похожее на следующее определение. Этот splice обеспечит начальное значение Quotes, связанное с расширением макроса. def $[T](x: Quotes ?=&gt; Expr[T]): T = ... Когда есть splice внутри цитаты, внутренний контекст цитаты будет зависеть от внешнего. Эта ссылка представлена с использованием типа Quotes.Nested. Пользователям цитат почти никогда не понадобится использовать Quotes.Nested. Эти сведения полезны только для расширенных макросов, которые будут проверять код и могут столкнуться с деталями кавычек и splice-ов. def f(using q1: Quotes) = '{ ${ (using q2: q1.Nested) ?=&gt; ... } } Можно представить, что вложенный splice подобен следующему методу, где ctx - контекст, полученный окружающей цитатой. def $[T](using q: Quotes)(x: q.Nested ?=&gt; Expr[T]): T = ... β-reduction Когда есть лямбда, применяемая к аргументу в кавычке '{ ((x: Int) =&gt; x + x)(y) }, она не уменьшается внутри кавычки; код сохраняется как есть. Существует оптимизация, которая будет β-редуцировать все лямбда-выражения, непосредственно применяемые к параметрам, чтобы избежать создания замыкания. Это не будет видно с точки зрения цитаты. Иногда бывает полезно выполнить эту β-редукцию непосредственно на цитатах. Для этого используется функция Expr.betaReduce[T], которая получает Expr[T] и β-редуцирует, если она непосредственно содержит применяемую лямбду. Expr.betaReduce('{ ((x: Int) =&gt; x + x)(y) }) // returns '{ val x = y; x + x } Summon values Есть два способа вызвать значения в макросе. Во-первых, использовать using параметр во встроенном методе, который явно передается реализации макроса. inline def setOf[T](using ord: Ordering[T]): Set[T] = ${ setOfCode[T]('ord) } def setOfCode[T: Type](ord: Expr[Ordering[T]])(using Quotes): Expr[Set[T]] = '{ TreeSet.empty[T](using $ord) } В этом случае параметр контекста обнаруживается до развертывания макроса. Если не найден, макрос не будет раскрыт. Второй способ — использование Expr.summon. Это позволяет программно искать различные given выражения. Следующий пример аналогичен предыдущему примеру: inline def setOf[T]: Set[T] = ${ setOfCode[T] } def setOfCode[T: Type](using Quotes): Expr[Set[T]] = Expr.summon[Ordering[T]] match case Some(ord) =&gt; '{ TreeSet.empty[T](using $ord) } case _ =&gt; '{ HashSet.empty[T] } Разница в том, что во втором сценарии макрос разворачивается перед выполнением неявного поиска. Поэтому можно написать произвольный код для обработки случая, когда элемент Ordering[T] не найден. Здесь используется HashSet вместо TreeSet, потому что первый не нуждается в Ordering. Цитатные классы типов В предыдущем примере было показано, как явно использовать класс типа Expr[Ordering[T]], используя предложение аргумента using. Это хорошо, но не очень удобно, если нужно использовать класс типов несколько раз. Чтобы показать это, будем использовать функцию powerCode, которую можно использовать для любого числового типа. Во-первых, может быть полезно сделать так, чтобы класс типа Expr мог сделать его given параметром. Для этого нужно явно указать powerCode в power, потому что есть given Numeric[Num], но требуется Expr[Numeric[Num]]. Но тогда можно игнорировать его в powerMacro и в любом другом месте, которое только его передает. inline def power[Num](x: Num, inline n: Int)(using num: Numeric[Num]) = ${ powerMacro('x, 'n)(using 'num) } def powerMacro[Num: Type](x: Expr[Num], n: Expr[Int])(using Expr[Numeric[Num]])(using Quotes): Expr[Num] = powerCode(x, n.valueOrAbort) Чтобы использовать этот класс типа, нужен given Numeric[Num],но у нас есть Expr[Numeric[Num]], и поэтому нужно склеить это выражение в сгенерированном коде. Чтобы сделать его доступным, можно просто соединить его с заданным определением. def powerCode[Num: Type](x: Expr[Num], n: Int)(using num: Expr[Numeric[Num]])(using Quotes): Expr[Num] = if (n == 0) '{ $num.one } else if (n % 2 == 0) '{ given Numeric[Num] = $num val y = $x * $x ${ powerCode('y, n / 2) } } else '{ given Numeric[Num] = $num $x * ${ powerCode(x, n - 1) } } References: Scala 3 Guide Scala 3 Reference"
    } ,    
    {
      "title": "Range",
      "url": "/scalaworkbook/docs/collections/range.html",
      "content": "Диапазон (Range) Range часто используется для заполнения структур данных и для циклов for. Эти примеры демонстрируют, как создавать диапазоны: 1 to 5 // res0: Inclusive = Range(1, 2, 3, 4, 5) 1 until 5 // res1: Range = Range(1, 2, 3, 4) 1 to 10 by 2 // res2: Range = Range(1, 3, 5, 7, 9) 'a' to 'c' // res3: Inclusive[Char] = NumericRange('a', 'b', 'c') Range можно использовать для заполнения коллекций: val x = (1 to 5).toList // x: List[Int] = List(1, 2, 3, 4, 5) val y = (1 to 5).toBuffer // y: Buffer[Int] = ArrayBuffer(1, 2, 3, 4, 5) Они также используются в циклах for: for i &lt;- 1 to 3 do println(i) // 1 // 2 // 3 Во многих коллекциях есть метод range: Vector.range(1, 5) // res5: Vector[Int] = Vector(1, 2, 3, 4) List.range(1, 10, 2) // res6: List[Int] = List(1, 3, 5, 7, 9) Set.range(1, 10) // res7: Set[Int] = HashSet(5, 1, 6, 9, 2, 7, 3, 8, 4) Диапазоны также полезны для создания тестовых коллекций: val evens = (0 to 10 by 2).toList // evens: List[Int] = List(0, 2, 4, 6, 8, 10) val odds = (1 to 10 by 2).toList // odds: List[Int] = List(1, 3, 5, 7, 9) val doubles = (1 to 5).map(_ * 2.0) // doubles: IndexedSeq[Double] = Vector(2.0, 4.0, 6.0, 8.0, 10.0) val map = (1 to 3).map(e =&gt; (e,s\"$e\")).toMap // map: Map[Int, String] = Map(1 -&gt; \"1\", 2 -&gt; \"2\", 3 -&gt; \"3\") References: Scala3 book Scala3 book, Collections Types Scala, Immutable collections Scala, Mutable collections"
    } ,    
    {
      "title": "Reflection",
      "url": "/scalaworkbook/docs/metaprogramming/reflection.html",
      "content": "Reflection API отражения обеспечивает более сложное и полное представление о структуре кода. Оно обеспечивает представление типизированных абстрактных синтаксических деревьев и их свойств, таких как типы, символы, позиции и комментарии. API можно использовать в макросах, а также для проверки файлов TASTy. Как использовать API API отражения определен в типе Quotes как reflect. Фактический экземпляр зависит от текущей области, в которой используются цитаты или сопоставление с образцом в цитатах. Следовательно, каждый метод макроса получает Quotes в качестве дополнительного аргумента. Поскольку Quotes является контекстным, для доступа к его членам нужно либо назвать параметр, либо вызвать его. Следующее определение из стандартной библиотеки подробно описывает канонический способ доступа к ней: package scala.quoted transparent inline def quotes(using inline q: Quotes): q.type = q Можно использовать scala.quoted.quotes для импорта текущей Quotes в область видимости: import scala.quoted.* // Import `quotes`, `Quotes`, and `Expr` def f(x: Expr[Int])(using Quotes): Expr[Int] = import quotes.reflect.* // Import `Tree`, `TypeRepr`, `Symbol`, `Position`, ..... val tree: Tree = ... ... Это позволит импортировать все типы и модули (с методами расширения) API. Как ориентироваться в API Полный API можно найти в документации по API для scala.quoted.Quotes.reflectModule. Наиболее важным элементом на странице является дерево иерархии, которое обеспечивает синтетический обзор отношений подтипов типов в API. Для каждого типа Foo в дереве: трейт FooMethods содержит методы, доступные для типа Foo трейт FooModule содержит статические методы, доступные для объекта Foo. В частности, здесь находятся конструкторы (apply/copy) и unapply метод, предоставляющий экстракторы, необходимые для сопоставления с образцом. Для всех типов Upper таких как Foo &lt;: Upper, методы, определенные в UpperMethods, также доступны для Foo Например, TypeBounds, подтип TypeRepr, представляет дерево типов в форме T &gt;: L &lt;: U: тип T, который является надтипом L и подтипом U. В TypeBoundsMethods есть методы low и hi, которые позволяют получить доступ к представлениям L и U. В TypeBoundsModule, доступен unapply метод, который позволяет написать: def f(tpe: TypeRepr) = tpe match case TypeBounds(l, u) =&gt; Поскольку TypeBounds &lt;: TypeRepr, все методы, определенные в TypeReprMethods, доступны для значений TypeBounds: def f(tpe: TypeRepr) = tpe match case tpe: TypeBounds =&gt; val low = tpe.low val hi = tpe.hi Связь с выражением/типом Expr и Term Выражения (Expr[T]) можно рассматривать как обертки вокруг Term, где T статически известный тип термина. Ниже используется метод расширения asTerm для преобразования выражения в термин. Этот метод расширения доступен только после импорта файлов quotes.reflect.asTerm. Затем используется asExprOf[Int], чтобы преобразовать термин обратно в Expr[Int]. Эта операция завершится ошибкой, если термин не имеет указанного типа (в данном случае Int) или если термин не является допустимым выражением. Например, Ident(fn) является недопустимым термином, если метод fn принимает параметры типа, и в этом случае потребуется расширение Apply(Ident(fn), args). def f(x: Expr[Int])(using Quotes): Expr[Int] = import quotes.reflect.* val tree: Term = x.asTerm val expr: Expr[Int] = tree.asExprOf[Int] expr Type и TypeRepr Точно так же можно рассматривать Type[T] как оболочку над TypeRepr со статически известным типом T. Чтобы получить TypeRepr, используется TypeRepr.of[T], который ожидает given Type[T] в области видимости (аналогично Type.of[T]). Также можно преобразовать его обратно в Type[?] с помощью метода asType. Поскольку тип Type[?] статически неизвестен, нужно вызвать его с реальным типом, чтобы его использовать. Этого можно добиться с помощью паттерна '[t]. def g[T: Type](using Quotes) = import quotes.reflect.* val tpe: TypeRepr = TypeRepr.of[T] tpe.asType match case '[t] =&gt; '{ val x: t = ${...} } ... Символы API-интерфейсы Term и TypeRepr относительно закрыты в том смысле, что методы производят и принимают значения, типы которых определены в API. Однако можно заметить наличие Symbols, которые идентифицируют определения. И Term, и TypeRepr (и, следовательно, Expr и Type) имеют связанный символ. Symbols позволяют сравнить два определения по ==, чтобы узнать, являются ли они одинаковыми. Кроме того, Symbol раскрывает и использует множество полезных методов. Например: declaredFields и declaredMethods позволяет перебирать поля и элементы, определенные внутри символа flags позволяет проверить несколько свойств символа companionClass и companionModule предоставить способ перехода к сопутствующему объекту/классу и обратно TypeRepr.baseClasses возвращает список символов родительских классов, расширенных типом Symbol.pos дает доступ к положению, к исходному коду определения и даже к имени файла, в котором определен символ. многие другие, которые можно найти в SymbolMethods К символу и обратно Рассмотрим экземпляр типа TypeRepr с именем val tpe: TypeRepr = .... Затем: tpe.typeSymbol возвращает символ типа, представленного TypeRepr. Рекомендуемый способ получения Symbol given Type[T] - TypeRepr.of[T].typeSymbol Для одноэлементного типа tpe.termSymbol возвращает символ базового объекта или значения. tpe.memberType(symbol) возвращает TypeRepr предоставленный символ Для объектов t: Tree вызов t.symbol возвращает символ, связанный с деревом. Учитывая, что Term &lt;: Tree, Expr.asTerm.symbol - это лучший способ получить символ, связанный с Expr[T] Для объектов sym: Symbol, sym.tree возвращает Tree, связанное с символом. Будьте осторожны при использовании этого метода, так как дерево для символа может быть не определено. Подробнее читайте на best practices page API-дизайн макросов Часто бывает полезно создавать вспомогательные методы или экстракторы, которые выполняют некоторую общую логику макросов. Самыми простыми методами будут те, которые упоминают только Expr, Type и Quotes в своей подписи. Внутри они могут использовать отражение, но это не будет видно на месте использования метода. def f(x: Expr[Int])(using Quotes): Expr[Int] = import quotes.reflect.* ... В некоторых случаях неизбежно, что некоторые методы будут ожидать или возвращать Trees или другие типы в quotes.reflect. В этих случаях рекомендуется следовать следующим примерам подписи метода: Метод, который принимает quotes.reflect.Term параметр def f(using Quotes)(term: quotes.reflect.Term): String = import quotes.reflect.* ... Метод расширения для quotes.reflect.Term возврата quotes.reflect.Tree extension (using Quotes)(term: quotes.reflect.Term) def g: quotes.reflect.Tree = ... Экстрактор, который соответствует quotes.reflect.Term object MyExtractor: def unapply(using Quotes)(x: quotes.reflect.Term) = ... Some(y) Избегайте сохранения контекста Quotes в поле. Quotes в полях неизбежно усложняют его использование, вызывая ошибки Quotes, связанные с разными путями. Обычно эти шаблоны встречаются в коде, который использует способы Scala 2 для определения методов расширения или контекстных unapply. Теперь, когда есть given параметры, которые можно добавлять перед другими параметрами, все эти старые обходные пути больше не нужны. Новые абстракции упрощают как сторону определения, так и сторону использования. Отладка Проверки во время выполнения Выражения (Expr[T]) можно рассматривать как обертки вокруг Term, где T статически известный тип термина. Следовательно, эти проверки будут выполняться во время выполнения (т.е. во время компиляции, когда макрос раскрывается). Рекомендуется включать флаг -Xcheck-macros при разработке макроса или при его тестировании. Этот флаг активирует дополнительные проверки во время выполнения, которые будут пытаться найти неправильно сформированные деревья или типы, как только они будут созданы. Также есть флаг -Ycheck:all, проверяющий все инварианты компилятора на правильность построения дерева. Эти проверки обычно заканчиваются ошибкой утверждения. Печать деревьев Методы toString для типов в пакете quotes.reflect не подходят для отладки, поскольку они показывают внутреннее представление, а не представление quotes.reflect. Во многих случаях они похожи, но иногда могут сбивать процесс отладки, поэтому на них не следует полагаться. Вместо этого quotes.reflect.Printers предоставляет набор полезных “принтеров” для отладки. Примечательно, что классы TreeStructure, TypeReprStructure и ConstantStructure могут быть весьма полезными. Они будут печатать древовидную структуру в соответствии с экстракторами, которые потребуются для ее сопоставления. val tree: Tree = ... println(tree.show(using Printer.TreeStructure)) Одно из наиболее полезных мест, где это можно добавить — конец сопоставления с образцом в Tree. tree match case Ident(_) =&gt; case Select(_, _) =&gt; ... case _ =&gt; throw new MatchError(tree.show(using Printer.TreeStructure)) Таким образом, если case пропущен, ошибка сообщит о знакомой структуре, которую можно скопировать и вставить, чтобы устранить проблемы. При желании можно сделать этот “принтер” “принтером” по умолчанию: import quotes.reflect.* given Printer[Tree] = Printer.TreeStructure ... println(tree.show) References: Scala 3 Guide Scala 3 Reference"
    } ,    
    {
      "title": "REPL",
      "url": "/scalaworkbook/docs/repl.html",
      "content": "REPL Scala REPL (“Read-Evaluate-Print-Loop”) - это интерпретатор командной строки, который используется в качестве “игровой площадки” для тестирования Scala кода. Для того чтобы запустить сеанс REPL, надо выполнить команду scala или scala3 в зависимости от операционной системы, где будет выведено приглашение “Welcome”, подобное этому: $ scala Welcome to Scala 3.1.3 (OpenJDK 64-Bit Server VM, Java 11.0.9). Type in expressions for evaluation. Or try :help. scala&gt; _ REPL — это интерпретатор командной строки, поэтому он ждет, пока вы что-нибудь наберете. Теперь можно вводить выражения Scala, чтобы увидеть, как они работают: scala&gt; 1 + 1 val res0: Int = 2 scala&gt; 2 + 2 val res1: Int = 4 Как показано в выводе, если не присваивать переменную результату выражения, REPL автоматически создает переменные с именами res0, res1 и т. д. Эти имена переменных можно использовать в последующих выражениях: scala&gt; val x = res0 * 10 val x: Int = 20 Обратите внимание, что в REPL output также показываются результаты выражений. В REPL можно проводить всевозможные эксперименты. В этом примере показано, как создать, а затем вызвать метод sum: scala&gt; def sum(a: Int, b: Int): Int = a + b def sum(a: Int, b: Int): Int scala&gt; sum(2, 2) val res2: Int = 4 Также можно использовать игровую среду на основе браузера scastie.scala-lang.org. Если вы предпочитаете писать код в текстовом редакторе, а не в консоли, то можно использовать worksheet. References: Scala3 book"
    } ,    
    {
      "title": "Возврат функции в методе",
      "url": "/scalaworkbook/docs/functions/returns-function.html",
      "content": "Возврат функции в методе Благодаря согласованности Scala написание метода, возвращающего функцию, похоже на то, что было описано в предыдущих разделах. Еще раз начнем с постановки проблемы: Необходимо создать метод greet, возвращающий функцию. Эта функция должна принимать строковый параметр и печатать его с помощью println. Начнем с простого шага: greet не принимает никаких входных параметров, а просто создает функцию и возвращает её. Учитывая это утверждение, можно начать создавать greet. Известно, что это будет метод: def greet() Также известно, что этот метод должен возвращать функцию, которая: принимает параметр String и печатает эту строку с помощью println. Следовательно, эта функция имеет тип String =&gt; Unit: def greet(): String =&gt; Unit = ??? ---------------- Теперь нужно создать тело метода. Возвращаемая функция соответствует следующему описанию: (name: String) =&gt; println(s\"Hello, $name\") Добавляем эту функцию в тело метода: def greet(): String =&gt; Unit = (name: String) =&gt; println(s\"Hello, $name\") Поскольку метод возвращает функцию, мы получаем ее, вызывая greet(). val greetFunction = greet() // greetFunction: Function1[String, Unit] = repl.MdocSession$App$$Lambda$8359/0x00000001024c1040@5f6d68b5 Теперь можно вызвать greetFunction: greetFunction(\"Joe\") // Hello, Joe Доработка метода Метод greet() был бы более полезным, если бы была возможность задавать приветствие. Например, передать его в качестве параметра методу greet() и использовать внутри println: def greet(theGreeting: String): String =&gt; Unit = (name: String) =&gt; println(s\"$theGreeting, $name\") Теперь, при вызове этого метода, процесс становится более гибким, потому что приветствие можно изменить. Вот как это выглядит, когда создается функция из этого метода: val sayHello = greet(\"Hello\") // sayHello: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$8360/0x00000001024c2840@62656631 Выходные данные подписи типа показывают, что sayHello — это функция, которая принимает входной параметр String и возвращает Unit. Так что теперь, при передаче sayHello строки, печатается приветствие: sayHello(\"Joe\") // Hello, Joe Приветствие можно менять для создания новых функций: val sayCiao = greet(\"Ciao\") // sayCiao: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$8360/0x00000001024c2840@40e44d2e val sayHola = greet(\"Hola\") // sayHola: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$8360/0x00000001024c2840@49665462 sayCiao(\"Isabella\") // Ciao, Isabella sayHola(\"Carlos\") // Hola, Carlos Более реалистичный пример Этот метод может быть еще более полезным, когда возвращает одну из многих возможных функций, например, фабрику пользовательских функций. Например, представим, что необходимо написать метод, который возвращает функции, приветствующие людей на разных языках. Ограничим это функциями, которые приветствуют на английском или французском языках, в зависимости от параметра, переданного в метод. Созданный метод должен: принимать “желаемый язык” в качестве входных данных и возвращать функцию в качестве результата. Кроме того, поскольку эта функция печатает заданную строку, известно, что она имеет тип String =&gt; Unit. С помощью этой информации сигнатура метода должна выглядеть так: def createGreetingFunction(desiredLanguage: String): String =&gt; Unit = ??? Далее, поскольку возвращаемые функции, берут строку и печатают ее, можно прикинуть две анонимные функции для английского и французского языков: (name: String) =&gt; println(s\"Hello, $name\") (name: String) =&gt; println(s\"Bonjour, $name\") Для большей читабельности дадим этим анонимным функциям имена и назначим двум переменным: val englishGreeting = (name: String) =&gt; println(s\"Hello, $name\") val frenchGreeting = (name: String) =&gt; println(s\"Bonjour, $name\") Теперь все, что осталось, это вернуть englishGreeting, если desiredLanguage — английский, и вернуть frenchGreeting, если desiredLanguage — французский. Один из способов сделать это - pattern matching: def createGreetingFunction(desiredLanguage: String): String =&gt; Unit = val englishGreeting = (name: String) =&gt; println(s\"Hello, $name\") val frenchGreeting = (name: String) =&gt; println(s\"Bonjour, $name\") desiredLanguage match case \"english\" =&gt; englishGreeting case \"french\" =&gt; frenchGreeting Обратите внимание, что возврат значения функции из метода ничем не отличается от возврата строкового или целочисленного значения. Вот как createGreetingFunction создает функцию приветствия на французском языке: val greetInFrench = createGreetingFunction(\"french\") greetInFrench(\"Jonathan\") // Bonjour, Jonathan И вот как - на английском: val greetInEnglish = createGreetingFunction(\"english\") greetInEnglish(\"Joe\") // Hello, Joe References: Scala3 book"
    } ,    
    {
      "title": "Runtime Staging",
      "url": "/scalaworkbook/docs/metaprogramming/runtime-staging.html",
      "content": "Runtime Staging Фреймворк одновременно выражает метапрограммирование времени компиляции и многоэтапное программирование. Можно думать о метапрограммировании во время компиляции как о двухэтапном процессе компиляции: на первом пишется код в сплайсах верхнего уровня, который будет использоваться для генерации кода (макросы), и на втором выполняются все необходимые вычисления во время компиляции. И объектная программа, которая будет запускаться как обычно. Что, если бы можно было бы синтезировать код во время выполнения и предложить программисту ещё один дополнительный этап? Затем может быть значение типа Expr[T] во время выполнения, которое по существу можно рассматривать как типизированное синтаксическое дерево, доступное для показа в виде строки (красивая печать), либо скомпилировать и запустить. Если количество цитат превышает количество вставок более чем на единицу (эффективная обработка во время выполнения значений типа Expr[Expr[T]], Expr[Expr[Expr[T]]], …), то говорится о многоэтапном программировании. Мотивация этой парадигмы состоит в том, чтобы позволить информации времени выполнения влиять на генерацию кода или направлять ее. Интуиция: этап, на котором выполняется код, определяется разницей между количеством областей вставки и областей цитат, в которые он встроен. если сплайсов больше, чем кавычек, код запускается во время компиляции, т.е. как макрос. В общем случае это означает запуск интерпретатора, оценивающего код, представленный в виде типизированного абстрактного синтаксического дерева. Интерпретатор может вернуться к рефлексивным вызовам при оценке приложения ранее скомпилированного метода. Если превышение сплайсов больше одного, это будет означать, что код реализации макроса (в отличие от кода, в который он расширяется) вызывает другие макросы. Если макросы реализуются интерпретацией, это приведет к башням интерпретаторов, где первый интерпретатор сам будет интерпретировать код интерпретатора, который, возможно, интерпретирует другой интерпретатор и так далее. если количество сплайсов равно количеству кавычек, код компилируется и запускается как обычно. если количество кавычек превышает количество сплайсов, код поэтапный. То есть он создает типизированное абстрактное синтаксическое дерево или структуру типов во время выполнения. Превышение котировки более чем на единицу соответствует многоступенчатому программированию. Предоставление интерпретатора для полного языка довольно сложно, и еще сложнее заставить этот интерпретатор работать эффективно. Поэтому в настоящее время накладываются следующие ограничения на использование сплайсов. сращивание верхнего уровня должно отображаться во встроенном методе (превращая этот метод в макрос). сращивание должно вызывать ранее скомпилированный метод, передавая аргументы в кавычках, константные аргументы или встроенные аргументы. сращивания внутри сплайсов (но без промежуточных кавычек) не допускаются. API Платформа позволяет выполнять код поэтапно, т.е. быть готовым к выполнению на более позднем этапе. Для запуска этого кода в классе есть еще один метод в Expr с именем run. Обратите внимание, что $ и run обе преобразуют Expr[T] в T, но только $ подпадает под действие PCP, тогда как run - это обычный метод. scala.quoted.staging.run предоставляет Quotes, который можно использовать для отображения выражения в его области. С другой стороны scala.quoted.staging.withQuotes предоставляет Quotes без оценки выражения. package scala.quoted.staging def run[T](expr: Quotes ?=&gt; Expr[T])(using Compiler): T = ... def withQuotes[T](thunk: Quotes ?=&gt; T)(using Compiler): T = ... Создание нового проекта Scala 3 с включенным промежуточным размещением sbt new scala/scala3-staging.g8 Из scala/scala3-staging.g8. Создаст проект с необходимыми зависимостями и некоторыми примерами. Если предпочитаете создавать проект самостоятельно, обязательно определите следующую зависимость в определении сборки build.sbt. libraryDependencies += \"org.scala-lang\" %% \"scala3-staging\" % scalaVersion.value и если используете scalac/scala напрямую, используйте флаг -with-compiler для обоих: scalac -with-compiler -d out Test.scala scala -with-compiler -classpath out Test Пример Теперь возьмем точно такой же пример, как в макросах. Предположим, что мы не хотим передавать массив статически, а генерируем код во время выполнения и передаем значение также во время выполнения. Обратите внимание, как создается функция будущей стадии типа Expr[Array[Int] =&gt; Int] в строке 6. С помощью staging.run{ ... } можно оценить выражение во время выполнения. В рамках staging.run также можно вызвать show, чтобы получить исходное представление выражения. import scala.quoted.* // make available the necessary compiler for runtime code generation given staging.Compiler = staging.Compiler.make(getClass.getClassLoader) val f: Array[Int] =&gt; Int = staging.run { val stagedSum: Expr[Array[Int] =&gt; Int] = '{ (arr: Array[Int]) =&gt; ${sum('arr)}} println(stagedSum.show) // Prints \"(arr: Array[Int]) =&gt; { var sum = 0; ... }\" stagedSum } f.apply(Array(1, 2, 3)) // Returns 6 References: Scala 3 Reference"
    } ,    
    {
      "title": "Scaladoc",
      "url": "/scalaworkbook/docs/scaladoc.html",
      "content": "Scaladoc Scaladoc — это инструмент для создания API документации проектов Scala 3. Он предоставляет функции, аналогичные javadoc, а также jekyll или docusaurus. References: Scaladoc Guide"
    } ,    
    {
      "title": "Поиск по типу",
      "url": "/scalaworkbook/docs/scaladoc/search-engine.html",
      "content": "Поиск по типу Поиск функций по их символическим именам может занять много времени. Именно поэтому новый scaladoc позволяет искать методы и поля по их типам. Рассмотрим следующее определение метода расширения: extension [T](arr: IArray[T]) def span(p: T =&gt; Boolean): (IArray[T], IArray[T]) = ... Вместо поиска span также можно искать IArray[A] =&gt; (A =&gt; Boolean) =&gt; (IArray[A], IArray[A]). Чтобы использовать эту функцию, введите сигнатуру искомого элемента в строке поиска scaladoc. Вот как это работает: Эта функция предоставляется поисковой системой Inkuire, которая работает для Scala 3 и Kotlin. Чтобы быть в курсе развития этой функции, следите за репозиторием Inkuire. Примеры запросов Некоторые примеры запросов с предполагаемыми результатами: List[Int] =&gt; (Int =&gt; Long) =&gt; List[Long] -&gt; map Seq[A] =&gt; (A =&gt; B) =&gt; Seq[B] -&gt; map (A, B) =&gt; A -&gt; _1 Set[Long] =&gt; Long =&gt; Boolean -&gt; contains Int =&gt; Long =&gt; Int -&gt; const String =&gt; Int =&gt; Char -&gt; apply (Int &amp; Float) =&gt; (String | Double) -&gt; toDouble, toString F[A] =&gt; Int -&gt; length Синтаксис запроса Для того чтобы запрос панели поиска scaladoc выполнялся с использованием Inkuire вместо поисковой системы по умолчанию, запрос должен содержать последовательность символов =&gt;. Принятый ввод аналогичен сигнатуре каррированной функции в Scala 3. С некоторыми отличиями: AndTypes, OrTypes и Functions должны быть заключены в круглые скобки, например, (Int &amp; Any) =&gt; String поля и методы без параметров можно найти, указав перед их типом =&gt;, например, =&gt; Int Можно использовать подстановочный знак _, чтобы указать, что необходимо сопоставить любой тип в данном месте, например, Long =&gt; Double =&gt; _ Типы в виде одной буквы, например A, или буквы с цифрой X1, автоматически считаются переменными типа. Другие переменные типа могут быть объявлены так же, как и в полиморфных функциях, например [AVariable, AlsoAVariable] =&gt; AVariable =&gt; AlsoAVariable =&gt; AVariable Работа с псевдонимами типов и приемниками методов Когда дело доходит до того, как код сопоставляется с записями InkuireDb, есть некоторые преобразования, чтобы сделать движок более самостоятельным (хотя и открытым для предложений и изменений). Во-первых, получатель (не владелец модуля) функции может рассматриваться как первый аргумент. Также применяется автоматическое каррирование, чтобы результаты не зависели от списков аргументов. При поиске совпадений val и def не различаются. Итак, по запросу Num =&gt; Int =&gt; Int =&gt; Int должны быть найдены следующие объявления: class Num(): def a(i: Int, j: Int): Int def b(i: Int)(j: Int): Int def c(i: Int): (Int =&gt; Int) val d: Int =&gt; Int =&gt; Int val e: Int =&gt; Int =&gt; Int val f: (Int, Int) =&gt; Int end Num def g(i: Num, j: Int, k: Int): Int extension (i: Num) def h(j: Int, k: Int): Int def i(i: Num, j: Int)(k: Int): Int extension (i: Num) def j(j: Int)(k: Int): Int ... Когда дело доходит до псевдонимов типов, они обесцениваются как в объявлении, так и в подписи запроса. Это означает, что для объявлений: type Name = String def fromName(name: Name): String def fromString(str: String): Name оба метода fromName и fromString, должны быть найдены для запросов Name =&gt; Name, String =&gt; String, Name =&gt; String и String =&gt; Name. Как это работает Inkuire работает как рабочий JavaScript в браузере благодаря мощи ScalaJS. Чтобы включить Inkuire при запуске scaladoc, добавьте флаг -Ygenerate-inkuire. При добавлении этого флага создаются два файла: inkuire-db.json - это файл, содержащий все доступные для поиска объявления из текущего документированного проекта в формате, читаемом поисковой системой Inkuire. inkuire-config.json - этот файл содержит расположение файлов базы данных, которые должны быть доступны для поиска в документации текущего проекта. По умолчанию он будет сгенерирован с расположением локального файла базы данных, а также с подразумеваемыми по умолчанию расположениями файлов базы данных во внешних сопоставлениях -external-mappings. References: Scaladoc Guide"
    } ,      
    {
      "title": "Semigroup",
      "url": "/scalaworkbook/typeclass/monoid/semigroup.html",
      "content": "{{page.title}} (S, +) является полугруппой (semigroup) для множества S и операции +, если удовлетворяет следующим свойствам для любых x, y, z ∈ S: Closure (замыкание): x + y ∈ S Associativity (ассоциативность): (x + y) + z = x + (y + z) Также говорится, что S образует полугруппу относительно +. Примеры полугрупп Строки образуют полугруппу при конкатенации Реализации полугрупп в различных библиотеках References: Algebird"
    } ,    
    {
      "title": "Set",
      "url": "/scalaworkbook/docs/collections/set.html",
      "content": "Работа с множествами Множество (Set) - итерируемая коллекция без повторяющихся элементов. В Scala есть как изменяемые, так и неизменяемые типы Set. В этом разделе демонстрируется неизменяемое множество. Создание множества Создание нового пустого множества: val nums = Set[Int]() // nums: Set[Int] = Set() val letters = Set[Char]() // letters: Set[Char] = Set() Создание множества с исходными данными: val nums = Set(1, 2, 3, 3, 3) // nums: Set[Int] = Set(1, 2, 3) val letters = Set('a', 'b', 'c', 'c') // letters: Set[Char] = Set('a', 'b', 'c') Добавление элементов в множество В неизменяемое множество новые элементы добавляются с помощью + и ++, результат присваивается новой переменной: val a = Set(1, 2) // a: Set[Int] = Set(1, 2) val b = a + 3 // b: Set[Int] = Set(1, 2, 3) val c = b ++ Seq(4, 1, 5, 5) // c: Set[Int] = HashSet(5, 1, 2, 3, 4) Стоит отметить, что повторяющиеся элементы не добавляются в множество, а также, что порядок элементов произвольный. Удаление элементов из множества Элементы из множества удаляются с помощью методов - и --: val a = Set(1, 2, 3, 4, 5) // a: Set[Int] = HashSet(5, 1, 2, 3, 4) val b = a - 5 // b: Set[Int] = HashSet(1, 2, 3, 4) val c = b -- Seq(3, 4) // c: Set[Int] = HashSet(1, 2) References: Scala3 book Scala3 book, Collections Types Scala, Immutable collections Scala, Mutable collections"
    } ,    
    {
      "title": "Настройки",
      "url": "/scalaworkbook/docs/scaladoc/settings.html",
      "content": "{{page.title}} В этой главе перечислены параметры конфигурации, которые можно использовать при вызове scaladoc. Некоторую информацию, показанную здесь, можно получить, вызвав scaladoc с флагом -help. Изменения scaladoc по сравнению со Scala 2 Scaladoc был переписан с нуля, и некоторые функции оказались бесполезными в новом контексте. Текущее состояние совместимости со старыми флагами scaladoc можно увидеть здесь. Указание настроек Настройки scaladoc можно указывать в качестве аргументов командной строки, например, scaladoc -d output -project my-project target/scala-3.0.0-RC2/classes. При вызове из sbt, обновите значение Compile / doc / scalacOptions и Compile / doc / target соответственно, например Compile / doc / target := file(\"output\"), Compile / doc / scalacOptions ++= Seq(\"-project\", \"my-project\"), Обзор всех доступных настроек -project Название проекта. Чтобы обеспечить совместимость с псевдонимами Scala2 с -doc-title -project-version Текущая версия проекта, которая отображается в верхнем левом углу. Чтобы обеспечить совместимость с псевдонимами Scala2 с -doc-version -project-logo Логотип проекта, который появляется в верхнем левом углу. Чтобы обеспечить совместимость с псевдонимами Scala2 с -doc-logo -project-footer Строковое сообщение, которое отображается в разделе нижнего колонтитула. Чтобы обеспечить совместимость с псевдонимами Scala2 с -doc-footer -comment-syntax Язык стилей, используемый для разбора комментариев. В настоящее время поддерживается два синтаксиса: markdown или wiki. Если настройка отсутствует, по умолчанию - markdown. -revision Редакция (ветвь или ссылка), используемая для создания проекта. Полезно с исходными ссылками, чтобы они не всегда указывали на последний мастер, который может быть изменен. -source-links Ссылки на источники обеспечивают сопоставление между файлом в документации и репозиторием кода. Примеры исходных ссылок: -source-links:docs=github://lampepfl/dotty/master#docs Принимаемые форматы: &lt;sub-path&gt;=&lt;исходная-ссылка&gt; &lt;исходная-ссылка&gt; где &lt;ссылка-источник&gt; является одним из следующих: github://&lt;organization&gt;/&lt;repository&gt;[/revision][#subpath] будет соответствовать https://github.com/$organization/$repository/[blob|edit]/$revision[/$subpath]/$filePath[$lineNumber], если редакция не указана, тогда требуется указать редакцию в качестве аргумента для Scaladoc gitlab://&lt;organization&gt;/&lt;repository&gt; будет соответствовать https://gitlab.com/$organization/$repository/-/[blob|edit]/$revision[/$subpath]/$filePath[$lineNumber], если редакция не указана, тогда требуется, чтобы редакция была указана как аргумент в Scaladoc &lt;scaladoc-template&gt; &lt;scaladoc-template&gt; — это формат параметра doc-source-url из старого scaladoc. ПРИМЕЧАНИЕ. Поддерживаются только шаблоны €{FILE_PATH_EXT}, €{TPL_NAME}, €{FILE_EXT}, €{FILE_PATH} и €{FILE_LINE}. Шаблон может быть определен только подмножеством источников, определенных префиксом пути, представленным &lt;sub-path&gt;. В этом случае пути, используемые в шаблонах, будут относительными относительно &lt;sub-path&gt;. -external-mappings Сопоставление регулярных выражений, соответствующих записям пути к классам, и внешней документации. Пример внешнего сопоставления: -external-mappings:.*scala.*::scaladoc3::https://scala-lang.org/api/3.x/,.*java.*::javadoc::https://docs.oracle.com/javase/8/docs/api/ Отображение имеет вид &lt;regex&gt;::[scaladoc3|scaladoc|javadoc]::&lt;path&gt;. Можно указать несколько сопоставлений, разделенных запятыми, как показано в примере. -social-links Ссылки на социальные сети. Например: -social-links:github::https://github.com/lampepfl/dotty,discord::https://discord.com/invite/scala,twitter::https://twitter.com/scala_lang Допустимые значения имеют вид: [github|twitter|gitter|discord]::ссылка. Scaladoc также поддерживает custom::link::white_icon_name::black_icon_name. В этом случае иконки должны находиться в каталоге images/. -skip-by-id Идентификаторы пакетов или классов верхнего уровня, которые следует пропускать при создании документации. -skip-by-regex Регулярные выражения, соответствующие полным именам пакетов или классов верхнего уровня, которые следует пропускать при создании документации. -doc-root-content Файл, из которого следует импортировать документацию корневого пакета. -author Добавление авторов в строку документации @author Name Surname по умолчанию не будет включено в сгенерированную html-документацию. Если необходимо явно пометить классы авторами, scaladoc запускается с данным флагом. -groups Группировка похожих функций вместе (на основе аннотации @group) -private Показать все типы и члены. Если параметр не указан, показывать только public и protected типы и члены. -doc-canonical-base-url Базовый URL-адрес для использования в качестве префикса и добавления canonical URL-адресов на все страницы. Канонический URL-адрес может использоваться поисковыми системами для выбора URL-адреса, который вы хотите, чтобы люди видели в результатах поиска. Если не установлено, канонические URL-адреса не генерируются. -siteroot Каталог, содержащий статические файлы, из которых создается документация. Каталог по умолчанию - ./docs -no-link-warnings Подавить предупреждения для двусмысленных или невалидных ссылок. Не влияет на предупреждения о некорректных ссылках ресурсов и т. д. -versions-dictionary-url URL-адрес, указывающий на документ JSON, содержащий словарь: version label -&gt; documentation location. Файл JSON имеет единственное свойство versions, которое содержит словарь, связывающий метки определенных версий документации с URL-адресами, указывающими на их index.html. Полезно для библиотек, которые поддерживают разные версии документации. Пример JSON-файла: { \"versions\": { \"3.0.x\": \"https://dotty.epfl.ch/3.0.x/docs/index.html\", \"Nightly\": \"https://dotty.epfl.ch/docs/index.html\" } } -snippet-compiler Аргументы компилятора сниппета позволяют настроить проверку типа сниппета. Этот параметр принимает список аргументов в формате: args := arg{,args} arg := [path=]flag, где path - префикс пути к исходным файлам, в которых находятся сниппеты, и flag - режим проверки типов. Если path отсутствует, аргумент будет использоваться по умолчанию для всех несопоставленных путей. Доступные флаги: compile — включает проверку фрагментов. nocompile — отключает проверку сниппетов. fail — включает проверку сниппета, утверждает, что сниппет не компилируется. Флаг fail удобен для фрагментов, которые показывают, что какое-то действие в конечном итоге завершится ошибкой во время компиляции. Пример использования: -snippet-compiler:my/path/nc=nocompile,my/path/f=fail,compile Что значит: все фрагменты в файлах в каталоге my/path/nc вообще не должны рассматриваться снипеттом все фрагменты в файлах в каталоге my/path/f не должны компилироваться во время компиляции все остальные фрагменты должны компилироваться успешно -Ysnippet-compiler-debug Установка этого параметра заставляет компилятор сниппета печатать сниппет по мере его компиляции (после упаковки). -Ydocument-synthetic-types Включение в документацию страниц с документацией по встроенным типам (например, Any, Nothing). Этот параметр полезен только для stdlib, поскольку scaladoc для Scala 3 использует файлы TASTy. Все остальные пользователи не должны касаться этой настройки. References: Scaladoc Guide"
    } ,    
    {
      "title": "Версионность",
      "url": "/scalaworkbook/docs/scaladoc/site-versioning.html",
      "content": "Версионность сайта Scaladoc предоставляет удобный способ переключения между различными версиями документации. Эта функция полезна, если желательно предоставить старые документы пользователям, которые не перешли на новую версию библиотеки. Как это настроить Эта функция была разработана для легкой масштабируемости без необходимости повторного создания всех scaladocs после добавления новой версии. Для этого вводится новая настройка: -versions-dictionary-url. Его аргумент должен быть URL-адресом документа JSON, содержащего информацию о расположении конкретных версий. Файл JSON должен содержать свойство versions со словарём, связывающий метки определенных версий документации с URL-адресами, указывающими на их index.html. Пример JSON-файла: { \"versions\": { \"3.0.x\": \"https://dotty.epfl.ch/3.0.x/docs/index.html\", \"Nightly\": \"https://dotty.epfl.ch/docs/index.html\" } } Такие документы необходимо указывать для каждой из версий, однако позже это дает больше гибкости. Если необходимо добавить версию документов API рядом с предыдущими 5 версиями, которые уже опубликованы, нужно только загрузить новые документы на веб-сервер и добавить новую запись в файл JSON. Все версии сайта теперь узнают о новой версии. Важно отметить, что существует только один файл JSON, чтобы избежать избыточности, и каждый scaladoc должен заранее настроить свой URL-адрес, например, в sbt: doc / scalacOptions ++= Seq(\"-versions-dictionary-url\", \"https://dotty.epfl.ch/versions.json\") Как это выглядит с точки зрения пользователя Предоставление файла JSON через -versions-dictionary-url позволяет scaladoc связывать версии. Также удобно иметь возможность изменить метку ревизии в выпадающем меню. Все изменится автоматически. References: Scaladoc Guide"
    } ,    
    {
      "title": "Проверка фрагмента",
      "url": "/scalaworkbook/docs/scaladoc/snippet-compiler.html",
      "content": "{{page.title}} Основная функциональность документации — помочь пользователям понять и правильно использовать проект. Иногда часть проекта нуждается в нескольких словах, чтобы показать ее использование, но бывают моменты, когда описания недостаточно, и нет ничего лучше, чем подробный пример. Удобный способ предоставления примеров в документации — создание фрагментов кода, представляющих использование заданной функциональности. Проблема фрагментов кода в том, что одновременно с разработкой проекта их нужно обновлять. Иногда изменения в одной части проекта могут нарушить работу примеров в других частях. Количество фрагментов и количество времени, прошедшего с момента их написания, не позволяет запомнить каждое место, где нужно их исправить. Через какое-то время наступает понимание, что документация — полный бардак и нужно пройтись по всем примерам и переписать их. Многие проекты Scala 2 используют markdown документацию с проверкой типов с помощью tut или mdoc. Почти все хотя бы слышали об этих инструментах. Поскольку они оказались очень полезными и сообщество Scala их успешно приняло, планируется включить функции tut и mdoc в компилятор, чтобы он был готов к включению в Scaladoc. Начало работы По умолчанию проверка фрагментов отключена. Её можно включить, добавив в Scaladoc следующий аргумент -snippet-compiler:compile Например, в sbt конфигурация выглядит так: Compile / doc / scalacOptions ++= Seq(\"-snippet-compiler:compile\") Эта опция включает компилятор сниппетов для всех scala сниппетов в проектной документации и распознает все сниппеты внутри ``` блоков scala. В настоящее время проверка фрагментов работает как в строках документации, написанных в Markdown, так и на статических сайтах. Для нового проекта этой конфигурации должно хватить. Однако, если вы переносите существующий проект, можно отключить компиляцию для некоторых фрагментов, которые в настоящее время не могут быть обновлены. Для этого добавьте nocompile флаг прямо в scala сниппет: ```scala sc:nocompile // under the hood `map` is transformed into List(1).map( _ + 1)(&lt;implicits&gt;) ``` Однако иногда сбой компиляции является преднамеренным поведением, например, для демонстрации ошибки. В этом случае выставляется флаг fail, который представляет одну из функций: Assert compilation errors. ```scala sc:fail List(1,2,3).toMap ``` Обзор функций Assert compilation errors Scala — это язык программирования со статической типизацией. Иногда в документации должны упоминаться случаи, когда код не должен компилироваться, или авторы хотят предоставить способы восстановления после определенных ошибок компиляции. Например, этот код: List(1,2,3).toMap приводит к результату: At 18:21: List(1,2,3).toMap Error: Cannot prove that Int &lt;:&lt; (K, V) where: K is a type variable with constraint V is a type variable with constraint . Примеры, представляющие код, который дает сбой во время компиляции, могут быть очень важными. Например, можно показать, как библиотека защищена от неправильного кода. Другой вариант использования — представить распространенные ошибки и способы их решения. Принимая во внимание эти варианты использования, предоставляется функция проверки того, компилируются ли отмеченные фрагменты кода. Для фрагментов кода, которые намеренно не компилируются, например следующего, добавьте флаг fail во фрагмент кода: ```scala sc:fail List(1,2,3).toMap ``` Проверка фрагмента проходит успешно и показывает ожидаемые ошибки компиляции в документации. Для фрагмента, который компилируется без ошибок: ```scala sc:fail List((1,2), (2,3)).toMap ``` результирующий вывод выглядит следующим образом: In static site (./docs/docs/index.md): Error: Snippet should not compile but compiled succesfully Контекст В Scaladoc внедрён механизм переноса, предоставляющий контекст для каждого фрагмента. Эта предварительная обработка выполняется автоматически для всех фрагментов в строках документации. Например, предположим, что необходимо задокументировать метод slice в файле collection.List для того, чтобы объяснить, как он работает, сравнив его с комбинацией методов drop и take, используя такой фрагмент кода: slice(2, 5) == drop(2).take(3) Показ этого примера — одна из первых вещей, которые приходят на ум, но он не скомпилируется без функции контекста. Помимо основной цели, это уменьшает шаблон фрагмента, потому что не нужно импортировать элементы одного и того же пакета и создавать экземпляры документированного класса. Фрагмент кода после предварительной обработки выглядит так: package scala.collection trait Snippet[A] { self: List[A] =&gt; slice(2,5) == drop(2).take(3) } Скрытие кода Несмотря на наличие контекстной функции, описанной выше, иногда автору необходимо предоставить больше элементов для области действия. Однако, с одной стороны, большой блок импортов и инициализаций необходимых классов может привести к потере читабельности. Но с другой стороны, хотелось бы иметь возможность видеть весь код. Для второго случая введен специальный синтаксис для сниппетов, который скрывает определенные фрагменты import кода — операторы, например, — но также позволяет расширить этот код в документации одним щелчком мыши. Пример: //{ import scala.collection.immutable.List //} val intList: List[Int] = List(1, 2, 3) Snippet includes При написании фрагментов кода часто требуется механизм повторного использования кода из одного фрагмента в другом. Например, взгляните на следующий фрагмент документации: Чтобы успешно скомпилировать последний фрагмент, нужно иметь ранее объявленные определения в области видимости. Для этого сценария — и, возможно, для многих других — добавлена новая функция: включение сниппета. Она позволяет повторно использовать код из одного фрагмента в другом, что снижает избыточность и повышает удобство сопровождения. Чтобы настроить это, добавьте аргумент sc-name к фрагменту, который необходимо включить в более поздний блок кода: ```scala sc-name:&lt;snippet-name&gt; где snippet-name должен быть уникальным в пределах файла и не может содержать пробелы и запятые. Затем в более позднем блоке кода в документации используйте аргумент sc-compile-with во scala фрагменте, который должен “включать” предыдущий блок кода: ```scala sc-compile-with:&lt;snippet-name&gt;(,&lt;snippet-name&gt;)+ где snippet-name - имя фрагмента, который должен быть включен. После настройки этой функции в примере код выглядит так: и вывод выглядит так: Можно указать более одного включения. Обратите внимание, что порядок, в котором они указаны, определяет порядок включения. можно включать только фрагменты, определенные над целевым фрагментом. Расширенная конфигурация Часто включение проверки фрагментов для всех фрагментов не является желаемым уровнем контроля, поскольку варианты использования могут быть более сложными. Для таких ситуаций подготовлен инструмент, чтобы пользователи могли настроить его под свои нужды. Доступные флаги Чтобы обеспечить больший контроль, компилятор фрагмента предоставляет три флага, которые позволяют изменить его поведение: compile - включает проверку сниппетов nocompile - отключает проверку сниппетов fail - включает проверку сниппета с подтверждением ошибки компиляции Настройки на основе пути Для большей гибкости вместо установки одного флага для управления всеми сниппетами в проекте его можно установить только для определенного пути, добавив префикс &lt;path&gt;= перед флагом. Например: -snippet-compiler:docs=compile - устанавливает флаг compile для сниппетов в docs. Если docs - это каталог, флаг устанавливается для всех файлов внутри docs. Кроме того, -snippet-compiler может управляться более чем одним параметром, при этом параметры разделяются запятыми. Например: -snippet-compiler:docs=compile,library/src=compile,library/src/scala/quoted=nocompile,library/src/scala/compiletime=fail Флаги выбираются по самому длинному совпадению префикса, поэтому можно определить общую настройку, а затем изменить это поведение по умолчанию для более конкретных путей. -snippet-compiler:compile,library/src/scala/quoted=nocompile,library/src/scala/compiletime=fail Флаг без префикса пути, такой как флаг compile в этом примере, считается значением по умолчанию. Переопределение прямо во фрагменте Аргументы CLI — хороший механизм для установки флагов для определенных файлов. Однако этот подход нельзя использовать для настройки определенных фрагментов. Допустим, необходимо написать один фрагмент кода, который должен потерпеть неудачу, и другие фрагменты, которые должны скомпилироваться. Эти аргументы находятся в информационной части сниппета: ```scala &lt;snippet-compiler-args&gt; // snippet ``` Например, чтобы настроить проверку для определенного фрагмента, добавьте следующий аргумент в его информационную часть фрагмента, где flag - один из доступных флагов, перечисленных выше (например, compile, nocompile или fail): sc:&lt;flag&gt; В качестве конкретного примера этот код показывает, как использовать флаг fail в отдельном фрагменте: ```scala sc:fail val itShouldFail: Int = List(1.1, 2, 3).head ``` References: Scaladoc Guide"
    } ,    
    {
      "title": "Soft Keywords",
      "url": "/scalaworkbook/docs/soft-keywords.html",
      "content": "{{page.title}} Мягкий модификатор (soft modifier) — это один из идентификаторов infix, inline, opaque, open и transparent. Мягкое ключевое слово (soft keyword) — это мягкий модификатор или один из as, derives, end, extension, throws, using, |, +, -, *. Мягкий модификатор рассматривается как потенциальный модификатор определения, если за ним следует жесткий модификатор или комбинация ключевых слов, начинающаяся с определения (def, val, var, type, given, class, trait, object, enum, case class, case object). Между двумя словами может быть последовательность токенов новой строки и мягких модификаторов. В противном случае мягкие ключевые слова обрабатываются особым образом в следующих ситуациях: inline, если за ним следует любой токен, который может начать выражение. derives, если оно появляется после предложения расширения или после имени и, возможно, параметров класса, trait, объекта или enum. end, если он появляется в начале строки, следующей за оператором (т.е. определением или выражением верхнего уровня). extension, если оно появляется в начале инструкции и сопровождается ( или [. using, если он появляется в начале списка параметров или аргументов. as, в предложении переименования импорта. |, если он разделяет два шаблона в альтернативе. +, -, если они появляются перед параметром типа. *, в импорте с подстановочными знаками, или он следует за типом параметра, или если он появляется в соединении vararg x*. В других местах мягкое ключевое слово рассматривается как обычный идентификатор. References: Scala 3 Reference"
    } ,    
    {
      "title": "Статика",
      "url": "/scalaworkbook/docs/scaladoc/static-site.html",
      "content": "Статическая документация Scaladoc умеет генерировать статические сайты, известные по Jekyll или Docusaurus. Наличие комбинированного инструмента позволяет обеспечить взаимодействие между статической документацией и API, что позволяет им естественным образом сочетаться. Создать сайт так же просто, как и в Jekyll. Корень сайта содержит макет сайта, и все файлы, размещенные там, будут либо считаться статическими, либо обрабатываться для расширения шаблона. Файлы, которые рассматриваются для расширения шаблона, должны заканчиваться на *.{html,md} и в дальнейшем будут называться “файлами шаблонов” или “шаблонами”. Простой сайт “Hello World” может выглядеть примерно так: . └── &lt;site-root&gt;/ └── _docs/ ├── index.html └── getting-started.html Что даст сайт со следующими файлами в сгенерированной документации: index.html getting-started.html Scaladoc может преобразовывать как файлы, так и каталоги (чтобы организовать документацию в древовидную структуру). По умолчанию каталоги имеют заголовок, основанный на имени файла, и имеют пустое содержимое. Можно предоставить индексные страницы для каждого раздела, создав index.html или index.md (но не одновременно) в выделенном каталоге. Характеристики Scaladoc использует механизм шаблонов Liquid и предоставляет несколько настраиваемых фильтров и тегов, характерных для документации Scala. В Scaladoc все шаблоны могут содержать вступительную часть YAML. Передняя часть анализируется и помещается в переменную page, доступную в шаблонах через Liquid. Пример вступительной статьи: --- title: My custom title --- Scaladoc использует некоторые предопределенные свойства для управления аспектами страницы. Предустановленные свойства: title обеспечивает заголовок страницы, который будет использоваться в навигации и метаданных HTML. extraCss - дополнительные файлы .css, которые будут включены в эту страницу. Пути должны указываться относительно корня документации. Этот параметр не экспортируется в механизм шаблонов. extraJs - дополнительные файлы .js, которые будут включены в эту страницу. Пути должны указываться относительно корня документации. Этот параметр не экспортируется в механизм шаблонов. hasFrame - если установлено значение false, страница не будет включать макет по умолчанию (навигацию, breadcrumbs и т.д.), а только токен-оболочку HTML для предоставления метаданных и ресурсов (файлы js и css). Этот параметр не экспортируется в механизм шаблонов. layout - предопределенный макет для использования, см. ниже. Этот параметр не экспортируется в механизм шаблонов. Использование существующих шаблонов и макетов Чтобы выполнить расширение шаблона, Dottydoc просматривает поле layout во вступительной части. Вот простой пример системы шаблонов в действии index.html: --- layout: main --- &lt;h1&gt;Hello world!&lt;/h1&gt; С таким простым основным шаблоном, как этот: &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {\\{ content }} &lt;/body&gt; &lt;/html&gt; content будет заменен на &lt;h1&gt;Hello world!&lt;/h1&gt; в файле index.html. Макеты должны быть размещены в каталоге _layouts в корне сайта: ├── _layouts │ └── main.html └── _docs ├── getting-started.md └── index.html Ресурсы Чтобы рендерить ассеты вместе со статическим сайтом, их нужно поместить в директорию _assets в корне сайта: ├── _assets │ └── images │ └── myimage.png └── _docs └── getting-started.md Чтобы сослаться на ресурс на странице, необходимо создать ссылку относительно каталога _assets. Take a look at the following image: [My image](images/myimage.png) Боковая панель По умолчанию Scaladoc отображает структуру каталогов из каталога _docs на визуализируемом сайте. Существует также возможность переопределить его, предоставив файл sidebar.yml в корневом каталоге сайта. Конфигурационный файл YAML описывает структуру отображаемого статического сайта и оглавление: index: index.html subsection: - title: Usage index: usage/index.html directory: usage subsection: - title: Dottydoc page: usage/dottydoc.html hidden: false - title: sbt-projects page: usage/sbt-projects.html hidden: false Корневой элемент должен быть subsection. Вложенные подразделы приведут к древовидной структуре навигации. Свойства subsection: title - Необязательная строка - заголовок подраздела по умолчанию. Вступительные заголовки имеют более высокий приоритет. index - Необязательная строка - Путь к индексной странице подраздела. Путь указан относительно каталога _docs. directory - Необязательная строка - Имя каталога, в котором будет находиться подраздел сгенерированного сайта. По умолчанию именем каталога является имя подраздела, преобразованное в kebab case. subsection - Массив subsection или page. Либо index, либо subsection должны быть определены. Подраздел, определенный с index и без subsection, будет содержать страницы и каталоги, загружаемые рекурсивно из каталога индексной страницы. Свойства page: title - Необязательная строка - заголовок страницы по умолчанию. Вступительные заголовки имеют более высокий приоритет. page - Строка - Путь к странице относительно каталога _docs. hidden - Необязательное логическое значение. Флаг, указывающий, должна ли страница отображаться на боковой панели навигации. По умолчанию установлено значение false. Все пути в файле конфигурации YAML относятся к &lt;static-root&gt;/_docs. Иерархия title Если заголовок указан несколько раз, приоритет будет следующим (от высшего к низшему приоритету): Страница title из front-matter файла markdown/html title свойство из sidebar.yml свойства имя файла Подраздел title из front-matter индексного файла markdown/html title свойство из sidebar.yml свойства имя файла Обратите внимание, что если пропустить index файл в древовидной структуре или не указать title во вступительной части, ему будет присвоено общее имя index. То же самое относится к использованию sidebar.yml, но не указанию ни title, ни index, а только подраздела. Снова появится общее имя index. Блог Функция блога описана в отдельном документе. Расширенная конфигурация Полная структура корня сайта . └── &lt;site-root&gt;/ ├── _layouts/ │ └── ... ├── _docs/ │ └── ... ├── _blog/ │ ├── index.md │ └── _posts/ │ └── ... └── _assets/ ├── js/ │ └── ... ├── img/ │ └── ... └── ... В результате получается статический сайт, содержащий документы, а также блог. Он также содержит пользовательские макеты и ассеты. Структура визуализируемой документации может быть основана на файловой системе, но также может быть переопределена конфигурацией YAML. Структура каталогов сопоставления Используя файл конфигурации YAML, можно определить, как структура исходного каталога должна быть преобразована в структуру выходного каталога. Взглянем на следующее определение подраздела: - title: Some other subsection index: abc/index.html directory: custom-directory subsection: - page: abc2/page1.md - page: foo/page2.md В этом подразделе показана возможность конфигурации YAML отображать структуру каталогов. Несмотря на то, что индексная страница и все определенные дочерние элементы находятся в разных каталогах, они будут рендериться в custom-directory. Исходная страница abc/index.html будет генерировать страницу custom-directory/index.html, исходная страница abc2/page1.md - custom-directory/page1.html, а исходная страница foo/page2.md - custom-directory/page2.html. Пример Пример сгенеренного с помощью Scaladoc статического сайта References: Scaladoc Guide"
    } ,    
    {
      "title": "Структуры управления",
      "url": "/scalaworkbook/docs/structures.html",
      "content": "{{page.title}} В Scala есть все ожидаемые структуры управления, в том числе: if/then/else циклы for циклы while try/catch/finally Здесь также есть две другие мощные конструкции, присутствующие не во всех языках программирования: for выражения (также известные как for comprehensions) match выражения if/else Однострочное if выражение выглядит так: val x = 1 if x == 1 then println(x) // 1 Когда необходимо выполнить несколько строк кода после if, используется синтаксис: if x == 1 then println(\"x is 1, as you can see:\") println(x) // x is 1, as you can see: // 1 if/else синтаксис выглядит так: if x == 1 then println(\"x is 1, as you can see:\") println(x) else println(\"x was not 1\") // x is 1, as you can see: // 1 if/else if/else выглядит так же, как и в других языках: def detect(x: Int) = if x &lt; 0 then println(\"negative\") else if x == 0 then println(\"zero\") else println(\"positive\") detect(-1) // negative detect(0) // zero detect(1) // positive При желании можно дополнительно включить оператор end if в конце каждого выражения: if x == 1 then println(\"x is 1, as you can see:\") println(x) end if if/else выражение всегда возвращает результат Сравнения if/else образуют выражения - это означает, что они возвращают значение, которое можно присвоить переменной. Поэтому нет необходимости в специальном тернарном операторе. Пример: val minValue = if a &lt; b then a else b Можно использовать if/else выражение в качестве тела метода: def compare(a: Int, b: Int): Int = if a &lt; b then -1 else if a == b then 0 else 1 Как будет видно дальше, все структуры управления Scala можно использовать в качестве выражений. Программирование, ориентированное на выражения (expression-oriented programming или EOP) - стиль разработки, когда каждое написанное выражение возвращает значение. И наоборот, строки кода, которые не возвращают значения, называются операторами или утверждениями и используются для получения побочных эффектов. По мере погружения в Scala можно обнаружить, что пишется больше выражений и меньше утверждений. for loops В самом простом случае цикл for в Scala можно использовать для перебора элементов в коллекции. Например, имея последовательность целых чисел, можно перебрать ее элементы и вывести значения следующим образом: val ints = List(1, 2, 3, 4, 5) for i &lt;- ints do println(i) // 1 // 2 // 3 // 4 // 5 Код i &lt;- ints называется генератором. Если необходим многострочный блок кода после генератора for, используется следующий синтаксис: for i &lt;- ints do val x = i * 2 println(s\"i = $i, x = $x\") // i = 1, x = 2 // i = 2, x = 4 // i = 3, x = 6 // i = 4, x = 8 // i = 5, x = 10 Несколько генераторов В цикле for можно использовать несколько генераторов, например: for i &lt;- 1 to 2 j &lt;- 'a' to 'b' k &lt;- 1 to 10 by 5 do println(s\"i = $i, j = $j, k = $k\") // i = 1, j = a, k = 1 // i = 1, j = a, k = 6 // i = 1, j = b, k = 1 // i = 1, j = b, k = 6 // i = 2, j = a, k = 1 // i = 2, j = a, k = 6 // i = 2, j = b, k = 1 // i = 2, j = b, k = 6 Guards Циклы for также могут содержать условия, называемые guards: for i &lt;- 1 to 5 if i % 2 == 0 do println(i) // 2 // 4 Можно добавлять столько условий, сколько необходимо: for i &lt;- 1 to 10 if i &gt; 3 if i &lt; 6 if i % 2 == 0 do println(i) // 4 Использование for с Map-ами Циклы for можно использовать с Map-ами. Например, если есть карта ключ/значение: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AR\" -&gt; \"Arizona\" ) Можно обойти все пары ключ/значение так: for (abbrev, fullName) &lt;- states do println(s\"$abbrev: $fullName\") // AK: Alaska // AL: Alabama // AR: Arizona Когда цикл for перебирает Map, каждая пара ключ/значение привязывается к переменным abbrev и fullName. По мере выполнения цикла переменная abbrev принимает значение текущего ключа, а переменная fullName - соответствующему ключу значению. for expressions В предыдущих примерах все циклы for использовались для побочных эффектов, в частности, для вывода результата в STDOUT с помощью println. Важно знать, что for также можно использовать для выражений, возвращающих значения. Для этого for создается с ключевым словом yield вместо do и возвращаемым выражением, например: val list = for i &lt;- 10 to 12 yield i * 2 // list: IndexedSeq[Int] = Vector(20, 22, 24) После присваивания list содержит Vector с отображаемыми значениями. Вот как работает это выражение: Выражение for начинает перебирать значения в диапазоне (10, 11, 12). Сначала оно работает со значением 10, умножает его на 2, затем выдает результат - 20. Далее берет 11 — второе значение в диапазоне. Умножает его на 2, а затем выдает значение 22. Можно представить эти полученные значения как накопление во временном хранилище. Наконец, цикл берет число 12 из диапазона, умножает его на 2, получая число 24. Цикл завершается в этой точке и выдает конечный результат - (20, 22, 24). В данном случае показанное выражение for эквивалентно вызову метода map: val list = (10 to 12).map(i =&gt; i * 2) // list: IndexedSeq[Int] = Vector(20, 22, 24) Выражения for можно использовать всегда, когда нужно обойти все элементы в коллекции и применить алгоритм к этим элементам для создания нового списка. Вот пример, который показывает, как использовать блок кода после yield: val names = List(\"_olivia\", \"_walter\", \"_peter\") // names: List[String] = List(\"_olivia\", \"_walter\", \"_peter\") val capNames = for name &lt;- names yield val nameWithoutUnderscore = name.drop(1) val capName = nameWithoutUnderscore.capitalize capName // capNames: List[String] = List(\"Olivia\", \"Walter\", \"Peter\") Поскольку выражение for возвращает результат, его можно использовать в качестве тела метода. Пример: def between3and10(xs: List[Int]): List[Int] = for x &lt;- xs if x &gt;= 3 if x &lt;= 10 yield x between3and10(List(1, 3, 7, 11)) // res15: List[Int] = List(3, 7) while loops Цикл while имеет следующий синтаксис: var x = 1 // x: Int = 1 while x &lt; 3 do println(x) x += 1 // 1 // 2 В Scala не приветствуется использование изменяемых переменных var, поэтому следует избегать while. Аналогичный результат можно достигнуть используя вспомогательный метод: def loop(x: Int): Unit = if x &lt; 3 then println(x) loop(x + 1) loop(1) match expressions Сопоставление с образцом (pattern matching) является основой функциональных языков программирования, и Scala включает в себя pattern matching, обладающий множеством возможностей. В самом простом случае можно использовать выражение match, подобное оператору Java switch, сопоставляя на основе целочисленного значения. Как и предыдущие структуры, pattern matching - это действительно выражение, поскольку оно вычисляет результат: import scala.annotation.switch val i = 6 // i: Int = 6 val day = (i: @switch) match case 0 =&gt; \"Sunday\" case 1 =&gt; \"Monday\" case 2 =&gt; \"Tuesday\" case 3 =&gt; \"Wednesday\" case 4 =&gt; \"Thursday\" case 5 =&gt; \"Friday\" case 6 =&gt; \"Saturday\" case _ =&gt; \"invalid day\" // day: String = \"Saturday\" В примере выше переменная i сопоставляется с числом и если равна от 0 до 6, то в day возвращается день недели. Иной случай обозначается символом _ и если i не равен от 0 до 6, то возвращается значение invalid day. При написании простых выражений соответствия, подобных этому, рекомендуется использовать аннотацию @switch для переменной i. Эта аннотация содержит предупреждение во время компиляции, если switch не может быть скомпилирован в tableswitch или lookupswitch, которые лучше подходят с точки зрения производительности. Значение по умолчанию Когда нужно получить доступ к универсальному значению по умолчанию в pattern matching, достаточно указать имя переменной в левой части оператора case, а затем использовать это имя в правой части оператора: i match case 0 =&gt; println(\"1\") case 1 =&gt; println(\"2\") case what =&gt; println(s\"Получено значение: $what\" ) // Получено значение: 6 Переменной можно дать любое допустимое имя. Можно также использовать _ в качестве имени, чтобы игнорировать значение. Обработка нескольких возможных значений в одной строке В этом примере показано, как использовать несколько возможных совпадений с образцом в каждом операторе case: val evenOrOdd = i match case 1 | 3 | 5 | 7 | 9 =&gt; println(\"odd\") case 2 | 4 | 6 | 8 | 10 =&gt; println(\"even\") case _ =&gt; println(\"some other number\") // even Использование if в pattern matching В pattern matching можно использовать условия: i match case 1 =&gt; println(\"one, a lonely number\") case x if x == 2 || x == 3 =&gt; println(\"two’s company, three’s a crowd\") case x if x &gt; 3 =&gt; println(\"4+, that’s a party\") case _ =&gt; println(\"i’m guessing your number is zero or less\") // 4+, that’s a party Ещё пример: i match case a if 0 to 9 contains a =&gt; println(s\"0-9 range: $a\") case b if 10 to 19 contains b =&gt; println(s\"10-19 range: $b\") case c if 20 to 29 contains c =&gt; println(s\"20-29 range: $c\") case _ =&gt; println(\"Hmmm...\") // 0-9 range: 6 case classes и выражение match Также можно извлекать поля из case class-ов — и классов, которые имеют правильно написанные методы apply/unapply — и использовать их в pattern matching. Вот пример использования простого case class Person case class Person(name: String) def speak(p: Person) = p match case Person(name) if name == \"Fred\" =&gt; println(s\"$name says, Yubba dubba doo\") case Person(name) if name == \"Bam Bam\" =&gt; println(s\"$name says, Bam bam!\") case _ =&gt; println(\"Watch the Flintstones!\") speak(Person(\"Fred\")) // Fred says, Yubba dubba doo speak(Person(\"Bam Bam\")) // Bam Bam says, Bam bam! speak(Person(\"Wilma\")) // Watch the Flintstones! Использование выражения match в теле метода Поскольку выражения match возвращают значение, их можно использовать в теле метода. Этот метод принимает значение Matchable в качестве входного параметра и возвращает логическое значение на основе результата выражения соответствия: def isTruthy(a: Matchable) = a match case 0 | \"\" | false =&gt; false case _ =&gt; true Входной параметр a определяется как тип Matchable, который является родителем всех типов Scala. Для Matchable может выполняться сопоставление с образцом. Метод реализуется путем сопоставления входных данных, обеспечивая два случая: первый проверяет, является ли заданное значение целым числом 0, пустой строкой или false, и в этом случае возвращает false. Для иных случаев возвращается значение true. Эти примеры показывают, как работает метод: isTruthy(0) // res23: Boolean = false isTruthy(false) // res24: Boolean = false isTruthy(\"\") // res25: Boolean = false isTruthy(1) // res26: Boolean = true isTruthy(\" \") // res27: Boolean = true isTruthy(2F) // res28: Boolean = true Использование pattern matching в качестве тела метода очень распространено. Использование различных шаблонов в pattern matching Для выражения match можно использовать множество различных шаблонов. Например: Сравнение с константой (case 3 =&gt;) Сравнение с последовательностями (case List(els : _*) =&gt;) Сравнение с кортежами (case (x, y) =&gt;) Сравнение с конструктором класса (case Person(first, last) =&gt;) Сравнение по типу (case p: Person =&gt;) Все эти виды шаблонов показаны в следующем примере: def pattern(x: Matchable): String = x match // Сравнение с константой case 0 =&gt; \"ноль\" case true =&gt; \"true\" case \"hello\" =&gt; \"строка 'hello'\" case Nil =&gt; \"пустой List\" // Сравнение с последовательностями case List(0, _, _) =&gt; \"список из 3 элементов с 0 в качестве первого элемента\" case List(1, _*) =&gt; \"Непустой список, начинающийся с 1, и имеющий любой размер &gt; 0\" case Vector(1, _*) =&gt; \"Vector, начинающийся с 1, и имеющий любой размер &gt; 0\" // Сравнение с кортежами case (a, b) =&gt; s\"получено $a и $b\" case (a, b, c) =&gt; s\"получено $a, $b и $c\" // Сравнение с конструктором класса case Person(first, \"Alexander\") =&gt; s\"Alexander, first name = $first\" case Dog(\"Zeus\") =&gt; \"Собака с именем Zeus\" // Сравнение по типу case s: String =&gt; s\"получена строка: $s\" case i: Int =&gt; s\"получено число: $i\" case f: Float =&gt; s\"получено число с плавающей точкой: $f\" case a: Array[Int] =&gt; s\"массив чисел: ${a.mkString(\",\")}\" case as: Array[String] =&gt; s\"массив строк: ${as.mkString(\",\")}\" case d: Dog =&gt; s\"Экземпляр класса Dog: ${d.name}\" case list: List[?] =&gt; s\"получен List: $list\" case m: Map[?, ?] =&gt; m.toString // Сравнение по умолчанию case _ =&gt; \"Unknown\" Дополнительные возможности выражений match match выражения могут быть объединены в цепочку: def chain(xs: List[Int]) = xs match case Nil =&gt; \"empty\" case _ =&gt; \"nonempty\" match case \"empty\" =&gt; 0 case \"nonempty\" =&gt; 1 chain(List.empty[Int]) // res30: Int = 0 chain(List(1, 2, 3)) // res31: Int = 1 try/catch/finally Как и в Java, в Scala есть конструкция try/catch/finally, позволяющая перехватывать исключения и управлять ими. Для обеспечения согласованности Scala использует тот же синтаксис, что и выражения match, и поддерживает pattern matching для различных возможных исключений. В следующем примере openAndReadAFile - это метод, который выполняет то, что следует из его названия: он открывает файл и считывает текст в нем, присваивая результат изменяемой переменной text: var text = \"\" try text = openAndReadAFile(filename) catch case fnf: FileNotFoundException =&gt; fnf.printStackTrace() case ioe: IOException =&gt; ioe.printStackTrace() finally println(\"Здесь необходимо закрыть ресурсы.\") Предполагая, что метод openAndReadAFile использует Java java.io.* классы для чтения файла и не перехватывает его исключения, попытка открыть и прочитать файл может привести как к FileNotFoundException, так и к IOException, и эти два исключения перехватываются в блоке catch этого примера. References: Scala3 book, taste Control Structures Scala3 book, Control Structures Scala 3 Reference"
    } ,    
    {
      "title": "TASTy Inspection",
      "url": "/scalaworkbook/docs/metaprogramming/tasty-inspection.html",
      "content": "{{page.title}} libraryDependencies += \"org.scala-lang\" %% \"scala3-tasty-inspector\" % scalaVersion.value TASTy файлы содержат полное типизированное дерево класса, включая исходные позиции и документацию. Это идеально подходит для инструментов, которые анализируют или извлекают семантическую информацию из кода. Чтобы избежать хлопот при работе напрямую с TASTy файлом, предоставляется файл Inspector, который загружает содержимое и предоставляет его через TASTy reflect API. Проверка TASTy файлов Для просмотра деревьев TASTy файла потребитель может быть определен следующим образом. import scala.quoted.* import scala.tasty.inspector.* class MyInspector extends Inspector: def inspect(using Quotes)(tastys: List[Tasty[quotes.type]]): Unit = import quotes.reflect.* for tasty &lt;- tastys do val tree = tasty.ast // Do something with the tree Затем можно создать экземпляр потребителя с помощью следующего кода, чтобы получить дерево файла foo/Bar.tasty. object Test: def main(args: Array[String]): Unit = val tastyFiles = List(\"foo/Bar.tasty\") TastyInspector.inspectTastyFiles(tastyFiles)(new MyInspector) Обратите внимание, что если нужно запустить main (в приведенном ниже примере, определенном в объекте с именем Test) после компиляции, нужно сделать компилятор доступным для среды выполнения: scalac -d out Test.scala scala -with-compiler -classpath out Test Шаблон проекта Используя версию sbt 1.1.5+, выполните: sbt new scala/scala3-tasty-inspector.g8 в папке, куда вы хотите клонировать шаблон. References: Scala 3 Reference"
    } ,    
    {
      "title": "Sbt",
      "url": "/scalaworkbook/docs/tools/tools-sbt.html",
      "content": "Сборка и тестирование проектов Scala с помощью Sbt В этом разделе будут показаны два инструмента, которые обычно используются в проектах Scala: инструмент сборки sbt ScalaTest - среда тестирования исходного кода Начнем с использования sbt для создания Scala-проектов, а затем рассмотрим, как использовать sbt и ScalaTest вместе для тестирования. Создание проектов Scala с помощью sbt Можно использовать несколько различных инструментов для создания проектов Scala, включая Ant, Maven, Gradle, Mill и другие. Но инструмент под названием sbt был первым инструментом сборки, специально созданным для Scala. Чтобы установить sbt, см. страницу загрузки. Создание проекта “Hello, world” Вы можете создать sbt проект “Hello, world” всего за несколько шагов. Сначала создайте каталог для работы и перейдите в него: $ mkdir hello $ cd hello В каталоге hello создайте подкаталог project: $ mkdir project Создайте файл с именем build.properties в каталоге project со следующим содержимым: sbt.version=1.6.2 Затем создайте файл с именем build.sbt в корневом каталоге проекта (hello), содержащий следующую строку: scalaVersion := \"3.1.3\" Теперь создайте файл с именем Hello.scala в корневом каталоге проекта с таким содержимым: @main def helloWorld = println(\"Hello, world\") Это все, что нужно сделать. Должна получиться следующая структура проекта: $ tree . ├── build.sbt ├── Hello.scala └── project └── build.properties Теперь запустите проект с помощью команды sbt: $ sbt run Вы должны увидеть вывод, который выглядит следующим образом, включая “Hello, world” из программы: $ sbt run [info] welcome to sbt 1.6.1 (AdoptOpenJDK Java 11.x) [info] loading project definition from project ... [info] loading settings for project from build.sbt ... [info] compiling 1 Scala source to target/scala-3.1.3/classes ... [info] running helloWorld Hello, world [success] Total time: 2 s Программа запуска — средство командной строки sbt - загружает версию sbt, установленную в файле project/build.properties, которая загружает версию компилятора Scala, установленную в файле build.sbt, компилирует код в файле Hello.scala и запускает результирующий байт-код. Если посмотреть на корневой каталог, то можно увидеть, что появилась папка с именем target. Это рабочие каталоги, которые использует sbt. Создание и запуск небольшого проекта Scala с помощью sbt занимает всего несколько простых шагов. Использование sbt в более крупных проектах Для небольшого проекта это все, что требует sbt для запуска. Для более крупных проектов с большим количеством файлов исходного кода, зависимостей или плагинов, потребуется создать организованную структуру каталогов. Остальная часть этого раздела демонстрирует структуру, которую использует sbt. Структура каталогов sbt Как и Maven, sbt использует стандартную структуру каталогов проекта. Преимуществом стандартизации является то, что, как только структура станет привычной, станет легко работать с другими проектами Scala/sbt. Первое, что нужно знать - это то, что под корневым каталогом проекта sbt ожидает структуру каталогов, которая выглядит следующим образом: . ├── build.sbt ├── project/ │ └── build.properties ├── src/ │ ├── main/ │ │ ├── java/ │ │ ├── resources/ │ │ └── scala/ │ └── test/ │ ├── java/ │ ├── resources/ │ └── scala/ └── target/ Также в корневой каталог можно добавить каталог lib, если необходимо в свой проект добавить неуправляемые зависимости — файлы JAR. Если достаточно создать проект, который имеет только файлы исходного кода Scala и тесты, но не будет использовать Java файлы и не нуждается в каких-либо “ресурсах” (встроенные изображения, файлы конфигурации и т.д.), то в каталоге src можно оставить только: . └── src/ ├── main/ │ └── scala/ └── test/ └── scala/ “Hello, world” со структурой каталогов sbt Создать такую структуру каталогов просто. Существуют инструменты, которые сделают это за вас, но если вы используете систему Unix/Linux, можно использовать следующие команды для создания структуры каталогов проекта sbt: $ mkdir HelloWorld $ cd HelloWorld $ mkdir -p src/{main,test}/scala $ mkdir project target После запуска этих команд, по запросу find . вы должны увидеть такой результат: $ find . . ./project ./src ./src/main ./src/main/scala ./src/test ./src/test/scala ./target Существуют и другие способы создания файлов и каталогов для проекта sbt. Один из способов - использовать команду sbt new, которая задокументирована на scala-sbt.org. Создание первого файла build.sbt На данный момент нужны еще две вещи для запуска проекта “Hello, world”: файл build.sbt файл Hello.scala Для такого небольшого проекта файлу build.sbt нужна только запись scalaVersion, но мы добавим три строки: name := \"HelloWorld\" version := \"0.1\" scalaVersion := \"3.1.3\" Поскольку проекты sbt используют стандартную структуру каталогов, sbt может найти все, что ему нужно. Теперь осталось просто добавить небольшую программу “Hello, world”. Программа “Hello, world” В больших проектах все файлы исходного кода будут находиться в каталогах src/main/scala и src/test/scala, но для небольшого примера, подобного этому, можно поместить файл исходного кода в корневой каталог. Поэтому создайте файл с именем HelloWorld.scala в корневом каталоге со следующим содержимым: @main def helloWorld = println(\"Hello, world\") Этот код определяет “main” метод, который печатает \"Hello, world\" при запуске. Теперь используйте команду sbt run для компиляции и запуска проекта: $ sbt run [info] welcome to sbt [info] loading settings for project ... [info] loading project definition [info] loading settings for project root from build.sbt ... [info] Compiling 1 Scala source ... [info] running helloWorld Hello, world [success] Total time: 4 s При первом запуске sbt загружает все, что ему нужно (это может занять несколько секунд), но после первого раза запуск становится намного быстрее. Кроме того, после выполнения первого шага можно обнаружить, что гораздо быстрее запускать sbt в интерактивном режиме. Для этого вначале отдельно запустите команду sbt: $ sbt [info] welcome to sbt [info] loading settings for project ... [info] loading project definition ... [info] loading settings for project root from build.sbt ... [info] sbt server started at local:///${HOME}/.sbt/1.0/server/7d26bae822c36a31071c/sock sbt:hello-world&gt; _ Затем внутри этой оболочки выполните команду run: sbt:hello-world&gt; run [info] running helloWorld Hello, world [success] Total time: 0 s Так намного быстрее. Если вы наберете help в командной строке sbt, то увидите список других команд, доступных для запуска. Введите exit (или нажмите CTRL-D), чтобы выйти из оболочки sbt. Использование шаблонов проектов Ручное создание структуры проекта может быть утомительным. К счастью, sbt может создать структуру на основе шаблона. Чтобы создать проект Scala 3 из шаблона, выполните следующую команду в оболочке: $ sbt new scala/scala3.g8 Sbt загрузит шаблон, задаст несколько вопросов и создаст файлы проекта в подкаталоге: $ tree scala-3-project-template scala-3-project-template ├── build.sbt ├── project │ └── build.properties ├── README.md └── src ├── main │ └── scala │ └── Main.scala └── test └── scala └── Test1.scala Если вы хотите создать проект Scala 3, который кросс-компилируется со Scala 2, используйте шаблон scala/scala3-cross.g8: $ sbt new scala/scala3-cross.g8 Узнайте больше о sbt new и шаблонах проектов в документации sbt. Другие инструменты сборки для Scala Хотя sbt широко используется, есть и другие инструменты, которые можно использовать для создания проектов Scala: Ant Gradle Maven Mill Coursier Coursier - это “преобразователь зависимостей”, похожий по функциям на Maven и Ivy. Он написан на Scala с нуля, “охватывает принципы функционального программирования” и для быстроты параллельно загружает артефакты. sbt использует Coursier для обработки большинства разрешений зависимостей, а в качестве инструмента командной строки его можно использовать для простой установки таких инструментов, как sbt, Java и Scala, как показано на странице “С чего начать?”. Этот пример показывает, что команда cs launch может использоваться для запуска приложений из зависимостей: $ cs launch org.scalameta::scalafmt-cli:2.4.2 -- --help scalafmt 2.4.2 Usage: scalafmt [options] [&lt;file&gt;...] -h, --help prints this usage text -v, --version print version more ... Подробнее см. на странице запуска Coursier. Использование sbt со ScalaTest ScalaTest — одна из основных библиотек тестирования для проектов Scala. В этом разделе рассмотрим шаги, необходимые для создания проекта Scala/sbt, использующего ScalaTest. 1) Создание структуры каталогов проекта Как и в предыдущем уроке, создаем структуру каталогов sbt для проекта с именем HelloScalaTest с помощью следующих команд: $ mkdir HelloScalaTest $ cd HelloScalaTest $ mkdir -p src/{main,test}/scala $ mkdir project 2) Создание файлов build.properties и build.sbt Затем создаем файл build.properties в подкаталоге project/ проекта с такой строкой: sbt.version=1.6.2 Создаем файл build.sbt в корневом каталоге проекта со следующим содержимым: name := \"HelloScalaTest\" version := \"0.1\" scalaVersion := \"3.1.3\" libraryDependencies ++= Seq( \"org.scalatest\" %% \"scalatest\" % \"3.2.9\" % Test ) Первые три строки этого файла практически такие же, как и в первом примере. Строки libraryDependencies сообщают sbt о включении зависимостей (файлов JAR), которые необходимы для добавления ScalaTest. Документация по ScalaTest всегда была хорошей, и вы всегда можете найти актуальную информацию о том, как должны выглядеть эти строки, на странице “Установка ScalaTest”. 3) Создание файла исходного кода Scala Затем создаем программу Scala, которую можно использовать для демонстрации ScalaTest. Сначала создайте каталог в src/main/scala с именем math: $ mkdir src/main/scala/math ---- Внутри этого каталога создайте файл MathUtils.scala со следующим содержимым: package math object MathUtils: def double(i: Int) = i * 2 Этот метод обеспечивает простой способ демонстрации ScalaTest. 4) Создание первых тестов ScalaTest ScalaTest очень гибок и предлагает несколько различных способов написания тестов. Простой способ начать работу — написать тесты с помощью AnyFunSuite. Для начала создайте каталог с именем math в каталоге src/test/scala: $ mkdir src/test/scala/math ---- Затем создайте в этом каталоге файл с именем MathUtilsTests.scala со следующим содержимым: package math import org.scalatest.funsuite.AnyFunSuite class MathUtilsTests extends AnyFunSuite: // test 1 test(\"'double' should handle 0\") { val result = MathUtils.double(0) assert(result == 0) } // test 2 test(\"'double' should handle 1\") { val result = MathUtils.double(1) assert(result == 2) } test(\"test with Int.MaxValue\") (pending) end MathUtilsTests Этот код демонстрирует AnyFunSuite подход. Несколько важных моментов: тестовый класс должен расширять AnyFunSuite тесты создаются, задавая каждому test уникальное имя в конце каждого теста необходимо вызвать assert, чтобы проверить, выполнено ли условие когда вы знаете, что хотите написать тест, но не хотите писать его прямо сейчас, создайте тест как “pending” (ожидающий) с показанным синтаксисом Подобное использование ScalaTest похоже на JUnit. Теперь можно запустить эти тесты с помощью команды sbt test. Пропуская первые несколько строк вывода, результат выглядит следующим образом: sbt:HelloScalaTest&gt; test [info] Compiling 1 Scala source ... [info] MathUtilsTests: [info] - 'double' should handle 0 [info] - 'double' should handle 1 [info] - test with Int.MaxValue (pending) [info] Total number of tests run: 2 [info] Suites: completed 1, aborted 0 [info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 1 [info] All tests passed. [success] Total time: 1 s Поддержка многих видов тестов В этом примере демонстрируется стиль тестирования, аналогичный стилю xUnit Test-Driven Development (TDD), с некоторыми преимуществами Behavior-Driven Development (BDD). Как уже упоминалось, ScalaTest является гибким, и вы также можете писать тесты, используя другие стили, такие как стиль, похожий на RSpec Ruby. Вы также можете использовать моканные объекты, тестирование на основе свойств и использовать ScalaTest для тестирования кода Scala.js. Дополнительные сведения о различных доступных стилях тестирования см. в Руководстве пользователя на веб-сайте ScalaTest. Куда дальше? Дополнительные сведения о sbt и ScalaTest см. в следующих ресурсах: Sbt ScalaTest References: Scala3 book"
    } ,    
    {
      "title": "Worksheet",
      "url": "/scalaworkbook/docs/tools/tools-worksheets.html",
      "content": "{{page.title}} Worksheet - это файл Scala, который вычисляется при сохранении, и результат каждого выражения отображается в столбце справа от программы. Рабочие листы похожи на сеанс REPL и имеют поддержку редактора 1-го класса: завершение, гиперссылки, интерактивные ошибки при вводе и т.д. Рабочие листы используют расширение .worksheet.sc. Далее покажем, как использовать рабочие листы в IntelliJ и в VS Code (с расширением Metals). 1) Откройте проект Scala или создайте его: чтобы создать проект в IntelliJ, выберите “File” -&gt; “New” -&gt; “Project…”, выберите “Scala” в левой колонке и нажмите “Далее”, чтобы задать название проекта и каталог. чтобы создать проект в VS Code, выполните команду “Metals: New Scala project”, выберите начальный scala/scala3.g8, задайте местоположение проекта, откройте его в новом окне VS Code и импортируйте сборку. 2) Создайте файл с именем hello.worksheet.sc в каталоге src/main/scala/. в IntelliJ щелкните правой кнопкой мыши на каталоге src/main/scala/ и выберите “New”, а затем “File”. в VS Code щелкните правой кнопкой мыши на каталоге src/main/scala/ и выберите “New File”. 3) Вставьте следующее содержимое в редактор: println(\"Hello, world!\") val x = 1 x + x 4) Запустите worksheet: в IntelliJ щелкните зеленую стрелку в верхней части редактора, чтобы запустить worksheet в VS Code сохраните файл Вы должны увидеть результат выполнения каждой строки на правой панели (IntelliJ) или в виде комментариев (VS Code). IntelliJ: VS Code: Обратите внимание, что worksheet будет использовать версию Scala, определенную проектом (обычно задается ключом scalaVersion в файле build.sbt). Также обратите внимание, что worksheet не имеют точек входа в программу. Вместо этого операторы и выражения верхнего уровня оцениваются сверху вниз. References: Scala3 book"
    } ,    
    {
      "title": "Утилиты",
      "url": "/scalaworkbook/docs/tools.html",
      "content": "{{page.title}} В этой главе представлены два способа написания и запуска программ Scala: путем создания проектов Scala, возможно содержащих несколько файлов, и определения точки входа в программу взаимодействуя с worksheet, который представляет собой программу, определенную в одном файле и выполняемую построчно References: Scala3 book"
    } ,    
    {
      "title": "Верхнеур. определения",
      "url": "/scalaworkbook/docs/toplevel-definitions.html",
      "content": "Верхнеуровневые определения В Scala 3 все виды определений могут быть записаны на “верхнем уровне” файлов исходного кода. Например, можно создать файл с именем MyCoolApp.scala и поместить в него данное содержимое: import scala.collection.mutable.ArrayBuffer enum Topping: case Cheese, Pepperoni, Mushrooms import Topping.* class Pizza: val toppings = ArrayBuffer[Topping]() val p = Pizza() extension (s: String) def capitalizeAllWords = s.split(\" \").map(_.capitalize).mkString(\" \") val hwUpper = \"hello, world\".capitalizeAllWords type Money = BigDecimal // по желанию дополнительные определения... @main def myApp = p.toppings += Cheese println(\"show me the code\".capitalizeAllWords) Как показано, нет необходимости помещать эти определения внутри пакета, класса или другой конструкции. Этот подход заменяет package objects из Scala 2, которые впоследствии будут объявлены устаревшими и удалены. Но, будучи намного проще в использовании, они работают аналогично: когда вы помещаете определение в пакет с именем foo, вы можете получить доступ к этому определению во всех других пакетах в foo, например, в пакете foo.bar в этом примере: package foo { def double(i: Int) = i * 2 } package foo { package bar { @main def fooBarMain = println(s\"${double(1)}\") } } Фигурные скобки используются в этом примере, чтобы подчеркнуть вложенность пакета (они не обязательны для использования). Преимуществом такого подхода является то, что можно размещать определения в пакете с именем com.acme.myapp, а затем можно ссылаться на эти определения в com.acme.myapp.model, com.acme.myapp.controller и т.д. References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Traits",
      "url": "/scalaworkbook/docs/modeling/traits.html",
      "content": "{{page.title}} Если провести аналогию с Java, то Scala trait похож на интерфейс в Java 8+. trait-ы могут содержать: абстрактные методы и поля конкретные методы и поля могут иметь параметры конструктора, как и классы В базовом использовании trait может использоваться как интерфейс, определяющий только абстрактные члены, которые будут реализованы другими классами: trait Employee: def id: Int def firstName: String def lastName: String traits также могут содержать определенные методы: trait HasLegs: def numLegs: Int def walk(): Unit def stop() = println(\"Stopped walking\") trait HasTail: def tailColor: String def wagTail() = println(\"Tail is wagging\") def stopTail() = println(\"Tail is stopped\") Классы и объекты могут расширять несколько traits, что позволяет с их помощью создавать небольшие модули. class IrishSetter(name: String) extends HasLegs, HasTail: val numLegs = 4 val tailColor = \"Red\" def walk() = println(\"I’m walking\") override def toString = s\"$name is a Dog\" В классе IrishSetter реализованы все абстрактные параметры и методы, поэтому можно создать его экземпляр: val d = IrishSetter(\"Big Red\") // d: IrishSetter = Big Red is a Dog Класс также может переопределять методы trait-ов при необходимости. Аргументы trait оцениваются непосредственно перед его инициализацией. Особенности при расширении trait с параметрами конструктора Одна потенциальная проблема с параметрами trait заключается в том, как предотвратить двусмысленность. Например, можно попробовать выполнить расширение Greeting дважды с разными параметрами: trait Greeting(val name: String): def msg = s\"How are you, $name\" class C extends Greeting(\"Bob\"): println(msg) class D extends C, Greeting(\"Bill\") // error: // trait Greeting is already implemented by superclass C, // its constructor cannot be called again // class E extends Greeting(\"Bob\"), FormalGreeting // ^ На самом деле эта программа не скомпилируется, потому что она нарушает второе правило для параметров trait: Если класс C расширяет параметризованный trait T, а его суперкласс — нет, то C должен передать аргументы в T. Если класс C расширяет параметризованный trait T и его суперкласс тоже, то C не должен передавать аргументы в T. trait-ы никогда не должны передавать аргументы родительским trait-ам. Вот трейт, расширяющий параметризованный трейт Greeting. trait FormalGreeting extends Greeting: override def msg = s\"How do you do, $name\" Правильный способ создания класса E, расширяющего оба - Greeting и FormalGreeting (в любом порядке) - такой: class E extends Greeting(\"Bob\"), FormalGreeting (new C).msg // How are you, Bob // res1: String = \"How are you, Bob\" (new E).msg // res2: String = \"How do you do, Bob\" Trait-ы с параметрами контекста Правило “требуется явное расширение” ослабляется, если отсутствующий trait содержит только параметры контекста. В этом случае ссылка на трейт неявно вставляется как дополнительный родитель с выводимыми аргументами. Например, вот вариант Greeting, где адресат является параметром контекста типа ImpliedName: case class ImpliedName(name: String): override def toString = name trait ImpliedGreeting(using val iname: ImpliedName): def msg = s\"How are you, $iname\" trait ImpliedFormalGreeting extends ImpliedGreeting: override def msg = s\"How do you do, $iname\" class F(using iname: ImpliedName) extends ImpliedFormalGreeting Определение F в последней строке неявно расширяется до class F(using iname: ImpliedName) extends Object, ImpliedGreeting(using iname), ImpliedFormalGreeting(using iname) Обратите внимание на вставленную ссылку на ImpliedFormalGreeting - родительский trait ImpliedGreeting, которая не упоминалась явно. given ImpliedName: ImpliedName(\"Bob\") (new F).msg // res3: String = \"How do you do, ImpliedName\" Transparent traits Trait-ы используются в двух случаях: как примеси для других классов и trait-ов как типы констант, определений или параметров Некоторые trait-ы используются преимущественно в первой роли, и обычно их нежелательно видеть в выводимых типах. Примером может служить trait Product, который компилятор добавляет в качестве примеси к каждому case class-у или case object-у. В Scala 2 этот родительский trait иногда делает выводимые типы более сложными, чем они должны быть. Пример: trait Kind case object Var extends Kind case object Val extends Kind val x = Set(if condition then Val else Var) Здесь предполагаемый тип x равен Set[Kind &amp; Product &amp; Serializable], тогда как можно было бы надеяться, что это будет Set[Kind]. Основания для выделения именно этого типа следующие: тип условного оператора, приведенного выше, является типом объединения Val | Var. тип объединения расширяется в выводе типа до наименьшего супертипа, который не является типом объединения. В примере - это тип Kind &amp; Product &amp; Serializable, так как все три trait-а являются trait-ами обоих Val и Var. Таким образом, этот тип становится предполагаемым типом элемента набора. Scala 3 позволяет помечать trait примеси как transparent, что означает, что он может быть подавлен при выводе типа. Вот пример, который повторяет строки приведенного выше кода, но теперь с новым transparent trait S вместо Product: transparent trait S trait Kind object Var extends Kind, S object Val extends Kind, S val x = Set(if condition then Val else Var) Теперь x предположил тип Set[Kind]. Общий transparent trait S не появляется в выводимом типе. Прозрачные trait-ы Trait-ы scala.Product, java.io.Serializable и java.lang.Comparable автоматически считаются transparent. Другие трейты превращаются в transparent trait с помощью модификатора transparent. Как правило, transparent trait — это trait-ы, влияющие на реализацию наследуемых классов, и trait-ы, которые сами по себе обычно не используются как типы. Два примера из стандартной библиотеки коллекций: IterableOps, который предоставляет реализации методов для Iterable. StrictOptimizedSeqOps, который оптимизирует некоторые из этих реализаций для последовательностей с эффективной индексацией. Как правило, любой trait, расширяемый рекурсивно, является хорошим кандидатом на объявление transparent. Правила вывода типов говорят, что transparent trait удаляются из пересечений, где это возможно. References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects Scala3, Reference Scala3, Transparent Traits"
    } ,    
    {
      "title": "Traverse",
      "url": "/scalaworkbook/typeclass/monad/traverse.html",
      "content": "{{page.title}} Предположим, что есть два функтора F и G. Traversable позволяет менять местами “обертку” функторов между собой, т.е. реализует операцию traverse = F[G[A]] -&gt; G[F[A]] Примеры traversable Реализации traversable в различных библиотеках References: Tour of Scala"
    } ,    
    {
      "title": "Tuple",
      "url": "/scalaworkbook/docs/collections/tuple.html",
      "content": "Tuple (кортежи) Scala tuple - это тип, который позволяет помещать коллекцию разных типов в один и тот же контейнер. Например, учитывая case class Person: case class Person(name: String) можно построить кортеж, содержащий Int, String и Person: val t = (11, \"eleven\", Person(\"Eleven\")) // t: Tuple3[Int, String, Person] = (11, \"eleven\", Person(name = \"Eleven\")) Доступ к значениям кортежа осуществляется через индекс (начиная с 0): t(0) // res0: Int = 11 t(1) // res1: String = \"eleven\" t(2) // res2: Person = Person(name = \"Eleven\") либо через методы вида ._i, где i - порядковый номер (начиная с 1, в отличие от индекса) t._1 // res3: Int = 11 t._2 // res4: String = \"eleven\" t._3 // res5: Person = Person(name = \"Eleven\") Также можно использовать extractor для присвоения переменным значений полей кортежа: val (num, str, person) = t // num: Int = 11 // str: String = \"eleven\" // person: Person = Person(name = \"Eleven\") Кортежи хороши для случаев, когда необходимо поместить коллекцию разнородных типов в небольшую структуру, похожую на коллекцию. References: Scala3 book Scala3 book, Collections Types Scala, Immutable collections Scala, Mutable collections"
    } ,    
    {
      "title": "Класс типов",
      "url": "/scalaworkbook/docs/abstractions/type-classes.html",
      "content": "{{page.title}} Класс типов (type class) — это абстрактный параметризованный тип, который позволяет добавлять новое поведение к любому закрытому типу данных без использования подтипов. Если вы пришли с Java, то можно думать о классах типов как о чем-то вроде java.util.Comparator[T]. В статье “Type Classes as Objects and Implicits” (2010 г.) обсуждаются основные идеи, лежащие в основе классов типов в Scala. Несмотря на то, что в статье используется более старая версия Scala, идеи актуальны и по сей день. Этот стиль программирования полезен во многих случаях, например: выражение того, как тип, которым вы не владеете, например, из стандартной или сторонней библиотеки, соответствует такому поведению добавление поведения к нескольким типам без введения отношений подтипов между этими типами (например, когда один расширяет другой) В Scala 3 классы типов — это просто trait-ы с одним или несколькими параметрами типа, например: trait Show[A]: def show(a: A): String Экземпляры Show для определенного типа A свидетельствуют о том, что мы можем показать (т.е. создать текстовое представление) экземпляр типа A. Например, рассмотрим следующий экземпляр Show для Int: class ShowInt extends Show[Int]: def show(a: Int) = s\"The number is ${a}!\" Можно написать методы, которые работают с произвольными типами A, ограниченными Show, следующим образом: def toHtml[A](a: A)(showA: Show[A]): String = \"&lt;p&gt;\" + showA.show(a) + \"&lt;/p&gt;\" То есть toHtml можно вызывать с произвольным A, если также предоставить экземпляр Show[A]. Например, метод можно вызвать так: toHtml(42)(ShowInt()) // res0: String = \"&lt;p&gt;The number is 42!&lt;/p&gt;\" Автоматическая передача экземпляров класса типов Поскольку классы типов являются очень важным способом структурирования программного обеспечения, Scala 3 предлагает дополнительные функции, которые делают работу с ними очень удобной. Эти дополнительные функции, относящиеся к категории контекстуальных абстракций, рассматриваются в одной из последующих глав. References: Scala3 book"
    } ,    
    {
      "title": "Type Lambdas",
      "url": "/scalaworkbook/docs/type-system/type-lambdas.html",
      "content": "Лямбда-типы Лямбда-тип позволяет выразить тип более высокого типа напрямую, без определения. [X, Y] =&gt;&gt; Map[Y, X] Например, приведенный выше тип определяет конструктор бинарного вида, который сопоставляет аргументы X и Y с Map[Y, X]. Параметры типа лямбда-выражений могут иметь границы, но они не могут содержать аннотации вариантности + или -. Пример: type XY = [X, Y] =&gt;&gt; Map[Y, X] val numbers: XY[String, Int] = Map(1 -&gt; \"first\", 2 -&gt; \"second\") // numbers: Map[Int, String] = Map(1 -&gt; \"first\", 2 -&gt; \"second\") numbers(1) // res0: String = \"first\" Проверка типа Лямбда-тип, например, [X] =&gt;&gt; F[X] определяет функцию от типов к типам. Параметры могут иметь ограничения. Если параметр ограничен, как [X &gt;: L &lt;: U] =&gt;&gt; F[X], то проверяется, что аргументы параметров соответствуют границам L и U. Только верхняя граница U рассматривается включительно, т.е. что X может в неё входить. Правила подтипа Рассмотрим два лямбда-выражения type TL1 = [X &gt;: L1 &lt;: U1] =&gt;&gt; R1 type TL2 = [X &gt;: L2 &lt;: U2] =&gt;&gt; R2 Тогда TL1 &lt;: TL2, если интервал типов L2 .. U2 содержится в интервале типа L1 .. U1 (т.е. L1 &lt;: L2 и U2 &lt;: U1), R1 &lt;: R2 Предполагается, что частично применяемый конструктор типа List эквивалентен его Eta Expansion. Т.е. List = [X] =&gt;&gt; List[X]. Это позволяет сравнивать конструкторы типов с лямбда-выражениями типов. Связь с определениями параметризованного типа Определение параметризованного типа type T[X] = R рассматривается как сокращение для непараметризованного определения с лямбда-типом в правой части: type T = [X] =&gt;&gt; R Если определение типа содержит аннотации вариантности + или -, проверяется, удовлетворяет ли лямбда аннотации вариантности. Например, type F2[A, +B] = A =&gt; B расширяется до type F2 = [A, B] =&gt;&gt; A =&gt; B и при этом проверяется, что параметр B появляется ковариантно в A =&gt; B. Параметризованный абстрактный тип type T[X] &gt;: L &lt;: U считается сокращением для непараметризованного абстрактного типа с лямбда-выражениями типа в качестве границ. type T &gt;: ([X] =&gt;&gt; L) &lt;: ([X] =&gt;&gt; U) Однако, если L - Nothing, то он не параметризован, т.к. Nothing считается нижним типом для всех видов. Например, type T[X] &lt;: X =&gt; X расширяется до type T &gt;: Nothing &lt;: ([X] =&gt;&gt; X =&gt; X) вместо type T &gt;: ([X] =&gt;&gt; Nothing) &lt;: ([X] =&gt;&gt; X =&gt; X) Те же расширения применяются к параметрам типа. Например, [F[X] &lt;: Coll[X]] рассматривается как сокращение для [F &gt;: Nothing &lt;: [X] =&gt;&gt; Coll[X]] Абстрактные типы и псевдонимы непрозрачных типов запоминают вариантность, с которыми были созданы. Итак, тип type F2[-A, +B] известно, что он контравариантен в A и ковариантен в B и может быть реализован только с типами, которые удовлетворяют этим ограничениям. Так же opaque type O[X] = List[X] O известно, что оно инвариантно (а не ковариантно, как следует из его правой части). С другой стороны, прозрачный псевдоним type O2[X] = List[X] будет рассматриваться как ковариантный, X используется ковариантно в его правой части. Каррированные параметры типа Тело лямбда-типа может снова быть лямбда-типом. Пример: type TL = [X] =&gt;&gt; [Y] =&gt;&gt; (X, Y) References: Scala 3 Reference Scala 3 Reference, Details"
    } ,    
    {
      "title": "Система типов",
      "url": "/scalaworkbook/docs/type-system.html",
      "content": "{{page.title}} Scala — уникальный язык, поскольку он статически типизирован, но часто кажется гибким и динамичным. Например, благодаря выводу типов можно писать код без явного указания типов переменных: val a = 1 val b = 2.0 val c = \"Hi!\" Это делает код динамически типизированным. А благодаря новым функциям в Scala 3, таким как объединение типов, также можно писать код, подобный следующему, который кратко выражает, какие значения ожидаются в качестве аргументов и какие типы возвращаются: def isTruthy(a: Boolean | Int | String): Boolean = ??? def dogCatOrWhatever(): Dog | Plant | Car | Sun = ??? Как видно из примера, при использовании объединения типы необязательно должны иметь общую иерархию, и их по-прежнему можно принимать в качестве аргументов или возвращать из метода. При разработке приложений такие функции, как вывод типов, используются каждый день, а generics - каждую неделю. При чтении Scaladoc для классов и методов, также необходимо иметь некоторое представление о ковариантности. Использование типов может быть относительно простым, а также обеспечивает большую выразительность, гибкость и контроль для разработчиков библиотек. Преимущества типов Языки программирования со статической типизацией предлагают ряд преимуществ, в том числе: помощь IDE в обеспечении надежной поддержки устранение многих классов потенциальных ошибок во время компиляции помощь в рефакторинге предоставление надежной документации, которая не может быть нерелевантной, поскольку проверена на тип References: Scala3 book"
    } ,    
    {
      "title": "Проверка типа",
      "url": "/scalaworkbook/docs/details/type-test.html",
      "content": "{{page.title}} При сопоставлении с образцом есть две ситуации, когда необходимо выполнить проверку типа во время выполнения. Первый случай — это явная проверка типа с использованием нотации шаблона атрибуции. (x: X) match case y: Y =&gt; Второй случай — когда экстрактор принимает аргумент, не являющийся подтипом контролируемого типа. (x: X) match case y @ Y(n) =&gt; object Y: def unapply(x: Y): Some[Int] = ... В обоих случаях тест класса будет выполняться во время выполнения. Но когда проверка типа относится к абстрактному типу (параметру типа или члену типа), проверка не может быть выполнена, поскольку тип стирается во время выполнения. Проверку типов в этих случаях можно выполнять если предоставлен trait TypeTest. package scala.reflect trait TypeTest[-S, T]: def unapply(s: S): Option[s.type &amp; T] Он предоставляет экстрактор, который возвращает свой аргумент, типизированный как T, если аргумент имеет тип T. Его можно использовать для кодирования проверки типа. def f[X, Y](x: X)(using tt: TypeTest[X, Y]): Option[Y] = x match case tt(x @ Y(1)) =&gt; Some(x) case tt(x) =&gt; Some(x) case _ =&gt; None Чтобы избежать синтаксических издержек, компилятор будет автоматически искать проверку типа, если обнаружит, что проверка типа относится к абстрактным типам. Это означает, что x: Y трансформируется в tt(x) и x @ Y(_) в tt(x @ Y(_)), если в области видимости доступен контекст TypeTest[X, Y]. Предыдущий код эквивалентен def f[X, Y](x: X)(using TypeTest[X, Y]): Option[Y] = x match case x @ Y(1) =&gt; Some(x) case x: Y =&gt; Some(x) case _ =&gt; None На стороне вызова можно было бы создать тест типа, где тест типа может быть выполнен непосредственно с тестами класса времени выполнения следующим образом. val tt: TypeTest[Any, String] = new TypeTest[Any, String]: def unapply(s: Any): Option[s.type &amp; String] = s match case s: String =&gt; Some(s) case _ =&gt; None f[AnyRef, String](\"acb\")(using tt) Компилятор синтезирует новый экземпляр теста типа, если ни один из них не найден в области видимости, например: new TypeTest[A, B]: def unapply(s: A): Option[s.type &amp; B] = s match case s: B =&gt; Some(s) case _ =&gt; None Если проверки типов не могут быть выполнены, в тесте case s: B =&gt; будет выдано непроверенное предупреждение. Наиболее распространенными экземплярами TypeTest являются те, которые принимают любые параметры (т.е. TypeTest[Any, T]). Чтобы можно было использовать такие экземпляры непосредственно в границах контекста, предоставляется псевдоним package scala.reflect type Typeable[T] = TypeTest[Any, T] Этот псевдоним можно использовать так: import scala.reflect.Typeable def f[T: Typeable]: Boolean = \"abc\" match case x: T =&gt; true case _ =&gt; false f[String] // res0: Boolean = true f[Int] // res1: Boolean = false Пример Учитывая следующее абстрактное определение чисел Пеано, которое предоставляет два given экземпляра типов TypeTest[Nat, Zero] и TypeTest[Nat, Succ]: import scala.reflect.* trait Peano: type Nat type Zero &lt;: Nat type Succ &lt;: Nat def safeDiv(m: Nat, n: Succ): (Nat, Nat) val Zero: Zero val Succ: SuccExtractor trait SuccExtractor: def apply(nat: Nat): Succ def unapply(succ: Succ): Some[Nat] given typeTestOfZero: TypeTest[Nat, Zero] given typeTestOfSucc: TypeTest[Nat, Succ] вместе с реализацией чисел Пеано на основе типа Int: object PeanoInt extends Peano: type Nat = Int type Zero = Int type Succ = Int def safeDiv(m: Nat, n: Succ): (Nat, Nat) = (m / n, m % n) val Zero: Zero = 0 val Succ: SuccExtractor = new: def apply(nat: Nat): Succ = nat + 1 def unapply(succ: Succ) = Some(succ - 1) def typeTestOfZero: TypeTest[Nat, Zero] = new: def unapply(x: Nat): Option[x.type &amp; Zero] = if x == 0 then Some(x) else None def typeTestOfSucc: TypeTest[Nat, Succ] = new: def unapply(x: Nat): Option[x.type &amp; Succ] = if x &gt; 0 then Some(x) else None можно написать следующую программу: import PeanoInt.* def divOpt(m: Nat, n: Nat): Option[(Nat, Nat)] = n match case Zero =&gt; None case s @ Succ(_) =&gt; Some(safeDiv(m, s)) val two = Succ(Succ(Zero)) // two: Int = 2 val five = Succ(Succ(Succ(two))) // five: Int = 5 println(divOpt(five, two)) // Some((2,1)) println(divOpt(two, five)) // Some((0,2)) println(divOpt(two, Zero)) // None Обратите внимание, что без TypeTest[Nat, Succ] паттерн Succ.unapply(nat: Succ) был бы unchecked. References: Scala 3 Reference"
    } ,    
    {
      "title": "Алгебр. типы данных",
      "url": "/scalaworkbook/docs/type-system/types-adts.html",
      "content": "Алгебраические типы данных (ADT) Алгебраические типы данных (ADT) могут быть созданы с помощью конструкции enum. Концепция enum является достаточно общей, чтобы также поддерживать алгебраические типы данных (ADT) и их обобщенную версию (GADT). Вот пример, показывающий, как тип Option может быть представлен в виде ADT: enum Option[+T]: case Some(x: T) case None В этом примере создается Option enum с параметром ковариантного типа T, состоящим из двух вариантов: Some и None. Some параметризуются параметром значения x; это сокращение для написания case класса, который расширяет Option. Поскольку None не параметризован, он обрабатывается как обычное значение enum. Предложения extends, которые были опущены в предыдущем примере, также могут быть указаны явно: enum Option[+T]: case Some(x: T) extends Option[T] case None extends Option[Nothing] Как и в случае с обычными значениями enum, case enum определяются в сопутствующем объекте перечисления, поэтому они называются Option.Some и Option.None (если только определения не “вытягиваются” при импорте): Option.Some(\"hello\") // res0: Option[String] = Some(x = \"hello\") Option.None // res1: Option[Nothing] = None Обратите внимание, что тип приведенных выше выражений всегда Option. Как правило, тип case enum будет расширен до базового типа enum, если не ожидается более конкретный тип. Это тонкая разница по сравнению с обычными case class-ами. Классы, составляющие case enum, существуют, и их можно использовать, либо создав их непосредственно с помощью new, либо явно указав ожидаемый тип. new Option.Some(2) // res2: Some[Int] = Some(x = 2) val x: Option.Some[Int] = Option.Some(3) // x: Some[Int] = Some(x = 3) Как и в других случаях использования перечисления, АТД могут определять дополнительные методы. Например, вот снова Option с методом isDefined и конструктором Option(...) в сопутствующем объекте: enum Option[+T]: case Some(x: T) case None def isDefined: Boolean = this match case None =&gt; false case Some(_) =&gt; true object Option: def apply[T &gt;: Null](x: T): Option[T] = if (x == null) None else Some(x) Перечисления и ADT используют одну и ту же синтаксическую конструкцию, поэтому их можно рассматривать просто как два конца спектра, и вполне возможно создавать гибриды. Например, приведенный ниже код дает реализацию Color либо с тремя значениями перечисления, либо с параметризованным case, который принимает значение RGB: enum Color(val rgb: Int): case Red extends Color(0xFF0000) case Green extends Color(0x00FF00) case Blue extends Color(0x0000FF) case Mix(mix: Int) extends Color(mix) Рекурсивные перечисления До сих пор все перечисления состояли только из различных вариантов значений или case class-ов. Перечисления также могут быть рекурсивными, как показано в приведенном ниже примере кодирования натуральных чисел: enum Nat: case Zero case Succ(n: Nat) Например, значение Succ(Succ(Zero)) представляет число 2 в унарной кодировке. Очень похожим образом могут быть определены списки: enum List[+A]: case Nil case Cons(head: A, tail: List[A]) Обобщенные алгебраические типы данных (GADT) Приведенная выше нотация для перечислений очень лаконична и служит идеальной отправной точкой для моделирования типов данных. Также возможно выразить гораздо более мощные типы: обобщенные алгебраические типы данных (GADTs). Вот пример GADT, где параметр типа (T) определяет содержимое, хранящееся в поле: enum Box[T](contents: T): case IntBox(n: Int) extends Box[Int](n) case BoolBox(b: Boolean) extends Box[Boolean](b) Сопоставление с шаблоном в конкретном конструкторе (IntBox или BoolBox) восстанавливает информацию о типе: def extract[T](b: Box[T]): T = b match case IntBox(n) =&gt; n + 1 case BoolBox(b) =&gt; !b Безопасно возвращать Int только в первом случае, так как из сопоставления с шаблоном известно, что b был IntBox. Дешугаризация перечислений Концептуально перечисления можно рассматривать как определение sealed класса вместе с сопутствующим объектом. Посмотрим на дешугаризацию перечисления Color: sealed abstract class Color(val rgb: Int) extends scala.reflect.Enum object Color: case object Red extends Color(0xFF0000) { def ordinal = 0 } case object Green extends Color(0x00FF00) { def ordinal = 1 } case object Blue extends Color(0x0000FF) { def ordinal = 2 } case class Mix(mix: Int) extends Color(mix) { def ordinal = 3 } def fromOrdinal(ordinal: Int): Color = ordinal match case 0 =&gt; Red case 1 =&gt; Green case 2 =&gt; Blue case _ =&gt; throw new NoSuchElementException(ordinal.toString) Вышеописанная дешугаризация упрощена, детали доступны по ссылке. Хотя перечисления можно кодировать вручную с помощью других конструкций, использование enum является более кратким, а также включает несколько дополнительных утилит (таких как метод fromOrdinal). References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Зависимые типы функций",
      "url": "/scalaworkbook/docs/type-system/types-dependent-function.html",
      "content": "{{page.title}} Зависимый тип функции (dependent function type) описывает типы функций, где тип результата может зависеть от значений параметров функции. Концепция зависимых типов и типов зависимых функций является более продвинутой, и обычно с ней сталкиваются только при разработке собственных библиотек или использовании расширенных библиотек. Зависимые типы методов Рассмотрим следующий пример гетерогенной базы данных, в которой могут храниться значения разных типов. Ключ содержит информацию о типе соответствующего значения: trait Key { type Value } trait DB { def get(k: Key): Option[k.Value] // зависимый метод } Получив ключ, метод get предоставляет доступ к карте и потенциально возвращает сохраненное значение типа k.Value. Мы можем прочитать этот path-dependent type как: “в зависимости от конкретного типа аргумента k возвращается соответствующее значение”. Например, у нас могут быть следующие ключи: object Name extends Key { type Value = String } object Age extends Key { type Value = Int } Вызовы метода get теперь будут возвращать такие типы: val db: DB = ... val res1: Option[String] = db.get(Name) val res2: Option[Int] = db.get(Age) Вызов метода db.get(Name) возвращает значение типа Option[String], а вызов db.get(Age) возвращает значение типа Option[Int]. Тип возвращаемого значения зависит от конкретного типа аргумента, переданного для get — отсюда и название dependent type. Зависимые типы функций Как видно выше, в Scala 2 уже была поддержка зависимых типов методов. Однако создание значений типа DB довольно громоздко: // создание пользователя DB def user(db: DB): Unit = db.get(Name) ... db.get(Age) // создание экземпляра DB и передача его `user` user(new DB { def get(k: Key): Option[k.Value] = ... // implementation of DB }) Необходимо вручную создать анонимный внутренний класс DB, реализующий метод get. Для кода, основанного на создании множества различных экземпляров DB, это очень утомительно. DB trait имеет только один абстрактный метод get. Было бы неплохо использовать в этом месте лямбда-синтаксис… user { k =&gt; ... // implementation of DB } На самом деле, в Scala 3 теперь это возможно! Можно определить DB как зависимый тип функции: type DB = (k: Key) =&gt; Option[k.Value] // ^^^^^^^^^^^^^^^^^^^^^^^^^^^ // зависимый тип функции Учитывая это определение DB, можно использовать приведенный выше вызов user. Определение Зависимый тип функции (dependent function type) — это тип функции, результат которой зависит от параметров функции. Например: trait Entry { type Key; val key: Key } def extractKey(e: Entry): e.Key = e.key // зависимый метод val extractor: (e: Entry) =&gt; e.Key = extractKey // значение зависимой функции // ^^^^^^^^^^^^^^^^^^^ // зависимый тип функции Тип обычной функции A =&gt; B представлен как экземпляр trait-а Function1 (т.е. Function1[A, B]) и аналогично для функций с большим количеством параметров. Зависимые функции также представлены как экземпляры этих трейтов, но они получают дополнительное уточнение. На самом деле, зависимый тип функции выше — это просто синтаксический сахар для Function1[Entry, Entry#Key]: def apply(e: Entry): e.Key Практический пример: числовые выражения Предположим, что необходимо определить модуль, который абстрагируется от внутреннего представления чисел. Это может быть полезно, например, для реализации библиотек для автоматического дифференцирования. Начнем с определения модуля для чисел: trait Nums: // тип Num оставлен абстрактным type Num // некоторые операции над числами def lit(d: Double): Num def add(l: Num, r: Num): Num def mul(l: Num, r: Num): Num Здесь опускается конкретная реализация Nums, но в качестве упражнения можно реализовать Nums, назначив тип Num = Double и реализуя соответствующие методы. Программа, использующая числовую абстракцию, теперь имеет следующий тип: type Prog = (n: Nums) =&gt; n.Num =&gt; n.Num val ex: Prog = nums =&gt; x =&gt; nums.add(nums.lit(0.8), x) Тип функции, которая вычисляет производную, наподобие ex: def derivative(input: Prog): Double Учитывая удобство зависимых типов функций, вызов этой функции в разных программах прост: derivative { nums =&gt; x =&gt; x } derivative { nums =&gt; x =&gt; nums.add(nums.lit(0.8), x) } // ... Напомним, что та же программа в приведенной выше кодировке будет выглядеть так: derivative(new Prog { def apply(nums: Nums)(x: nums.Num): nums.Num = x }) derivative(new Prog { def apply(nums: Nums)(x: nums.Num): nums.Num = nums.add(nums.lit(0.8), x) }) // ... Комбинация с контекстными функциями Комбинация методов расширения, контекстных функций и зависимых функций обеспечивает мощный инструмент для разработчиков библиотек. Например, мы можем уточнить нашу библиотеку, как указано выше, следующим образом: trait NumsDSL extends Nums: extension (x: Num) def +(y: Num) = add(x, y) def *(y: Num) = mul(x, y) def const(d: Double)(using n: Nums): n.Num = n.lit(d) type Prog = (n: NumsDSL) ?=&gt; n.Num =&gt; n.Num // ^^^ // prog теперь - контекстная функция, которая неявно предполагает NumsDSL в контексте вызова def derivative(input: Prog): Double = ... // теперь нам не нужно упоминать Nums в приведенных ниже примерах derivative { x =&gt; const(1.0) + x } derivative { x =&gt; x * x + const(2.0) } // ... Дополнительные примеры В приведенном ниже примере определяется trait C и два зависимых типа функций DF и IDF, а также выводятся результаты вызовов соответствующих функций: trait C { type M; val m: M } type DF = (x: C) =&gt; x.M type IDF = (x: C) ?=&gt; x.M val c = new C { type M = Int; val m = 3 } val depfun: DF = (x: C) =&gt; x.m val idepfun: IDF = summon[C].m val t = depfun(c) // t: Int = 3 val u = idepfun(using c) // u: Int = 3 В следующем примере тип зависимости f.Eff относится к типу CanThrow: trait Effect // Type X =&gt; Y abstract class Fun[-X, +Y]: type Eff &lt;: Effect def apply(x: X): Eff ?=&gt; Y class CanThrow extends Effect class CanIO extends Effect given ct: CanThrow = new CanThrow given ci: CanIO = new CanIO class I2S extends Fun[Int, String]: type Eff = CanThrow def apply(x: Int) = x.toString class S2I extends Fun[String, Int]: type Eff = CanIO def apply(x: String) = x.length // def map(f: A =&gt; B)(xs: List[A]): List[B] def map[A, B](f: Fun[A, B])(xs: List[A]): f.Eff ?=&gt; List[B] = xs.map(f.apply) // def mapFn[A, B]: (A =&gt; B) -&gt; List[A] -&gt; List[B] def mapFn[A, B]: (f: Fun[A, B]) =&gt; List[A] =&gt; f.Eff ?=&gt; List[B] = f =&gt; xs =&gt; map(f)(xs) // def compose(f: A =&gt; B)(g: B =&gt; C)(x: A): C def compose[A, B, C](f: Fun[A, B])(g: Fun[B, C])(x: A): f.Eff ?=&gt; g.Eff ?=&gt; C = g(f(x)) // def composeFn: (A =&gt; B) -&gt; (B =&gt; C) -&gt; A -&gt; C def composeFn[A, B, C]: (f: Fun[A, B]) =&gt; (g: Fun[B, C]) =&gt; A =&gt; f.Eff ?=&gt; g.Eff ?=&gt; C = f =&gt; g =&gt; x =&gt; compose(f)(g)(x) val i2s = new I2S val s2i = new S2I mapFn(i2s)(List(1, 2, 3)).mkString // res0: String = \"123\" composeFn(i2s)(s2i)(22) // res1: Int = 2 References: Scala3 book Scala 3 Reference Scala 3 Reference, Details"
    } ,    
    {
      "title": "Generics типы",
      "url": "/scalaworkbook/docs/type-system/types-generics.html",
      "content": "{{page.title}} Универсальные (generic) классы (или trait-ы) принимают тип в качестве параметра в квадратных скобках [...]. Для обозначения параметров типа согласно конвенции Scala используется одна заглавная буква (например, A). Затем этот тип можно использовать внутри класса по мере необходимости для параметров экземпляра метода или для возвращаемых типов: // здесь мы объявляем параметр типа A // v class Stack[A]: private var elements: List[A] = Nil // ^ // здесь мы ссылаемся на этот тип // v def push(x: A): Unit = { elements = elements.prepended(x) } def peek: A = elements.head def pop(): A = val currentTop = peek elements = elements.tail currentTop Эта реализация класса Stack принимает любой тип в качестве параметра. Прелесть дженериков состоит в том, что теперь можно создавать Stack[Int], Stack[String] и т. д., что позволяет повторно использовать реализацию Stack для произвольных типов элементов. Пример создания и использования Stack[Int]: val stack = Stack[Int] stack.push(1) stack.push(2) println(stack.pop()) // 2 println(stack.pop()) // 1 Подробности о том, как выразить ковариантность с помощью универсальных типов, см. в разделе “Ковариантность”. Верхнее ограничение типа Параметры типа и члены абстрактного типа могут быть ограничены определенными диапазонами. Такие диапазоны ограничивают конкретные значение типа и, возможно, предоставляют больше информации о членах таких типов. Верхнее ограничение типа T &lt;: A указывает на то что тип T относится к подтипу типа A. Приведем пример, демонстрирующий верхнее ограничение для типа класса PetContainer: abstract class Animal: def name: String abstract class Pet extends Animal class Cat extends Pet: override val name: String = \"Cat\" class Dog extends Pet: override val name: String = \"Dog\" class Lion extends Animal: override val name: String = \"Lion\" class PetContainer[P &lt;: Pet](p: P): def pet: P = p val dogContainer = PetContainer[Dog](Dog()) val catContainer = PetContainer[Cat](Cat()) Класс PetContainer принимает тип P, который должен быть подтипом Pet. Dog и Cat - это подтипы Pet, поэтому можно создать новые PetContainer[Dog] и PetContainer[Cat]. Однако, если попытаться создать PetContainer[Lion], то получим следующую ошибку: val lionContainer = PetContainer[Lion](Lion()) // error: // Type argument App0.this.Lion does not conform to upper bound App0.this.Pet // val lionContainer = PetContainer[Lion](Lion()) // ^ Это потому, что Lion не является подтипом Pet. Нижнее ограничение типа В то время как верхнее ограничение типа ограничивает тип до подтипа стороннего типа, нижнее ограничение типа объявляют тип супертипом стороннего типа. Термин B &gt;: A выражает то, что параметр типа B или абстрактный тип B относится к супертипу типа A. В большинстве случаев A будет задавать тип класса, а B - тип метода. Вот пример, где это полезно: trait Node[+B]: def prepend(elem: B): Node[B] case class ListNode[+B](h: B, t: Node[B]) extends Node[B]: def prepend(elem: B): ListNode[B] = ListNode(elem, this) def head: B = h def tail: Node[B] = t case class Nil[+B]() extends Node[B]: def prepend(elem: B): ListNode[B] = ListNode(elem, this) В данной программе реализован связанный список. Nil представляет пустой список. Класс ListNode - это узел, который содержит элемент типа B (head) и ссылку на остальную часть списка (tail). Класс Node и его подтипы ковариантны, потому что указанно +B. Однако эта программа не скомпилируется, потому что параметр elem в prepend имеет тип B, который объявлен ковариантным. Так это не работает, потому что функции контрвариантны в типах своих параметров и ковариантны в типах своих результатов. Чтобы исправить это, необходимо перевернуть вариантность типа параметра elem в prepend. Для этого вводится новый тип для параметра U, у которого тип B указан в качестве нижней границы типа. trait Node[+B]: def prepend[U &gt;: B](elem: U): Node[U] case class ListNode[+B](h: B, t: Node[B]) extends Node[B]: def prepend[U &gt;: B](elem: U): ListNode[U] = ListNode(elem, this) def head: B = h def tail: Node[B] = t case class Nil[+B]() extends Node[B]: def prepend[U &gt;: B](elem: U): ListNode[U] = ListNode(elem, this) Теперь можно сделать следующее: trait Bird case class AfricanSwallow() extends Bird case class EuropeanSwallow() extends Bird val africanSwallowList = ListNode[AfricanSwallow](AfricanSwallow(), Nil()) // africanSwallowList: ListNode[AfricanSwallow] = ListNode( // h = AfricanSwallow(), // t = Nil() // ) val birdList: Node[Bird] = africanSwallowList // birdList: Node[Bird] = ListNode(h = AfricanSwallow(), t = Nil()) birdList.prepend(EuropeanSwallow()) // res7: Node[Bird] = ListNode( // h = EuropeanSwallow(), // t = ListNode(h = AfricanSwallow(), t = Nil()) // ) Переменной с типом Node[Bird] можно присвоить значение africanSwallowList, а затем добавить и EuropeanSwallow. References: Scala3 book Scala tour, Upper type bounds Scala tour, Lower type bounds"
    } ,    
    {
      "title": "Определение типов",
      "url": "/scalaworkbook/docs/type-system/types-inferred.html",
      "content": "{{page.title}} Как и в других статически типизированных языках программирования, в Scala тип можно объявить при создании новой переменной: val x: Int = 1 val y: Double = 1 В этих примерах типы явно объявлены как Int и Double соответственно. Однако в Scala обычно не нужно объявлять тип при объявлении переменной: val a = 1 // a: Int = 1 val b = List(1, 2, 3) // b: List[Int] = List(1, 2, 3) val m = Map(1 -&gt; \"one\", 2 -&gt; \"two\") // m: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") Scala сама выводит типы, как показано выше. Действительно, большинство переменных определяются без указания типа, и способность Scala автоматически определять его — это одна из особенностей, которая делает Scala похожим на язык с динамической типизацией. References: Scala3 book"
    } ,    
    {
      "title": "Пересечение типов",
      "url": "/scalaworkbook/docs/type-system/types-intersection.html",
      "content": "{{page.title}} Используемый для типов оператор &amp; создает так называемый тип пересечения (intersection type). Тип A &amp; B представляет собой значения, которые одновременно относятся как к типу A, так и к типу B. Например, в следующем примере используется тип пересечения Resettable &amp; Growable[String]: trait Resettable: def reset(): Unit trait Growable[A]: def add(a: A): Unit def f(x: Resettable &amp; Growable[String]): Unit = x.reset() x.add(\"first\") В методе f в этом примере параметр x должен быть как Resettable, так и Growable[String]. Все члены типа пересечения A и B являются типом A и типом B. Следовательно, как показано, для Resettable &amp; Growable[String] доступны методы reset и add. Пересечение типов может быть полезно для структурного описания требований. В примере выше для f мы прямо заявляем, что нас устраивает любое значение для x, если оно является подтипом как Resettable, так и Growable. Нет необходимости создавать номинальный вспомогательный trait, подобный следующему: trait Both[A] extends Resettable, Growable[A] def f(x: Both[String]): Unit Существует важное различие между двумя вариантами определения f: в то время как оба позволяют вызывать f с экземплярами Both, только первый позволяет передавать экземпляры, которые являются подтипами Resettable и Growable[String], но не Both[String]. Обратите внимание, что &amp; коммутативно: A &amp; B имеет тот же тип, что и B &amp; A. Общие элементы Если элемент присутствует и в A, и в B, его тип в A &amp; B является пересечением типа в A и типа в B. Например, рассмотрим: trait A: def children: List[A] trait B: def children: List[B] val x: A &amp; B = new C val ys: List[A &amp; B] = x.children Тип children в A &amp; B является пересечением типа children в A и его типа в B, то есть List[A] &amp; List[B]. Это может быть дополнительно упрощено до List[A &amp; B], потому что List является ковариантным. При определении класса C, который наследует A и B, необходимо дать определение метода children с требуемым типом: class C extends A, B: def children: List[A &amp; B] = ??? Пример trait Book: def title: String trait Audio: def track: String case class AudioBook(title: String, track: String) extends Book, Audio case class BookAudio(title: String, track: String) extends Audio, Book trait Library: val first: Book def items: List[Book] trait Album: val first: Audio def items: List[Audio] class AudiobookLibrary(titles: String*) extends Library, Album: private val title: String = titles.head val first: Book &amp; Audio = AudioBook(title, \"empty\") def items: List[Book &amp; Audio] = titles.map(title =&gt; BookAudio(\"empty\", title)).toList val al = AudiobookLibrary(\"Пушкин\", \"Толстой\", \"Достоевский\") val book: Book = al.first // book: Book = AudioBook(title = \"Пушкин\", track = \"empty\") println(book.title) // Пушкин val books: List[Book] = al.items // books: List[Book] = List( // BookAudio(title = \"empty\", track = \"Пушкин\"), // BookAudio(title = \"empty\", track = \"Толстой\"), // BookAudio(title = \"empty\", track = \"Достоевский\") // ) books.foreach(b =&gt; println(b.title)) // empty // empty // empty val audio: Audio = al.first // audio: Audio = AudioBook(title = \"Пушкин\", track = \"empty\") println(audio.track) // empty val audios: List[Audio] = al.items // audios: List[Audio] = List( // BookAudio(title = \"empty\", track = \"Пушкин\"), // BookAudio(title = \"empty\", track = \"Толстой\"), // BookAudio(title = \"empty\", track = \"Достоевский\") // ) audios.foreach(a =&gt; println(a.track)) // Пушкин // Толстой // Достоевский Детали Правила подтипа T &lt;: A T &lt;: B ---------------- T &lt;: A &amp; B A &lt;: T ---------------- A &amp; B &lt;: T B &lt;: T ---------------- A &amp; B &lt;: T Из приведенных выше правил можно показать, что &amp; коммутативно: A &amp; B &lt;: B &amp; A для любых A и B. B &lt;: B A &lt;: A ---------- ----------- A &amp; B &lt;: B A &amp; B &lt;: A --------------------------- A &amp; B &lt;: B &amp; A Другими словами, A &amp; B - это тот же тип, что и B &amp; A, в том смысле, что эти два типа имеют одинаковые значения и являются подтипами друг друга. Если C - конструктор типа, то C[A] &amp; C[B] можно упростить, используя следующие три правила: если C ковариантно, C[A] &amp; C[B] ~&gt; C[A &amp; B] если C контравариантно, C[A] &amp; C[B] ~&gt; C[A | B] если C невариантно, выдается ошибка компиляции Когда C является ковариантным, C[A &amp; B] &lt;: C[A] &amp; C[B] можно вывести: A &lt;: A B &lt;: B ---------- --------- A &amp; B &lt;: A A &amp; B &lt;: B --------------- ----------------- C[A &amp; B] &lt;: C[A] C[A &amp; B] &lt;: C[B] ------------------------------------------ C[A &amp; B] &lt;: C[A] &amp; C[B] Когда C контравариантно, C[A | B] &lt;: C[A] &amp; C[B] можно вывести: A &lt;: A B &lt;: B ---------- --------- A &lt;: A | B B &lt;: A | B ------------------- ---------------- C[A | B] &lt;: C[A] C[A | B] &lt;: C[B] -------------------------------------------------- C[A | B] &lt;: C[A] &amp; C[B] Стирание типов Стертый тип для S &amp; T — это стираемый glb (наибольшая нижняя граница) стираемого типа S и T. Правила стирания типов пересечения приведены ниже в псевдокоде: |S &amp; T| = glb(|S|, |T|) glb(JArray(A), JArray(B)) = JArray(glb(A, B)) glb(JArray(T), _) = JArray(T) glb(_, JArray(T)) = JArray(T) glb(A, B) = A if A extends B glb(A, B) = B if B extends A glb(A, _) = A if A is not a trait glb(_, B) = B if B is not a trait glb(A, _) = A // use first См. также TypeErasure#erasedGlb Связь с составным типом (with) Типы пересечения A &amp; B заменяют составные типы A with B. На данный момент синтаксис A with B по-прежнему разрешен и интерпретируется как A &amp; B, но его использование в качестве типа (в отличие от предложения new или extends) будет объявлено устаревшим и удалено в будущем. References: Scala3 book Scala 3 Reference Scala 3 Reference, Details"
    } ,    
    {
      "title": "Непрозрачные типы",
      "url": "/scalaworkbook/docs/type-system/types-opaque.html",
      "content": "{{page.title}} Непрозрачные (opaque) псевдонимы типов Scala 3 обеспечивают абстракции типов без каких-либо накладных расходов. Накладные расходы на абстракцию Предположим, что необходимо определить модуль, предлагающий арифметические операции над числами, которые представлены их логарифмами. Это может быть полезно для повышения точности, когда числовые значения очень большие или близкие к нулю. Поскольку важно отличать “обычные” двойные значения от чисел, хранящихся в виде их логарифмов, введем класс Logarithm: class Logarithm(protected val underlying: Double): def toDouble: Double = math.exp(underlying) def + (that: Logarithm): Logarithm = // здесь используется метод apply сопутствующего объекта Logarithm(this.toDouble + that.toDouble) def * (that: Logarithm): Logarithm = new Logarithm(this.underlying + that.underlying) object Logarithm: def apply(d: Double): Logarithm = new Logarithm(math.log(d)) Метод apply сопутствующего объекта позволяет создавать значения типа Logarithm, которые можно использовать следующим образом: val l2 = Logarithm(2.0) val l3 = Logarithm(3.0) println((l2 * l3).toDouble) // 6.0 println((l2 + l3).toDouble) // 4.999999999999999 В то время как класс Logarithm предлагает хорошую абстракцию для значений Double, которые хранятся в этой конкретной логарифмической форме, это накладывает серьезные накладные расходы на производительность: для каждой отдельной математической операции нужно извлекать значение underlying, а затем снова обернуть его в новый экземпляр Logarithm. Модульные абстракции Рассмотрим другой подход к реализации той же библиотеки. На этот раз вместо того, чтобы определять Logarithm как класс, определяем его с помощью псевдонима типа. Во-первых, зададим абстрактный интерфейс модуля: trait Logarithms: type Logarithm // operations on Logarithm def add(x: Logarithm, y: Logarithm): Logarithm def mul(x: Logarithm, y: Logarithm): Logarithm // functions to convert between Double and Logarithm def make(d: Double): Logarithm def extract(x: Logarithm): Double // extension methods to use `add` and `mul` as \"methods\" on Logarithm extension (x: Logarithm) def toDouble: Double = extract(x) def + (y: Logarithm): Logarithm = add(x, y) def * (y: Logarithm): Logarithm = mul(x, y) Теперь давайте реализуем этот абстрактный интерфейс, задав тип Logarithm равным Double: object LogarithmsImpl extends Logarithms: type Logarithm = Double // operations on Logarithm def add(x: Logarithm, y: Logarithm): Logarithm = make(x.toDouble + y.toDouble) def mul(x: Logarithm, y: Logarithm): Logarithm = x + y // functions to convert between Double and Logarithm def make(d: Double): Logarithm = math.log(d) def extract(x: Logarithm): Double = math.exp(x) В рамках реализации LogarithmsImpl уравнение Logarithm = Double позволяет реализовать различные методы. Дырявые абстракции Однако эта абстракция немного “дырява”. Мы должны убедиться, что всегда программируем только с абстрактным интерфейсом Logarithms и никогда не используем LogarithmsImpl напрямую. Прямое использование LogarithmsImpl сделало бы равенство Logarithm = Double видимым для пользователя, который может случайно использовать Double там, где ожидается логарифмическое удвоение. Например: import LogarithmsImpl.* val l: Logarithm = make(1.0) val d: Double = l // type checks AND leaks the equality! Необходимость разделения модуля на абстрактный интерфейс и реализацию может быть полезной, но также требует больших усилий, чтобы просто скрыть детали реализации Logarithm. Программирование с использованием абстрактного модуля Logarithms может быть очень утомительным и часто требует использования дополнительных функций, таких как типы, зависящие от пути, как в следующем примере: def someComputation(L: Logarithms)(init: L.Logarithm): L.Logarithm = ... Накладные расходы упаковки/распаковки Абстракции типов, такие как type Logarithm, стираются в соответствии с их привязкой (Any - в нашем случае). То есть, хотя нам не нужно вручную переносить и разворачивать значение Double, все равно будут некоторые накладные расходы, связанные с упаковкой примитивного типа Double. Непрозрачные типы Вместо того, чтобы вручную разбивать компонент Logarithms на абстрактную часть и на конкретную реализацию, можно просто использовать opaque типы для достижения аналогичного эффекта: object MyMath: // !!! opaque type Logarithm = Double // два способа использования типа Logarithm object Logarithm: def apply(d: Double): Logarithm = math.log(d) def safe(d: Double): Option[Logarithm] = if d &gt; 0.0 then Some(math.log(d)) else None end Logarithm extension (x: Logarithm) def toDouble: Double = math.exp(x) def + (y: Logarithm): Logarithm = Logarithm(math.exp(x) + math.exp(y)) def * (y: Logarithm): Logarithm = x + y end MyMath Тот факт, что Logarithm совпадает с Double, известен только в области, где он определен, которая в приведенном выше примере соответствует объекту MyMath. Или, другими словами, внутри области видимости Logarithm рассматривается как псевдоним типа, но он полностью инкапсулирован или “непрозрачен” (opaque) для внешнего мира, где, как следствие, Logarithm рассматривается как абстрактный тип, не имеющий ничего общего с Double. Равенство Logarithm = Double может использоваться для реализации методов (например, * и toDouble). Общедоступный API Logarithm состоит из методов apply и safe, определенных в сопутствующем объекте. Они преобразуются из Double в значения Logarithm. Более того, операции toDouble, которые преобразуют в другую сторону, и операции + и * определяются как методы расширения над значениями Logarithm. Следующие операции допустимы, поскольку они используют функциональные возможности, реализованные в объекте MyMath. import MyMath.Logarithm val l = Logarithm(1.0) // l: Logarithm = 0.0 val l2 = Logarithm(2.0) // l2: Logarithm = 0.6931471805599453 val l3 = l * l2 // l3: Logarithm = 0.6931471805599453 val l4 = l + l2 // l4: Logarithm = 1.0986122886681098 Но следующие операции приведут к ошибкам типа: val d: Double = l // error: found: Logarithm, required: Double val l2: Logarithm = 1.0 // error: found: Double, required: Logarithm l * 2 // error: found: Int(2), required: Logarithm l / l2 // error: `/` is not a member of Logarithm Несмотря на то, что мы абстрагировались от Logarithm, абстракция предоставляется бесплатно: поскольку существует только одна реализация, во время выполнения не будет накладных расходов на упаковку для примитивных типов, таких как Double. Границы псевдонимов непрозрачных типов Псевдонимы непрозрачных типов также могут иметь ограничения. Пример: object Access: opaque type Permissions = Int opaque type PermissionChoice = Int opaque type Permission &lt;: Permissions &amp; PermissionChoice = Int extension (x: PermissionChoice) def | (y: PermissionChoice): PermissionChoice = x | y extension (x: Permissions) def &amp; (y: Permissions): Permissions = x | y extension (granted: Permissions) def is(required: Permissions) = (granted &amp; required) == required def isOneOf(required: PermissionChoice) = (granted &amp; required) != 0 val NoPermission: Permission = 0 val Read: Permission = 1 val Write: Permission = 2 val ReadWrite: Permissions = Read | Write val ReadOrWrite: PermissionChoice = Read | Write end Access Объект Access определяет три псевдонима непрозрачного типа: Permission, представляющий одно разрешение, Permissions, представляющий набор разрешений со значением “все эти разрешения предоставлены”, PermissionChoice, представляющий набор разрешений со значением “по крайней мере одно из этих разрешений предоставлено”. Вне объекта Access значения типа Permissions могут быть объединены с помощью оператора &amp;, где x &amp; y означает “все разрешения в x и в y предоставлены”. Значения типа PermissionChoice можно комбинировать с помощью оператора |, где x | y означает “разрешение в x или y предоставлено”. Обратите внимание, что внутри объекта Access операторы &amp; и | всегда разрешаются в соответствующие методы Int, поскольку члены всегда имеют приоритет над методами расширения. По этой причине метод расширения | в Access не вызывает бесконечную рекурсию. В частности, определение ReadWrite должно использовать |, побитовый оператор для Int, даже если внешний клиентский код Access будет использовать &amp;, метод расширения для Permissions. Внутренние представления ReadWrite и ReadOrWrite идентичны, но это не видно клиенту, которого интересует только семантика Permissions, как в примере ниже. Все три псевдонима непрозрачного типа имеют один и тот же базовый тип представления Int. Тип Permission имеет верхнюю границу Permissions &amp; PermissionChoice. Это дает понять за пределами объекта Access, что Permission является подтипом двух других типов. Следовательно, следующий сценарий использования проходит type-checks. object User: import Access.* case class Item(rights: Permissions) extension (item: Item) def +(other: Item): Item = Item(item.rights &amp; other.rights) val roItem = Item(Read) // OK, since Permission &lt;: Permissions val woItem = Item(Write) val rwItem = Item(ReadWrite) val noItem = Item(NoPermission) assert(!roItem.rights.is(ReadWrite)) assert(roItem.rights.isOneOf(ReadOrWrite)) assert(rwItem.rights.is(ReadWrite)) assert(rwItem.rights.isOneOf(ReadOrWrite)) assert(!noItem.rights.is(ReadWrite)) assert(!noItem.rights.isOneOf(ReadOrWrite)) assert((roItem + woItem).rights.is(ReadWrite)) end User С другой стороны, вызов roItem.rights.isOneOf(ReadWrite) выдаст ошибку типа: assert(roItem.rights.isOneOf(ReadWrite)) ^^^^^^^^^ Found: (Access.ReadWrite : Access.Permissions) Required: Access.PermissionChoice Permissions и PermissionChoice являются разными, несвязанными типами вне Access. Члены непрозрачного типа в классах Хотя обычно непрозрачные типы используются вместе с объектами, чтобы скрыть детали реализации модуля, их также можно использовать с классами. Например, можно переопределить приведенный выше пример логарифмов как класс. class Logarithms: opaque type Logarithm = Double def apply(d: Double): Logarithm = math.log(d) def safe(d: Double): Option[Logarithm] = if d &gt; 0.0 then Some(math.log(d)) else None def mul(x: Logarithm, y: Logarithm) = x + y Члены непрозрачного типа разных экземпляров обрабатываются как разные: val l1 = new Logarithms val l2 = new Logarithms val x = l1(1.5) val y = l1(2.6) val z = l2(3.1) l1.mul(x, y) // type checks l1.mul(x, z) // error: found l2.Logarithm, required l1.Logarithm В общем, можно думать о непрозрачном типе как о прозрачном только в пределах private[this]. Резюме Непрозрачные типы предлагают надежную абстракцию над деталями реализации, не накладывая расходов на производительность. Как показано выше, непрозрачные типы удобны в использовании и очень хорошо интегрируются с функцией методов расширения. Подробнее об opaque type: Мотивация Детали References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Другие типы",
      "url": "/scalaworkbook/docs/type-system/types-others.html",
      "content": "{{page.title}} В Scala есть несколько других расширенных типов, в том числе: existential types higher-kinded types singleton types refinement types References: Scala3 book"
    } ,    
    {
      "title": "Структурные типы",
      "url": "/scalaworkbook/docs/type-system/types-structural.html",
      "content": "{{page.title}} Некоторые варианты использования, такие как моделирование доступа к базе данных, более удобны в динамически типизированных языках, чем в статически типизированных языках. С динамически типизированными языками естественно моделировать строку как запись или объект и выбирать записи с помощью простых точечных обозначений, например row.columnName. Достижение того же результата в статически типизированном языке требует определения класса для каждой возможной строки, возникающей в результате манипуляций с базой данных, включая строки, возникающие в результате join и проектирования, и настройки схемы для сопоставления между строкой и представляющим ее классом. Это требует большого количества шаблонов, что заставляет разработчиков менять преимущества статической типизации на более простые схемы, в которых имена столбцов представляются в виде строк и передаются другим операторам, например row.select(\"columnName\"). Этот подход лишен преимуществ статической типизации и все еще не так естественен, как динамически типизируемая версия. Структурные типы (structural types) помогают в ситуациях, когда желательно поддерживать простую точечную нотацию в динамических контекстах, не теряя преимуществ статической типизации. Они также позволяют разработчикам настраивать, как должны определяться поля и методы. Пример Вот пример структурного типа Person: class Record(elems: (String, Any)*) extends Selectable: private val fields = elems.toMap def selectDynamic(name: String): Any = fields(name) type Person = Record { val name: String val age: Int } Тип Person добавляет уточнение (refinement) к своему родительскому типу Record, которое определяет поля name и age. Говорится, что уточнение носит структурный (structural) характер, поскольку name и age не определены в родительском типе. Но тем не менее они существуют как члены класса Person. Например, следующая программа напечатала бы “Emma is 42 years old.”: val person = Record( \"name\" -&gt; \"Emma\", \"age\" -&gt; 42 ).asInstanceOf[Person] println(s\"${person.name} is ${person.age} years old.\") Родительский тип Record в этом примере представляет собой универсальный класс, который может в своем аргументе elems принимать произвольные записи. Этот аргумент - последовательность пар ключей типа String и значений типа Any. Когда создается Person как Record, необходимо с помощью приведения типов задать, что запись определяет правильные поля правильных типов. Сама Record слишком слабо типизирована, поэтому компилятор не может знать об этом без помощи пользователя. На практике связь между структурным типом и его базовым общим представлением, скорее всего, будет выполняться на уровне базы данных и, следовательно, не будет беспокоить конечного пользователя. Record расширяет маркер trait scala.Selectable и определяет метод selectDynamic, который сопоставляет имя поля с его значением. Выбор элемента структурного типа выполняется путем вызова соответствующего метода. person.name и person.age преобразуются компилятором Scala в: person.selectDynamic(\"name\").asInstanceOf[String] person.selectDynamic(\"age\").asInstanceOf[Int] Второй пример Чтобы закрепить сказанное, вот еще один структурный тип с именем Book, представляющий книгу, доступную в базе данных: type Book = Record { val title: String val author: String val year: Int val rating: Double } Как и в случае с Person, экземпляр Book создается следующим образом: val book = Record( \"title\" -&gt; \"The Catcher in the Rye\", \"author\" -&gt; \"J. D. Salinger\", \"year\" -&gt; 1951, \"rating\" -&gt; 4.5 ).asInstanceOf[Book] Класс Selectable Помимо selectDynamic класс Selectable иногда также определяет метод applyDynamic, который можно использовать для замены вызовов функций на вызов структурных элементов. Таким образом, если a является экземпляром Selectable, структурный вызов типа a.f(b, c) преобразуется в: a.applyDynamic(\"f\")(b, c) References: Scala3 book Scala 3 Reference Scala 3 Reference, Details"
    } ,    
    {
      "title": "Объединение типов",
      "url": "/scalaworkbook/docs/type-system/types-union.html",
      "content": "{{page.title}} Используемый для типов | оператор создает так называемый тип объединения (union type). Тип А | B представляет значения, которые относятся либо к типу A, либо к типу B. В следующем примере метод help принимает параметр с именем id типа объединения Username | Password, который может быть либо Username, либо Password: case class Username(name: String) case class Password(hash: Hash) def help(id: Username | Password) = val user = id match case Username(name) =&gt; lookupName(name) case Password(hash) =&gt; lookupPassword(hash) // ... help реализуется используя pattern matching. Этот код является гибким и типобезопасным решением. Если попытаться передать тип, отличный от Username или Password, компилятор пометит это как ошибку: help(\"hi\") // error: Found: (\"hi\" : String) // Required: Username | Password Ошибка также будет получена, если попытаться добавить case в выражение match, которое не соответствует типам Username или Password: case 1.0 =&gt; ??? // ERROR: this line won’t compile Альтернатива объединенным типам Как показано, объединенные типы могут использоваться для представления вариантов нескольких разных типов, не требуя, чтобы эти типы были частью специально созданной иерархии классов. Предварительное планирование иерархии классов Другие языки требуют предварительного планирования иерархии классов, как показано в следующем примере: trait UsernameOrPassword case class Username(name: String) extends UsernameOrPassword case class Password(hash: Hash) extends UsernameOrPassword def help(id: UsernameOrPassword) = ... Предварительное планирование не очень хорошо масштабируется, поскольку, например, требования пользователей API могут быть непредсказуемыми. Кроме того, загромождение иерархии типов маркерами типа UsernameOrPassword затрудняет чтение кода. Теговые объединения Другой альтернативой является задание отдельного типа перечисления, например: enum UsernameOrPassword: case IsUsername(u: Username) case IsPassword(p: Password) Перечисление UsernameOrPassword представляет собой помеченное объединение Username и Password. Однако этот способ моделирования объединения требует явной упаковки и распаковки, и, например, Username не является подтипом UsernameOrPassword. Вывод типов объединения Компилятор присваивает типу объединения выражение, только если такой тип явно задан. Например, рассмотрим такие значения: val name = Username(\"Eve\") // name: Username = Username(name = \"Eve\") val password = Password(123) // password: Password = Password(hash = 123) В этом примере показано, как можно использовать тип объединения при привязке переменной к результату выражения if/else: val a = if (true) name else password // a: Object = Username(name = \"Eve\") val b: Password | Username = if (true) name else password // b: Password | Username = Username(name = \"Eve\") Типом a является Object, который является супертипом Username и Password, но не наименьшим супертипом, Password | Username. Если необходим наименьший супертип, его нужно указать явно, как это делается для b. Типы объединения являются двойственными типам пересечения. И как &amp; с типами пересечения, | также коммутативен: A | B того же типа, что и B | А. Детали Взаимодействие в сопоставлении с образцом | также используется при сопоставлении шаблонов с отдельными альтернативами шаблонов и имеет более низкий приоритет, чем : используемый в типизированных шаблонах. Это означает, что: case _: A | B =&gt; ... эквивалентен: case (_: A) | B =&gt; ... , а не: case _: (A | B) =&gt; ... Правила подтипа Правила подтипа: A всегда является подтипом A | B для всех A, B если A &lt;: C и B &lt;: C, тогда A | B &lt;: C | является коммутативным и ассоциативным подобно &amp;: A | B =:= B | A A | (B | C) =:= (A | B) | C &amp; является дистрибутивным по |: A &amp; (B | C) =:= A &amp; B | A &amp; C Из этих правил следует, что наименьшая верхняя граница (LUB - least upper bound) множества типов есть объединение этих типов. Мотивация Основная причина введения типов объединения в Scala заключается в том, что они позволяют гарантировать, что для каждого набора типов всегда можно сформировать конечный LUB. Кроме того, типы объединения являются полезной конструкцией при попытке дать типы существующим API с динамической типизацией, поэтому они являются неотъемлемой частью TypeScript и даже частично реализованы в Scala.js. Соединение типа union В некоторых ситуациях, описанных ниже, тип объединения может потребовать расшириться до типа, не являющегося объединением, для этой цели мы определяем соединение типа объединения T1 | ... | Tn как наименьший тип пересечения экземпляров базовых классов T1,..., Tn. Обратите внимание, что типы объединения могут по-прежнему отображаться как аргументы типа в результирующем типе, это гарантирует, что объединение всегда конечно. Дано: trait C[+T] trait D trait E class A extends C[A] with D class B extends C[B] with D with E Объединение A | B - это C[A | B] &amp; D. Вывод типа При выводе типа результата определения (переменной или метода - val, var, def), если тип, который собираемся вывести, является типом объединения, он заменяется объединением. Пример: import scala.collection.mutable.ListBuffer val x = ListBuffer(Right(\"foo\"), Left(0)) val y: ListBuffer[Either[Int, String]] = x Этот код проходит проверку типов, потому что аргумент предполагаемого типа ListBuffer в правой части x - Left[Int, Nothing] | Right[Nothing, String] - был расширен до Either[Int, String]. Если бы компилятор не сделал этого расширения, последняя строка не проходила бы проверку типов, потому что ListBuffer инвариантен в своем аргументе. Элементы Элементы типа union являются элементами его объединения. Пример Следующий код не проходит проверку типов, так как метод hello не является членом AnyRef, который является объединением A | B. trait A { def hello: String } trait B { def hello: String } def test(x: A | B) = x.hello // error: value `hello` is not a member of A | B С другой стороны, допускается следующее: trait D trait E trait C { def hello: String } trait A extends C with D trait B extends C with E def test(x: A | B) = x.hello // ok, т.к. `hello` - элемент объединения A | B, который является подтипом C При этом необходимо отметить, что в метод test нельзя передать экземпляр С, потому что A | B - подтип C, но не наоборот: val a: A = new A: def hello = \"Hello, A!\" val b: B = new B: def hello = \"Hello, B!\" test(a) // res1: String = \"Hello, A!\" test(b) // res2: String = \"Hello, B!\" val c: C = new C: def hello = \"Hello, C!\" test(c) // error: // Found: (App0.this.c : App0.this.C) // Required: App0.this.A | App0.this.B // test(c) // ^ Проверка полноты в сопоставлении с образцом Если селектор совпадения с образцом является типом объединения, совпадение считается исчерпывающим, если охватываются все части объединения. Пример: trait A { def hello: String } trait B { def hello: String } def matching(x: A | B): String = x match case a: A =&gt; a.hello case b: B =&gt; b.hello case c: C =&gt; c.hello // Лишнее -- [E030] Match case Unreachable Warning: -------------------------------------- 5 | case c: C =&gt; c.hello | ^^^^ | Unreachable case Стирание типов Стертый тип для A | B является наименьшей верхней границей (erased least upper bound) стираемых типов A и B. Цитата из документации TypeErasure#erasedLub, стертый LUB вычисляется следующим образом: если оба аргумента являются массивами объектов, LUB - массив стертых LUB типов элементов если оба аргумента являются массивами одних и тех же примитивов, LUB - массив этого примитива если один аргумент — массив примитивов, а другой — массив объектов, LUB - Object если один аргумент является массивом, LUB - Object в противном случае общий суперкласс или trait S классов аргументов со следующими двумя свойствами: S минимален: никакой другой общий суперкласс или признак не происходит от S. S является последним: в линеаризации первого типа аргумента |A| нет минимальных общих суперклассов или трейтов, которые идут после S. References: Scala3 book Scala 3 Reference Scala 3 Reference, Details"
    } ,    
    {
      "title": "Ковариантность",
      "url": "/scalaworkbook/docs/type-system/types-variance.html",
      "content": "Ковариантность типов Вариантность параметра типа управляет подтипом параметризованных типов (таких, как классы или trait-ы). Чтобы разобраться в вариантности, рассмотрим следующий пример типов: trait Item { def productNumber: String } trait Buyable extends Item { def price: Int } trait Book extends Buyable { def isbn: String } Предположим также следующие параметризованные типы: // пример инвариантного типа trait Pipeline[T]: def process(t: T): T // пример ковариантного типа trait Producer[+T]: def make: T // пример контрвариантного типа trait Consumer[-T]: def take(t: T): Unit В целом существует три режима вариантности (variance): инвариант (invariant) — значение по умолчанию, написанное как Pipeline[T] ковариантный (covariant) — помечен знаком +, например Producer[+T] контравариантный (contravariant) — помечен знаком -, как в Consumer[-T] Подробнее рассмотрим, что означает и как используется эта аннотация. Инвариантные типы По умолчанию такие типы, как Pipeline, инвариантны в своем аргументе типа (в данном случае T). Это означает, что такие типы, как Pipeline[Item], Pipeline[Buyable] и Pipeline[Book], не являются подтипами друг друга. Предположим, что следующий метод использует два значения (b1, b2) типа Pipeline[Buyable] и передает свой аргумент b методу process при его вызове на b1 и b2: def oneOf( p1: Pipeline[Buyable], p2: Pipeline[Buyable], b: Buyable ): Buyable = val b1 = p1.process(b) val b2 = p2.process(b) if b1.price &lt; b2.price then b1 else b2 Напомним, что отношения подтипов между типами следующие: Book &lt;: Buyable &lt;: Item. Мы не можем передать Pipeline[Book] методу oneOf, потому что в реализации oneOf мы вызываем p1 и p2 со значением типа Buyable. Pipeline[Book] ожидает Book, что потенциально может вызвать runtime error. Мы не можем передать Pipeline[Item], потому что вызов process обещает вернуть Item; однако мы должны вернуть Buyable. Почему Инвариант? На самом деле тип Pipeline должен быть инвариантным, так как он использует свой параметр типа T и в качестве аргумента, и в качестве типа возвращаемого значения. По той же причине некоторые типы в библиотеке коллекций Scala, такие как Array или Set, также являются инвариантными. Ковариантные типы В отличие от Pipeline, который является инвариантным, тип Producer помечается как ковариантный (covariant) путем добавления к параметру типа префикса +. Это допустимо, так как параметр типа используется только в качестве типа возвращаемого значения. Пометка типа как ковариантного означает, что мы можем передать (или вернуть) Producer[Book] там, где ожидается Producer[Buyable]. И на самом деле, это разумно. Тип Producer[Buyable].make только обещает вернуть Buyable. Но для пользователей make, так же допустимо принять Book, который является подтипом Buyable. Это иллюстрируется следующим примером, где функция makeTwo ожидает Producer[Buyable]: def makeTwo(p: Producer[Buyable]): Int = p.make.price + p.make.price Допустимо передать в makeTwo производителя книг: val bookProducer: Producer[Book] = ??? makeTwo(bookProducer) Вызов price в рамках makeTwo по-прежнему действителен и для Book. Ковариантные типы для неизменяемых контейнеров Ковариантность чаще всего встречается при работе с неизменяемыми контейнерами, такими как List, Seq, Vector и т.д. Например, List и Vector определяются приблизительно так: class List[+A] ... class Vector[+A] ... Таким образом, можно использовать List[Book] там, где ожидается List[Buyable]. Это также интуитивно имеет смысл: если ожидается коллекция вещей, которые можно купить, то вполне допустимо получить коллекцию книг. В примере выше у книг есть дополнительный метод isbn, но дополнительные возможности можно игнорировать. Контравариантные типы В отличие от типа Producer, который помечен как ковариантный, тип Consumer помечен как контравариантный (contravariant) путем добавления к параметру типа префикса -. Это допустимо, так как параметр типа используется только в позиции аргумента. Пометка его как контравариантного означает, что можно передать (или вернуть) Consumer[Item] там, где ожидается Consumer[Buyable]. То есть у нас есть отношение подтипа Consumer[Item] &lt;: Consumer[Buyable]. Помните, что для типа Producer все было наоборот, и у нас был Producer[Buyable] &lt;: Producer[Item]. Метод Consumer[Item].take принимает Item. Как вызывающий take, мы также можем предоставить Buyable, который будет с радостью принят Consumer[Item], поскольку Buyable — это подтип Item, то есть, по крайней мере, Item. Контравариантные типы для потребителей Контравариантные типы встречаются гораздо реже, чем ковариантные типы. Наиболее важным типом, помеченным как контравариантный, с которым можно столкнуться, является тип функций: trait Function[-A, +B]: def apply(a: A): B Тип аргумента A помечен как контравариантный A — он использует значения типа A. Тип результата B, напротив, помечен как ковариантный — он создает значения типа B. Вот несколько примеров, иллюстрирующих отношения подтипов, вызванные аннотациями вариантности функций: val f: Function[Buyable, Buyable] = b =&gt; b // OK - допустимо вернуть Buyable там, где ожидается Item val g: Function[Buyable, Item] = f // OK - допустимо передать аргумент Book туда, где ожидается Buyable val h: Function[Book, Buyable] = f Резюме В этом разделе были рассмотрены три различных вида вариантности: Producers обычно ковариантны и помечают свой параметр типа со знаком +. Это справедливо и для неизменяемых коллекций. Consumers обычно контравариантны и помечают свой параметр типа со знаком -. Типы, которые являются одновременно производителями и потребителями, должны быть инвариантными и не требуют какой-либо маркировки для параметра своего типа. В эту категорию, в частности, попадают изменяемые коллекции, такие как Array. References: Scala3 book"
    } ,    
    {
      "title": "Типы данных",
      "url": "/scalaworkbook/docs/types.html",
      "content": "{{page.title}} В этом разделе представлен обзор переменных и типов данных Scala. Два вида переменных Переменная может быть неизменяемой или изменяемой: Тип Описание val Создает неизменяемую переменную, подобную final в Java. Согласно стандартам Scala и функционального программирования желательно всегда создавать переменную с помощью val. var Создает изменяемую переменную. Практически не используется в Scala, т.к. изменяемая переменная противоречит принципам функционального программирования. В примере показано, как создавать val и var переменные: val a = 0 // a: Int = 0 var b = 1 // b: Int = 1 Значение val не может быть переназначено. Если попытаться переназначить, то будет получена ошибка компиляции: val msg = \"Hello, world\" msg = \"Aloha\" // error: // Reassignment to val msg // msg = \"Aloha\" // ^^^^^^^^^^^^^ И наоборот, var может быть переназначен: var msg = \"Hello, world\" // msg: String = \"Hello, world\" msg = \"Aloha\" msg // res1: String = \"Aloha\" Объявление типов переменных Когда создается переменная, можно явно объявить ее тип или позволить определить тип компилятору: val x: Int = 1 val x = 1 Вторая форма известна как вывод типа (type inference), и это отличный способ помочь сохранить код кратким. Компилятор Scala обычно может определить тип данных, как показано в выходных данных этих примеров: val x = 1 // x: Int = 1 val s = \"a string\" // s: String = \"a string\" val nums = List(1, 2, 3) // nums: List[Int] = List(1, 2, 3) Всегда можно явно объявить тип переменной, но в простых примерах, подобных этим, в этом нет необходимости: val x: Int = 1 val s: String = \"a string\" val p: Person = Person(\"Richard\") В Scala все значения имеют тип, включая числовые значения и функции. Иерархия типов в Scala Приведенная ниже диаграмма иллюстрирует подмножество иерархии типов. Any - это супертип всех типов, также называемый the top type. Он определяет универсальные методы, такие как equals, hashCode и toString. У верхнего типа Any есть подтип Matchable, который используется для обозначения всех типов, для которых возможно выполнить pattern matching. Важно гарантировать вызов свойства “параметричность”, что вкратце означает, что мы не можем сопоставлять шаблоны для значений типа Any, а только для значений, которые являются подтипом Matchable. Справочная документация содержит более подробную информацию о Matchable. Matchable имеет два важных подтипа: AnyVal и AnyRef. AnyVal представляет типы значений. Существует несколько предопределенных типов значений, и они non-nullable: Double, Float, Long, Int, Short, Byte, Char, Unit и Boolean. Unit - это тип значения, который не несет никакой значимой информации. Существует ровно один экземпляр Unit - (). AnyRef представляет ссылочные типы. Все типы, не являющиеся значениями, определяются как ссылочные типы. Каждый пользовательский тип в Scala является подтипом AnyRef. Если Scala используется в контексте среды выполнения Java, AnyRef соответствует java.lang.Object. В языках, основанных на операторах, void используется для методов, которые ничего не возвращают. В Scala для методов, которые не имеют возвращаемого значения, такие как следующий метод, для той же цели используется Unit: def printIt(a: Any): Unit = println(a) Вот пример, демонстрирующий, что строки, целые числа, символы, логические значения и функции являются экземплярами Any и могут обрабатываться так же, как и любой другой объект: val list: List[Any] = List( \"a string\", 732, 'c', true, () =&gt; \"an anonymous function returning a string\" ) // list: List[Any] = List( // \"a string\", // 732, // 'c', // true, // &lt;function&gt; // ) Код определяет список значений типа List[Any]. Список инициализируется элементами различных типов, но каждый из них является экземпляром scala.Any, поэтому мы можем добавить их в список. Типы значений в Scala Как показано выше, числовые типы Scala расширяют AnyVal, и все они являются полноценными объектами. В этих примерах показано, как объявлять переменные этих числовых типов: val b: Byte = 1 val i: Int = 1 val l: Long = 1 val s: Short = 1 val d: Double = 2.0 val f: Float = 3.0 В первых четырех примерах, если явно не указать тип, то число 1 по умолчанию будет равно Int, поэтому, если нужен один из других типов данных — Byte, Long или Short — необходимо явно объявить эти типы. Числа с десятичной дробью (например, 2.0) по умолчанию будут иметь значение Double, поэтому, если необходим Float, нужно объявить Float явно, как показано в последнем примере. Поскольку Int и Double являются числовыми типами по умолчанию, их можно создавать без явного объявления типа данных: val i = 123 // i: Int = 123 val j = 1.0 // j: Double = 1.0 Также можно добавить символы L, D, and F (или их эквивалент в нижнем регистре) для того, чтобы задать Long, Double, или Float значения: val x = 1_000L // x: Long = 1000L val y = 2.2D // y: Double = 2.2 val z = 3.3F // z: Float = 3.3F В Scala также есть типы String (значение заключается в двойные кавычки или три двойных) и Char (значение заключается в одинарные кавычки): val name = \"Bill\" // name: String = \"Bill\" val c = 'a' // c: Char = 'a' BigInt и BigDecimal Для действительно больших чисел можно использовать типы BigInt и BigDecimal: var a = BigInt(1_234_567_890_987_654_321L) // a: BigInt = 1234567890987654321 var b = BigDecimal(123_456.789) // b: BigDecimal = 123456.789 Где Double и Float являются приблизительными десятичными числами, а BigDecimal используется для точной арифметики, например, при работе с валютой. BigInt и BigDecimal поддерживают все привычные числовые операторы: val b = BigInt(1234567890) // b: BigInt = 1234567890 val c = b + b // c: BigInt = 2469135780 val d = b * b // d: BigInt = 1524157875019052100 Строки Строки Scala похожи на строки Java, но у них есть две замечательные дополнительные функции: они поддерживают интерполяцию строк создавать многострочные строки очень просто String interpolation Интерполяция строк обеспечивает очень удобный способ использования переменных внутри строк. Например, учитывая эти три переменные: val firstName = \"John\" val mi = 'C' val lastName = \"Doe\" их комбинацию можно получить так: s\"Name: $firstName $mi $lastName\" // res4: String = \"Name: John C Doe\" Достаточно поставить перед строкой букву s, а затем - символ $ перед именами переменных внутри строки. Чтобы вставить произвольные выражения в строку, они заключаются в фигурные скобки: s\"2 + 2 = ${2 + 2}\" // res6: String = \"2 + 2 = 4\" val x = -1 // x: Int = -1 s\"x.abs = ${x.abs}\" // res7: String = \"x.abs = 1\" Символ s, помещенный перед строкой, является лишь одним из возможных интерполяторов. Если использовать f вместо s, можно использовать синтаксис форматирования в стиле printf в строке. Кроме того, интерполятор строк - это всего лишь специальный метод, и его можно определить самостоятельно. Например, некоторые библиотеки баз данных определяют очень мощный интерполятор sql. Для экранирования символа \" в интерполяции используется символ $: val inventor = \"Thomas Edison\" // inventor: String = \"Thomas Edison\" val interpolation = s\"as $inventor said: $\"The three great essentials to achieve anything worth while are: Hard work, Stick-to-itiveness, and Common sense.$\"\" // interpolation: String = \"as Thomas Edison said: \\\"The three great essentials to achieve anything worth while are: Hard work, Stick-to-itiveness, and Common sense.\\\"\" println(interpolation) // as Thomas Edison said: \"The three great essentials to achieve anything worth while are: Hard work, Stick-to-itiveness, and Common sense.\" Multiline strings Многострочные строки создаются путем включения строки в три двойные кавычки: println(\"\"\"The essence of Scala: Fusion of functional and object-oriented programming in a typed setting.\"\"\") // The essence of Scala: // Fusion of functional and object-oriented // programming in a typed setting. Одним из недостатков базового подхода является то, что строки после первой имеют отступ. Если важно исключить отступ, можно поставить символ | перед всеми строками после первой и вызвать метод stripMargin после строки: println(\"\"\"The essence of Scala: |Fusion of functional and object-oriented |programming in a typed setting.\"\"\".stripMargin) // The essence of Scala: // Fusion of functional and object-oriented // programming in a typed setting. Теперь все строки выравниваются по левому краю. Здесь также можно использовать переменные внутри строки, добавив s перед первыми \"\"\". Приведение типов Типы значений могут быть приведены следующим образом: Например: val x: Int = 987654321 // x: Int = 987654321 val y: Long = x // y: Long = 987654321L val face: Char = '☺' // face: Char = '☺' val number: Int = face // number: Int = 9786 Приведение типов однонаправленное, следующий код не будет компилиться: val a: Long = 987654321 val b: Float = a val c: Long = b // val c: Long = b // ^ // Found: (b : Float) // Required: Long Неявное приведение типов в некоторых случаях помечено как deprecated и может быть запрещено в будущих версиях: val x: Long = 987654321 val y: Float = x // method long2float in object Long is deprecated since 2.13.1: Implicit conversion from Long to Float is dangerous because it loses precision. Write `.toFloat` instead. // val y: Float = x // ^ Nothing и null Nothing является подтипом всех типов, также называемым the bottom type. Нет значения, которое имело бы тип Nothing. Он обычно сигнализирует о прекращении, таком как thrown exception, выходе из программы или бесконечном цикле - т.е. это тип выражения, который не вычисляется до определенного значения, или метод, который нормально не возвращается. Null - это подтип всех ссылочных типов (т.е. любой подтип AnyRef). Он имеет единственное значение, определяемое ключевым словом null. В настоящее время применение null считается плохой практикой. Его следует использовать в основном для взаимодействия с другими языками JVM. Опция opt-in compiler изменяет статус Null, делая все ссылочные типы non-nullable. Этот параметр может стать значением по умолчанию в будущей версии Scala. В то же время null почти никогда не следует использовать в коде Scala. Альтернативы null обсуждаются в главе о функциональном программировании и в документации API. References: Scala3 book, Variables and Data Types Scala3 book, A First Look at Types"
    } ,    
    {
      "title": "Variable Arguments",
      "url": "/scalaworkbook/docs/methods/vararg-parameters.html",
      "content": "Методы с неопределенным количеством параметров Метод может иметь неопределенное количество параметров одного типа. Они указываются с помощью синтаксиса T*. Пример: def printAll(args: String*): Unit = args.foreach(println) printAll(\"Adam\") // Adam printAll(\"Adam\", \"Bob\") // Adam // Bob printAll(\"Adam\", \"Bob\", \"Celin\") // Adam // Bob // Celin printAll(\"Adam\", \"Bob\", \"Celin\", \"David\") // Adam // Bob // Celin // David Ещё пример: val arr = Array(0, 1, 2, 3) // arr: Array[Int] = Array(0, 1, 2, 3) val lst = List(arr*) // lst: List[Int] = List(0, 1, 2, 3) def printList(lst: List[Int]): Unit = lst match case List(0, 1, xs*) =&gt; println(xs) case List(1, _*) =&gt; println(\"Starts with 1\") case _ =&gt; println(\"Error\") printList(lst) // List(2, 3) printList(lst.tail) // Starts with 1 References: Scala3 book, Method Features Scala 3 Reference"
    } ,    
    {
      "title": "Параметры функции",
      "url": "/scalaworkbook/docs/functions/variables.html",
      "content": "{{page.title}} Вернемся к примеру из предыдущего раздела: val doubledInts = ints.map((i: Int) =&gt; i * 2) Анонимной функцией является следующая часть: (i: Int) =&gt; i * 2 Причина, по которой она называется анонимной (anonymous), заключается в том, что она не присваивается переменной и, следовательно, не имеет имени. Однако анонимная функция, также известная как функциональный литерал (function literal), может быть назначена переменной для создания функциональной переменной (function variable): val double = (i: Int) =&gt; i * 2 Код выше создает функциональную переменную с именем double. В этом выражении исходный литерал функции находится справа от символа =, а новое имя переменной - слева. Список параметров функции подчеркнут: val double = (i: Int) =&gt; i * 2 -------- Как и список параметров для метода, список параметров функции означает, что функция double принимает один параметр с типом Int и именем i. Как можно видеть ниже, double имеет тип Int =&gt; Int, что означает, что он принимает один параметр Int и возвращает Int: val double = (i: Int) =&gt; i * 2 // double: Int =&gt; Int = ... Вызов метода Функция double может быть вызвана так: val x = double(2) // x: Int = 4 double также можно передать в вызов map: List(1, 2, 3).map(double) // res0: List[Int] = List(2, 4, 6) Кроме того, когда есть другие функции типа Int =&gt; Int: val triple = (i: Int) =&gt; i * 3 можно сохранить их в List или Map: val functionList: List[Int =&gt; Int] = List(double, triple) val functionMap: Map[String, Int =&gt; Int] = Map( \"2x\" -&gt; double, \"3x\" -&gt; triple ) functionList имеет тип List[Int =&gt; Int], functionMap - Map[String, Int =&gt; Int]. Ключевые моменты Ключевые моменты: чтобы создать функциональную переменную, достаточно присвоить имя переменной функциональному литералу когда есть функция, с ней можно обращаться как с любой другой переменной, то есть как со String или Int переменной А благодаря улучшенной функциональности Eta Expansion в Scala 3 с методами можно обращаться точно так же. References: Scala3 book Scala3 book, Function Variables"
    } ,    
    {
      "title": "Vector",
      "url": "/scalaworkbook/docs/collections/vector.html",
      "content": "{{page.title}} Vector - это индексируемая неизменяемая последовательность. “Индексируемая” часть описания означает, что она обеспечивает произвольный доступ и обновление за практически постоянное время, поэтому можно быстро получить доступ к элементам Vector по значению их индекса, например, получить доступ к listOfPeople(123_456_789). В общем, за исключением той разницы, что (а) Vector индексируется, а List - нет, и (б) List имеет метод ::, эти два типа работают одинаково. Вот несколько способов создания Vector: val nums = Vector(1, 2, 3, 4, 5) // nums: Vector[Int] = Vector(1, 2, 3, 4, 5) val strings = Vector(\"one\", \"two\") // strings: Vector[String] = Vector(\"one\", \"two\") case class Person(name: String) val people = Vector( Person(\"Bert\"), Person(\"Ernie\"), Person(\"Grover\") ) // people: Vector[Person] = Vector( // Person(name = \"Bert\"), // Person(name = \"Ernie\"), // Person(name = \"Grover\") // ) Поскольку Vector неизменяем, в него нельзя добавить новые элементы. Вместо этого создается новая последовательность, с добавленными к существующему Vector в начало или в конец элементами. Например, так элементы добавляются в конец: val a = Vector(1,2,3) // a: Vector[Int] = Vector(1, 2, 3) val b = a :+ 4 // b: Vector[Int] = Vector(1, 2, 3, 4) val c = a ++ Vector(4, 5) // c: Vector[Int] = Vector(1, 2, 3, 4, 5) А так - в начало Vector-а: val a = Vector(1,2,3) // a: Vector[Int] = Vector(1, 2, 3) val b = 0 +: a // b: Vector[Int] = Vector(0, 1, 2, 3) val c = Vector(-1, 0) ++: a // c: Vector[Int] = Vector(-1, 0, 1, 2, 3) В дополнение к быстрому произвольному доступу и обновлениям, Vector обеспечивает быстрое добавление в начало и конец. Подробную информацию о производительности Vector и других коллекций см. в характеристиках производительности коллекций. Наконец, Vector в цикле for используется точно так же, как List, ArrayBuffer или любая другая последовательность: val names = Vector(\"Joel\", \"Chris\", \"Ed\") // names: Vector[String] = Vector(\"Joel\", \"Chris\", \"Ed\") for name &lt;- names do println(s\"My name is $name\") // My name is Joel // My name is Chris // My name is Ed Вектора представленны деревьями с высоким уровнем ветвления (уровень ветвления дерева или графа - это количество дочерних элементов у каждого узла). Каждый узел дерева содержит до 32-х элементов вектора или содержит до 32-х других узлов. Вектора с размером до 32-х элементов могут быть представлены одним узлом. Вектора с 32 * 32 = 1024 элементами могут быть представлены одним витком. Для векторов с 2^15 элементами достаточно двух переходов от корня дерева до конечного элемента узла, трех переходов - для векторов с 2^20 элементами, четырех переходов - для 2^25 элементами и пяти переходов для 2^30 элементами. Таким образом, для всех векторов разумных размеров выбор элемента включает до 5 простых выборок массивов. Именно это подразумевается, что доступ к элементам осуществляется с “практически постоянным временем”. Так же как и доступ к элементу, операция обновления в векторах занимает “практически” постоянное время. Добавление элемента в середину вектора может быть выполнено через копирование узла содержащего этот элемент и каждого ссылающегося на него узла, начиная от корня дерева. Это означает, что процесс обновления элемента создает от одного до пяти узлов, каждый из которых содержит до 32 элементов или поддеревьев. Это, конечно, дороже, чем просто обновление элемента в изменяемом массиве, но все же намного дешевле, чем копирование вообще всего вектора. Поскольку вектора обладают хорошим балансом между быстрой случайной выборкой и быстрым случайным обновлением элементов, они используются в качестве реализации неизменяемых индексированных последовательностей: collection.immutable.IndexedSeq(1, 2, 3) // res2: IndexedSeq[Int] = Vector(1, 2, 3) References: Scala3 book Scala3 book, Collections Types Scala, Immutable collections"
    } ,    
    {
      "title": "Что такое ФП?",
      "url": "/scalaworkbook/docs/fp/what-is-fp.html",
      "content": "Что такое функциональное программирование? Википедия определяет функциональное программирование следующим образом: Функциональное программирование — парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния. В функциональном программировании функции рассматриваются как “граждане первого класса”, что означает, что они могут быть привязаны к именам (включая локальные идентификаторы), передаваться в качестве аргументов и возвращаться из других функций, как и любой другой тип данных. Это позволяет писать программы в декларативном и составном стиле, где небольшие функции объединяются модульным образом. Также полезно знать, что опытные функциональные программисты рассматривают свой код математически, что объединение чистых функций вместе похоже на объединение ряда алгебраических уравнений. Когда пишется функциональный код, вы чувствуете себя математиком, и как только понимаете парадигму, то хотите писать только чистые функции, которые всегда возвращают значения, а не исключения или null, чтобы можно было комбинировать чистые функции вместе. Ощущение, что вы пишете математические уравнения (выражения), является движущим желанием, заставляющим использовать только чистые функции и неизменяемые значения - это то, что используется в алгебре и других формах математики. Функциональное программирование - это большая тема, и нет простого способа сжать её всю в одну главу. В следующих разделах будет представлен обзор основных тем и показаны некоторые инструменты, предоставляемые Scala для написания функционального кода. References: Scala3 book Wikipedia"
    } ,    
    {
      "title": "Взаимодействие с Java",
      "url": "/scalaworkbook/docs/with_java.html",
      "content": "{{page.title}} Введение В этом разделе рассматривается, как использовать код Java в Scala, и наоборот, как использовать код Scala в Java. В целом, использование Java-кода в Scala довольно простое. Есть только несколько моментов использования утилит Scala для преобразования концепций Java в Scala, в том числе: классы коллекций Java Java класс Optional Точно так же, если вы пишете код Java и хотите использовать концепции Scala, вам потребуется преобразовать коллекции Scala и Scala класс Option. В следующих разделах показаны наиболее распространенные преобразования: как использовать коллекции Java в Scala как использовать Java Optional в Scala расширение интерфейсов Java в Scala как использовать коллекции Scala в Java как использовать Scala Option в Java как использовать Scala trait-ы в Java как обрабатывать методы Scala, которые в коде Java вызывают исключения как использовать Scala методы с переменным числом параметров в Java создание альтернативных имен для использования Scala методов в Java Обратите внимание, что предпочтительно использование Java 11 или новее. Как использовать коллекции Java в Scala Если при написании кода Scala необходимо использовать коллекцию Java, её можно использовать просто как есть. Однако, если необходимо использовать коллекцию в цикле for или желательно воспользоваться преимуществами функций высшего порядка в коллекциях Scala, потребуется преобразовать коллекцию Java в коллекцию Scala. Вот пример того, как это работает. Учитывая этот Java ArrayList: // java public class JavaClass { public static List&lt;String&gt; getStrings() { return new ArrayList&lt;String&gt;(List.of(\"a\", \"b\", \"c\")); } } Можно преобразовать этот список Java в Scala Seq, используя утилиты преобразования в пакете Scala scala.jdk.CollectionConverters: // scala import scala.jdk.CollectionConverters.* def testList() = println(\"Using a Java List in Scala\") val javaList: java.util.List[String] = JavaClass.getStrings() val scalaSeq: Seq[String] = javaList.asScala.toSeq scalaSeq.foreach(println) for s &lt;- scalaSeq do println(s) Конечно, этот код можно сократить, но здесь показаны отдельные шаги, чтобы продемонстрировать, как работает процесс преобразования. Как использовать Java Optional в Scala Если нужно использовать Java класс Optional в коде Scala, импортируйте объект scala.jdk.OptionConverters, а затем используйте метод toScala для преобразования значения Optional в Scala Option. Чтобы продемонстрировать это, вот класс Java с двумя значениями Optional&lt;String&gt;, одно из которых содержит строку, а второе — пустое: // java import java.util.Optional; public class JavaClass { static Optional&lt;String&gt; oString = Optional.of(\"foo\"); static Optional&lt;String&gt; oEmptyString = Optional.empty(); } Теперь в коде Scala можно получить доступ к этим полям. Если просто получить к ним прямой доступ, они оба будут значениями Optional: // scala import java.util.Optional val optionalString = JavaClass.oString // Optional[foo] val eOptionalString = JavaClass.oEmptyString // Optional.empty Но с помощью методов scala.jdk.OptionConverters эти поля можно преобразовать в значения Scala Option: import java.util.Optional import scala.jdk.OptionConverters.* val optionalString = JavaClass.oString // Optional[foo] val optionString = optionalString.toScala // Some(foo) val eOptionalString = JavaClass.oEmptyString // Optional.empty val eOptionString = eOptionalString.toScala // None Расширение интерфейсов Java в Scala Если необходимо использовать интерфейсы Java в коде Scala, расширяйте их так же, как если бы они были Scala trait-ами. Например, учитывая эти три интерфейса Java: // java interface Animal { void speak(); } interface Wagging { void wag(); } interface Running { // an implemented method default void run() { System.out.println(\"I’m running\"); } } Можно создать класс Dog в Scala так же, как если бы использовались trait-ы. Все, что нужно сделать, это реализовать методы speak и wag: // scala class Dog extends Animal, Wagging, Running: def speak = println(\"Woof\") def wag = println(\"Tail is wagging\") @main def useJavaInterfaceInScala = val d = new Dog d.speak d.wag Как использовать коллекции Scala в Java Когда нужно использовать класс коллекции Scala в Java-коде, используйте методы Scala объекта Scala.jdk.javaapi.CollectionConverters в Java-коде, чтобы преобразования работали. Например, если есть подобный List[String] в классе Scala: // scala class ScalaClass: val strings = List(\"a\", \"b\") Можно получить доступ к этому списку Scala в коде Java следующим образом: // java import scala.jdk.javaapi.CollectionConverters; // create an instance of the Scala class ScalaClass sc = new ScalaClass(); // access the `strings` field as `sc.strings()` scala.collection.immutable.List&lt;String&gt; xs = sc.strings(); // convert the Scala `List` a Java `List&lt;String&gt;` java.util.List&lt;String&gt; listOfStrings = CollectionConverters.asJava(xs); listOfStrings.forEach(System.out::println); Этот код можно сократить, но показаны полные шаги, чтобы продемонстрировать, как работает процесс. Вот несколько вещей, на которые стоит обратить внимание: в Java-коде создается экземпляр ScalaClass точно так же, как экземпляр класса Java. ScalaClass имеет поле с именем strings, но из Java вы получаете доступ к этому полю как к методу, т.е. как sc.strings() Как использовать Scala Option в Java Когда нужно использовать Scala Option в коде Java, то можно преобразовать Option в значение Java Optional, используя метод toJava объекта Scala scala.jdk.javaapi.OptionConverters. Чтобы продемонстрировать это, создайте класс Scala с двумя значениями Option[String], одно из которых содержит строку, а второе — пустое: // scala object ScalaObject: val someString = Option(\"foo\") val noneString: Option[String] = None Затем в коде Java преобразуйте эти значения Option[String] в java.util.Optional[String] с помощью метода toJava из объекта scala.jdk.javaapi.OptionConverters: // java import java.util.Optional; import static scala.jdk.javaapi.OptionConverters.toJava; public class JUseScalaOptionInJava { public static void main(String[] args) { Optional&lt;String&gt; stringSome = toJava(ScalaObject.someString()); // Optional[foo] Optional&lt;String&gt; stringNone = toJava(ScalaObject.noneString()); // Optional.empty System.out.printf(\"stringSome = %s\\n\", stringSome); System.out.printf(\"stringNone = %s\\n\", stringNone); } } Два поля Scala Option теперь доступны как Optional значения Java. Как использовать Scala trait-ы в Java В Java 11 можно использовать trait Scala точно так же, как интерфейс Java, даже если у trait-а есть реализованные методы. Например, учитывая эти два trait-а Scala, один с реализованным методом и ещё один абстрактный: // scala trait ScalaAddTrait: def sum(x: Int, y: Int) = x + y // implemented trait ScalaMultiplyTrait: def multiply(x: Int, y: Int): Int // abstract Класс Java может реализовать оба этих интерфейса и определить метод multiply: // java class JavaMath implements ScalaAddTrait, ScalaMultiplyTrait { public int multiply(int a, int b) { return a * b; } } JavaMath jm = new JavaMath(); System.out.println(jm.sum(3,4)); // 7 System.out.println(jm.multiply(3,4)); // 12 Как обрабатывать методы Scala, которые в коде Java вызывают исключения Когда пишется Scala код, используя идиомы программирования Scala, вы никогда не напишете метод, который выдает исключение. Но если по какой-то причине есть метод Scala, который выдает исключение, и желательно, чтобы разработчики Java могли этот метод использовать, добавьте аннотацию @throws к этому методу Scala, чтобы пользователи Java знали, какие исключения он может выдавать. Например, этот метод Scala exceptionThrower аннотирован, чтобы объявить, что он генерирует Exception: // scala object SExceptionThrower: @throws(classOf[Exception]) def exceptionThrower = throw new Exception(\"Idiomatic Scala methods don’t throw exceptions\") В результате нужно будет обработать исключение в Java-коде. Например, этот код не скомпилируется, потому что исключение не обрабатывается: // java: won’t compile because the exception isn’t handled public class ScalaExceptionsInJava { public static void main(String[] args) { SExceptionThrower.exceptionThrower(); } } Компилятор выдает ошибку: [error] ScalaExceptionsInJava: unreported exception java.lang.Exception; must be caught or declared to be thrown [error] SExceptionThrower.exceptionThrower() Аннотация сообщает компилятору Java, что exceptionThrower может выдавать исключение. Теперь, при написании Java-кода, вы должны обработать исключение с помощью блока try или объявить, что Java-метод выдает исключение. И наоборот, если оставить аннотацию вне метода Scala exceptionThrower, код Java будет скомпилирован. Но это не то, что следует делать, потому что код Java может не учитывать метод Scala, вызывающий исключение. Как использовать Scala методы с переменным числом параметров в Java Если метод Scala имеет переменное число параметров и необходимо использовать этот метод в Java, то данный метод Scala помечается аннотацией @varargs. Например, метод printAll в этом классе Scala объявляет поле String* varargs: // scala import scala.annotation.varargs object VarargsPrinter: @varargs def printAll(args: String*): Unit = args.foreach(println) Поскольку printAll объявлен с аннотацией @varargs, его можно вызвать из программы Java с переменным числом параметров, как показано в этом примере: // java public class JVarargs { public static void main(String[] args) { VarargsPrinter.printAll(\"Hello\", \"world\"); } } Запуск этого кода приводит к следующему выводу: Hello world Создание альтернативных имен для использования Scala методов в Java В Scala можно создавать методы с символическими именами, например, +: def +(a: Int, b: Int) = a + b Это имя метода не будет работать в Java, но в Scala можно указать “альтернативное” имя для метода — псевдоним, который будет работать в Java: import scala.annotation.targetName class Adder: @targetName(\"add\") def +(a: Int, b: Int) = a + b Теперь в Java-коде можно использовать псевдоним имени метода add: var adder = new Adder(); int x = adder.add(1,1); System.out.printf(\"x = %d\\n\", x); References: Scala3 book Scala 3 Reference"
    } ,    
    {
      "title": "Собственный map",
      "url": "/scalaworkbook/docs/functions/write-map.html",
      "content": "Написание своего собственного метода map Теперь, когда известно, как писать собственные функции высшего порядка, рассмотрим более реальный пример. Представим, что у класса List нет метода map, и есть необходимость его написать. Первым шагом при создании функций является точное определение проблемы. Сосредоточившись только на List[Int], получаем: Необходимо написать метод map, который можно использовать для применения функции к каждому элементу в List[Int], возвращая преобразованные элементы в виде нового списка. Учитывая это утверждение, начнем писать сигнатуру метода. Во-первых, известно, что функция должна приниматься в качестве параметра, и эта функция должна преобразовать Int в какой-то общий тип A, поэтому получаем: def map(f: (Int) =&gt; A) Синтаксис использования универсального типа требует объявления этого символа типа перед списком параметров, поэтому добавляем объявление типа: def map[A](f: (Int) =&gt; A) Далее известно, что map также должен принимать List[Int]: def map[A](f: (Int) =&gt; A, xs: List[Int]) Наконец, также известно, что map возвращает преобразованный список, содержащий элементы универсального типа A: def map[A](f: (Int) =&gt; A, xs: List[Int]): List[A] = ??? Теперь все, что нужно сделать, это написать тело метода. Метод map применяет заданную им функцию к каждому элементу в заданном списке для создания нового преобразованного списка. Один из способов сделать это - использовать выражение for: for x &lt;- xs yield f(x) for выражения зачастую делают код удивительно простым, и в данном случае - это все тело метода. Объединив for с сигнатурой метода, получим автономный метод map, который работает с List[Int]: def map[A](f: (Int) =&gt; A, xs: List[Int]): List[A] = for x &lt;- xs yield f(x) Обобщим метод map Обратим внимание, что выражение for не делает ничего, что зависит от типа Int внутри списка. Следовательно, можно заменить Int в сигнатуре типа параметром универсального типа B: def map[A, B](f: (B) =&gt; A, xs: List[B]): List[A] = for x &lt;- xs yield f(x) Получился метод map, который работает с любым списком. Демонстрация работы получившегося map: def double(i : Int) = i * 2 def strlen(s: String) = s.length map(double, List(1, 2, 3)) // res0: List[Int] = List(2, 4, 6) map(strlen, List(\"a\", \"bb\", \"ccc\")) // res1: List[Int] = List(1, 2, 3) Теперь, когда рассмотрены методы, принимающие функции в качестве входных параметров, перейдем к методам, возвращающим функции. References: Scala3 book"
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
