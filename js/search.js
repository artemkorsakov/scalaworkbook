// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Контекстуальные абстракции",
      "url": "/scalaworkbook/docs/abstractions.html",
      "content": "Контекстуальные абстракции При определенных обстоятельствах можно опустить некоторые параметры вызовов методов, которые считаются повторяющимися. Эти параметры называются параметрами контекста (Context Parameters), поскольку они выводятся компилятором из контекста, окружающего вызов метода. Например, рассмотрим программу, которая сортирует список адресов по двум критериям: название города, а затем - название улицы. val addresses: List[Address] = ... addresses.sortBy(address =&gt; (address.city, address.street)) Метод sortBy принимает функцию, которая возвращает для каждого адреса значение для сравнения его с другими адресами. В этом случае мы передаем функцию, которая возвращает пару, содержащую название города и название улицы. Обратите внимание, что мы указываем только, что сравнивать, но не как выполнять сравнение. Как алгоритм сортировки узнает, как сравнивать пары строк? На самом деле метод sortBy принимает второй параметр — параметр контекста, который выводится компилятором. Параметр не появляется в приведенном выше примере, потому что он предоставляется компилятором. Этот второй параметр реализует способ сравнения. Удобно опустить его, потому что мы знаем, что строки обычно сравниваются с использованием лексикографического порядка. Однако также возможно передать его явно: addresses.sortBy(address =&gt; (address.city, address.street))(using Ordering.Tuple2(Ordering.String, Ordering.String)) В данном случае экземпляр Ordering.Tuple2(Ordering.String, Ordering.String) - это именно тот экземпляр, который выводится компилятором в первом случае. Другими словами, оба примера используют одну и ту же функцию сравнения. Контекстуальные абстракции используются для того, чтобы избежать повторения кода. Они помогают разработчикам писать фрагменты кода, которые являются расширяемыми и в то же время краткими. References: Scala3 book"
    } ,    
    {
      "title": "Анонимные функции",
      "url": "/scalaworkbook/docs/functions/anonymous.html",
      "content": "Анонимные функции Анонимная функция, также называемая лямбда, представляет собой блок кода, который передается в качестве аргумента функции более высокого порядка. Википедия определяет анонимную функцию как “определение функции, не привязанное к идентификатору”. Например, возьмем коллекцию: val ints = List(1, 2, 3) Можно создать новый список, удвоив каждый элемент в целых числах, используя метод map класса List и свою пользовательскую анонимную функцию: val doubledInts = ints.map(_ * 2) // doubledInts: List[Int] = List(2, 4, 6) Как видно из комментария, doubleInts содержит список List(2, 4, 6). В этом примере анонимной функцией является часть кода: _ * 2. Это сокращенный способ сказать: “Умножить данный элемент на 2”. Более длинные формы Более длинными формами предыдущего примера являются следующие функции: val doubledInts = ints.map((i: Int) =&gt; i * 2) val doubledInts = ints.map((i) =&gt; i * 2) val doubledInts = ints.map(i =&gt; i * 2) Все эти строки имеют одно и то же значение: удваивайте каждый элемент в ints, чтобы создать новый список, doubledInts. Сокращение анонимных функций Если необходимо явно указать анонимную функцию, можно использовать эту длинную форму: val doubledInts = ints.map((i: Int) =&gt; i * 2) Анонимная функция в этом выражении такова: (i: Int) =&gt; i * 2 Если незнаком данный синтаксис, то можно воспринимать символ =&gt; как преобразователь, потому что выражение преобразует список параметров в левой части символа (переменная Int с именем i) в новый результат, используя алгоритм справа от символа =&gt; (в данном случае выражение, которое удваивает значение Int). Сокращение выражения Эту длинную форму можно сократить: val doubledInts = ints.map((i: Int) =&gt; i * 2) Поскольку компилятор Scala из данных в ints может сделать вывод, что i является Int, объявление Int можно удалить: val doubledInts = ints.map((i) =&gt; i * 2) Поскольку аргумент всего один, скобки вокруг параметра i можно не указывать: val doubledInts = ints.map(i =&gt; i * 2) Поскольку Scala позволяет использовать символ _ вместо имени переменной, если в функции только один параметр, код можно упростить еще больше: val doubledInts = ints.map(_ * 2) Ещё короче В других примерах можно еще больше упростить анонимные функции. Например, начиная с самой явной формы, можно распечатать каждый элемент в целых числах, используя эту анонимную функцию с методом foreach класса List: ints.foreach((i: Int) =&gt; println(i)) Как и раньше, объявление Int не требуется, а поскольку аргумент всего один, скобки вокруг i не нужны: ints.foreach(i =&gt; println(i)) Поскольку i используется в теле функции только один раз, выражение можно еще больше упростить с помощью символа _: ints.foreach(println(_)) Наконец, если анонимная функция состоит из одного вызова метода с одним аргументом, нет необходимости явно называть и указывать аргумент, можно написать только имя метода (здесь, println): ints.foreach(println) References: Scala3 book Scala3 book, Anonymous Functions"
    } ,    
    {
      "title": "Типы коллекций",
      "url": "/scalaworkbook/docs/collections/classes.html",
      "content": "Типы коллекций В этом разделе продемонстрированы наиболее распространенные типы коллекций и их методы. В конце этого раздела для получения более подробной информации представлены дополнительные ссылки для более глубокого изучения коллекций. Три основные категории коллекций Для коллекций Scala можно выделить три основные категории: Последовательности (Sequences/Seq) представляют собой последовательный набор элементов и могут быть индексированными (как массив) или линейными (как связанный список) Карты (Maps) содержат набор пар ключ/значение, например Java Map, Python dictionary или Ruby Hash Множества (Sets) — это неупорядоченный набор уникальных элементов Все они являются базовыми типами и имеют подтипы для конкретных целей, таких как параллелизм (concurrency), кэширование (caching) и потоковая передача (streaming). В дополнение к этим трем основным категориям существуют и другие полезные типы коллекций, включая диапазоны (ranges), стеки (stacks) и очереди (queues). Иерархия коллекций В качестве краткого обзора следующие три рисунка показывают иерархию классов и трейтов в коллекциях Scala. На первом рисунке показаны типы коллекций в пакете scala.collection. Все это высокоуровневые абстрактные классы или трейты, которые обычно имеют неизменяемые и изменяемые реализации. На этом рисунке показаны все коллекции в пакете scala.collection.immutable: А на этом рисунке показаны все коллекции в пакете scala.collection.mutable: В следующих разделах представлены некоторые из распространенных типов. Общие коллекции Основные коллекции, используемые чаще всего: Тип коллекции Неизменяемая Изменяемая Описание List ✓   Линейная неизменяемая последовательность (связный список) Vector ✓   Индексированная неизменяемая последовательность LazyList ✓   Ленивый неизменяемый связанный список, элементы которого вычисляются только тогда, когда они необходимы; подходит для больших или бесконечных последовательностей. ArrayBuffer   ✓ Подходящий тип для изменяемой индексированной последовательности ListBuffer   ✓ Используется, когда вам нужен изменяемый список; обычно преобразуется в List Map ✓ ✓ Итерируемая коллекция, состоящая из пар ключей и значений Set ✓ ✓ Итерируемая коллекция без повторяющихся элементов Как показано, Map и Set бывают как неизменяемыми, так и изменяемыми. Основы каждого типа демонстрируются в следующих разделах. В Scala буфер, такой как ArrayBuffer или ListBuffer, представляет собой последовательность, которая может увеличиваться и уменьшаться. Примечание о неизменяемых коллекциях В последующих разделах всякий раз, когда используется слово immutable, можно с уверенностью сказать, что тип предназначен для использования в стиле функционального программирования (FP). С помощью таких типов коллекция не меняется, а при вызове функциональных методов возвращается новый результат - новая коллекция. Выбор последовательности При выборе последовательности нужно руководствоваться двумя основными вопросами: должна ли последовательность индексироваться (как массив), обеспечивая быстрый доступ к любому элементу, или она должна быть реализована как линейный связанный список? необходима изменяемая или неизменяемая коллекция? Рекомендуемые универсальные последовательности: Тип \\ Категория Неизменяемая Изменяемая индексируемая Vector ArrayBuffer линейный связанный список List ListBuffer Например, если нужна неизменяемая индексированная коллекция, в общем случае следует использовать Vector. И наоборот, если нужна изменяемая индексированная коллекция, используйте ArrayBuffer. List и Vector часто используются при написании кода в функциональном стиле. ArrayBuffer обычно используется при написании кода в императивном стиле. ListBuffer используется, когда стили смешиваются, например, при создании списка. Следующие несколько разделов кратко демонстрируют типы List, Vector и ArrayBuffer. List List представляет собой линейную неизменяемую последовательность. Каждый раз, когда в список добавляются или удаляются элементы, по сути создается новый список из существующего. Создание списка Список можно создать различными способами: val ints = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) val names = List(\"Joel\", \"Chris\", \"Ed\") // names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") val namesAgain = \"Joel\" :: \"Chris\" :: \"Ed\" :: Nil // namesAgain: List[String] = List(\"Joel\", \"Chris\", \"Ed\") При желании тип списка можно объявить, хотя обычно в этом нет необходимости: val ints: List[Int] = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) val names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") // names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") Одно исключение — когда в коллекции смешанные типы; в этом случае тип желательно указывать явно: val things: List[Any] = List(1, \"two\", 3.0) // things: List[Any] = List(1, \"two\", 3.0) Добавление элементов в список Поскольку список неизменяем, в него нельзя добавлять новые элементы. Вместо этого создается новый список с добавленными к существующему списку элементами. Например, учитывая этот список: val a = List(1, 2, 3) Для добавления одного элемента используется метод ::, для добавления нескольких — :::, как показано здесь: val b = 0 :: a // b: List[Int] = List(0, 1, 2, 3) val c = List(-1, 0) ::: a // c: List[Int] = List(-1, 0, 1, 2, 3) Также можно добавить элементы в конец списка, но, поскольку список является односвязным, следует добавлять к нему элементы только в начало; добавление элементов в конец списка — относительно медленная операция, особенно при работе с большими последовательностями. Если необходимо добавлять к неизменяемой последовательности элементы в начало и конец, используйте Vector. Поскольку List является связанным списком, крайне нежелательно пытаться получить доступ к элементам больших списков по значению их индекса. Например, если есть List с миллионом элементов, доступ к такому элементу, как myList(999_999), займет относительно много времени, потому что этот запрос должен пройти почти через все элементы. Если есть большая коллекция и необходимо получать доступ к элементам по их индексу, вместо List используйте Vector или ArrayBuffer. Как запомнить названия методов В методах Scala символ : представляет сторону, на которой находится последовательность, поэтому, когда используется метод +:, список нужно указывать справа: 0 +: a // res2: List[Int] = List(0, 1, 2, 3) Аналогично, если используется :+, список должен быть слева: a :+ 4 // res3: List[Int] = List(1, 2, 3, 4) Кроме того, хорошей особенностью этих символических имен методов является то, что они стандартизированы. Те же имена методов используются с другими неизменяемыми последовательностями, такими как Seq и Vector. Также можно использовать несимволические имена методов для добавления элементов в начало (a.prepended(4)) или конец (a.appended(4)). Как пройтись по списку Представим, что есть список имён: val names = List(\"Joel\", \"Chris\", \"Ed\") Напечатать каждое имя можно следующим способом: for name &lt;- names do println(name) // Joel // Chris // Ed Преимуществом использования циклов for с коллекциями заключается в том, что Scala стандартизирован, и один и тот же подход работает со всеми последовательностями, включая Array, ArrayBuffer, List, Seq, Vector, Map, Set и т. д. Немного истории Список Scala подобен списку из языка программирования Lisp, который был впервые представлен в 1958 году. Действительно, в дополнение к привычному способу создания списка: val ints = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) точно такой же список можно создать следующим образом: val list = 1 :: 2 :: 3 :: Nil // list: List[Int] = List(1, 2, 3) Это работает, потому что List — односвязный список, оканчивающийся элементом Nil, а :: — это метод List, работающий как оператор “cons” в Lisp. LazyList Коллекции Scala также включают LazyList, который представляет собой ленивый неизменяемый связанный список. Он называется «ленивым» — или нестрогим — потому что вычисляет свои элементы только тогда, когда они необходимы. Примеры: val x = LazyList.range(1, Int.MaxValue) x.take(1) x.take(5) x.map(_ + 1) LazyList начинает вычислять свои элементы только при вызове некоторых методов, например, foreach: x.take(1).foreach(println) // 1 Для получения дополнительной информации об использовании, преимуществах и недостатках строгих и нестрогих (ленивых) коллекций см. обсуждение “строгих” и “нестрогих” коллекций на странице “Архитектура Scala 2.13’s Collections”. Vector Vector - это индексируемая неизменяемая последовательность. “Индексируемая” часть описания означает, что она обеспечивает произвольный доступ и обновление за практически постоянное время, поэтому можно быстро получить доступ к элементам Vector по значению их индекса, например, получить доступ к listOfPeople(123_456_789). В общем, за исключением той разницы, что (а) Vector индексируется, а List - нет, и (б) List имеет метод ::, эти два типа работают одинаково. Вот несколько способов создания Vector: val nums = Vector(1, 2, 3, 4, 5) // nums: Vector[Int] = Vector(1, 2, 3, 4, 5) val strings = Vector(\"one\", \"two\") // strings: Vector[String] = Vector(\"one\", \"two\") case class Person(name: String) val people = Vector( Person(\"Bert\"), Person(\"Ernie\"), Person(\"Grover\") ) // people: Vector[Person] = Vector( // Person(name = \"Bert\"), // Person(name = \"Ernie\"), // Person(name = \"Grover\") // ) Поскольку Vector неизменяем, в него нельзя добавить новые элементы. Вместо этого создается новая последовательность, с добавленными к существующему Vector в начало или в конец элементами. Например, так элементы добавляются в конец: val a = Vector(1,2,3) // a: Vector[Int] = Vector(1, 2, 3) val b = a :+ 4 // b: Vector[Int] = Vector(1, 2, 3, 4) val c = a ++ Vector(4, 5) // c: Vector[Int] = Vector(1, 2, 3, 4, 5) А так - в начало Vector-а: val a = Vector(1,2,3) // a: Vector[Int] = Vector(1, 2, 3) val b = 0 +: a // b: Vector[Int] = Vector(0, 1, 2, 3) val c = Vector(-1, 0) ++: a // c: Vector[Int] = Vector(-1, 0, 1, 2, 3) В дополнение к быстрому произвольному доступу и обновлениям, Vector обеспечивает быстрое добавление в начало и конец. Подробную информацию о производительности Vector и других коллекций см. в характеристиках производительности коллекций. Наконец, Vector в цикле for используется точно так же, как List, ArrayBuffer или любая другая последовательность: val names = Vector(\"Joel\", \"Chris\", \"Ed\") // names: Vector[String] = Vector(\"Joel\", \"Chris\", \"Ed\") for name &lt;- names do println(s\"My name is $name\") // My name is Joel // My name is Chris // My name is Ed ArrayBuffer ArrayBuffer используется тогда, когда нужна изменяемая индексированная последовательность общего назначения. Поскольку ArrayBuffer индексирован, произвольный доступ к элементам выполняется быстро. Создание ArrayBuffer Чтобы использовать ArrayBuffer, в отличие от предыдущих рассмотренных классов, его нужно вначале импортировать: import scala.collection.mutable.ArrayBuffer Если необходимо начать с пустого ArrayBuffer, просто укажите его тип: var strings = ArrayBuffer[String]() var ints = ArrayBuffer[Int]() var people = ArrayBuffer[Person]() Если известен примерный размер ArrayBuffer, его можно задать: val buf = new ArrayBuffer[Int](100_000) Чтобы создать новый ArrayBuffer с начальными элементами, достаточно просто указать начальные элементы, как для List или Vector: val nums = ArrayBuffer(1, 2, 3) val people = ArrayBuffer( Person(\"Bert\"), Person(\"Ernie\"), Person(\"Grover\") ) Добавление элементов в ArrayBuffer Новые элементы добавляются в ArrayBuffer с помощью методов += и ++=. Также можно использовать текстовый аналог: append, appendAll, insert, insertAll, prepend и prependAll. Вот несколько примеров с += и ++=: val nums = ArrayBuffer(1, 2, 3) // nums: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3) nums += 4 // res15: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4) nums ++= List(5, 6) // res18: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6) Удаление элементов из ArrayBuffer ArrayBuffer является изменяемым, поэтому у него есть такие методы, как -=, --=, clear, remove и другие. Примеры с -= и --=: val a = ArrayBuffer.range('a', 'h') // a: ArrayBuffer[Char] = ArrayBuffer('a', 'b', 'c', 'd', 'e', 'f', 'g') a -= 'a' // res20: ArrayBuffer[Char] = ArrayBuffer('b', 'c', 'd', 'e', 'f', 'g') a --= Seq('b', 'c') // res23: ArrayBuffer[Char] = ArrayBuffer('d', 'e', 'f', 'g') a --= Set('d', 'e') // res27: ArrayBuffer[Char] = ArrayBuffer('f', 'g') Обновление элементов в ArrayBuffer Элементы в ArrayBuffer можно обновлять, либо переназначать: val a = ArrayBuffer.range(1,5) // a: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4) a(2) = 50 println(a) // ArrayBuffer(1, 2, 50, 4) a.update(0, 10) println(a) // ArrayBuffer(10, 2, 50, 4) Maps Map — это итерируемая коллекция, состоящая из пар ключей и значений. В Scala есть как изменяемые, так и неизменяемые типы Map. В этом разделе показано, как использовать неизменяемый Map. Создание Map Неизменяемая Map создается следующим образом: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AZ\" -&gt; \"Arizona\" ) Перемещаться по элементам Map в цикле for можно следующим образом: for (k, v) &lt;- states do println(s\"key: $k, value: $v\") // key: AK, value: Alaska // key: AL, value: Alabama // key: AZ, value: Arizona Доступ к элементам Map Доступ к элементам Map осуществляется через указание в скобках значения ключа: val ak = states(\"AK\") // ak: String = \"Alaska\" val al = states(\"AL\") // al: String = \"Alabama\" На практике также используются такие методы, как keys, keySet, keysIterator, циклы for и функции высшего порядка, такие как map, для работы с ключами и значениями Map. Добавление элемента в Map При добавлении элементов в неизменяемую карту с помощью + и ++, создается новая карта: val a = Map(1 -&gt; \"one\") // a: Map[Int, String] = Map(1 -&gt; \"one\") val b = a + (2 -&gt; \"two\") // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") val c = b ++ Seq( 3 -&gt; \"three\", 4 -&gt; \"four\" ) // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\") Удаление элементов из Map Элементы удаляются с помощью методов - или --. В случае неизменяемой Map создается новый экземпляр, который нужно присвоить новой переменной: val a = Map( 1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\" ) // a: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\") val b = a - 4 // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\") val c = a - 4 - 3 // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") Обновление элементов в Map Чтобы обновить элементы на неизменяемой Map, используется метод update (или оператор +): val a = Map( 1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\" ) // a: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\") val b = a.updated(3, \"THREE!\") // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"THREE!\") val c = a + (2 -&gt; \"TWO...\") // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"TWO...\", 3 -&gt; \"three\") Перебор элементов в Map Элементы в Map можно перебрать с помощью цикла for, как и для остальных коллекций: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AZ\" -&gt; \"Arizona\" ) // states: Map[String, String] = Map( // \"AK\" -&gt; \"Alaska\", // \"AL\" -&gt; \"Alabama\", // \"AZ\" -&gt; \"Arizona\" // ) for (k, v) &lt;- states do println(s\"key: $k, value: $v\") // key: AK, value: Alaska // key: AL, value: Alabama // key: AZ, value: Arizona Существует много способов работы с ключами и значениями на Map. Общие методы Map включают foreach, map, keys и values. В Scala есть много других специализированных типов Map, включая CollisionProofHashMap, HashMap, LinkedHashMap, ListMap, SortedMap, TreeMap, WeakHashMap и другие. Работа с множествами Множество (Set) - итерируемая коллекция без повторяющихся элементов. В Scala есть как изменяемые, так и неизменяемые типы Set. В этом разделе демонстрируется неизменяемое множество. Создание множества Создание нового пустого множества: val nums = Set[Int]() // nums: Set[Int] = Set() val letters = Set[Char]() // letters: Set[Char] = Set() Создание множества с исходными данными: val nums = Set(1, 2, 3, 3, 3) // nums: Set[Int] = Set(1, 2, 3) val letters = Set('a', 'b', 'c', 'c') // letters: Set[Char] = Set('a', 'b', 'c') Добавление элементов в множество В неизменяемое множество новые элементы добавляются с помощью + и ++, результат присваивается новой переменной: val a = Set(1, 2) // a: Set[Int] = Set(1, 2) val b = a + 3 // b: Set[Int] = Set(1, 2, 3) val c = b ++ Seq(4, 1, 5, 5) // c: Set[Int] = HashSet(5, 1, 2, 3, 4) Стоит отметить, что повторяющиеся элементы не добавляются в множество, а также, что порядок элементов произвольный. Удаление элементов из множества Элементы из множества удаляются с помощью методов - и --: val a = Set(1, 2, 3, 4, 5) // a: Set[Int] = HashSet(5, 1, 2, 3, 4) val b = a - 5 // b: Set[Int] = HashSet(1, 2, 3, 4) val c = b -- Seq(3, 4) // c: Set[Int] = HashSet(1, 2) Диапазон (Range) Range часто используется для заполнения структур данных и для циклов for. Эти примеры демонстрируют, как создавать диапазоны: 1 to 5 // res45: Inclusive = Range(1, 2, 3, 4, 5) 1 until 5 // res46: Range = Range(1, 2, 3, 4) 1 to 10 by 2 // res47: Range = Range(1, 3, 5, 7, 9) 'a' to 'c' // res48: Inclusive[Char] = NumericRange('a', 'b', 'c') Range можно использовать для заполнения коллекций: val x = (1 to 5).toList // x: List[Int] = List(1, 2, 3, 4, 5) val y = (1 to 5).toBuffer // y: Buffer[Int] = ArrayBuffer(1, 2, 3, 4, 5) Они также используются в циклах for: for i &lt;- 1 to 3 do println(i) // 1 // 2 // 3 Во многих коллекциях есть метод range: Vector.range(1, 5) // res50: Vector[Int] = Vector(1, 2, 3, 4) List.range(1, 10, 2) // res51: List[Int] = List(1, 3, 5, 7, 9) Set.range(1, 10) // res52: Set[Int] = HashSet(5, 1, 6, 9, 2, 7, 3, 8, 4) Диапазоны также полезны для создания тестовых коллекций: val evens = (0 to 10 by 2).toList // evens: List[Int] = List(0, 2, 4, 6, 8, 10) val odds = (1 to 10 by 2).toList // odds: List[Int] = List(1, 3, 5, 7, 9) val doubles = (1 to 5).map(_ * 2.0) // doubles: IndexedSeq[Double] = Vector(2.0, 4.0, 6.0, 8.0, 10.0) val map = (1 to 3).map(e =&gt; (e,s\"$e\")).toMap // map: Map[Int, String] = Map(1 -&gt; \"1\", 2 -&gt; \"2\", 3 -&gt; \"3\") Tuple (кортежи) Scala tuple - это тип, который позволяет помещать коллекцию разных типов в один и тот же контейнер. Например, учитывая case class Person: case class Person(name: String) можно построить кортеж, содержащий Int, String и Person: val t = (11, \"eleven\", Person(\"Eleven\")) // t: Tuple3[Int, String, Person] = (11, \"eleven\", Person(name = \"Eleven\")) Доступ к значениям кортежа осуществляется через индекс (начиная с 0): t(0) // res53: Int = 11 t(1) // res54: String = \"eleven\" t(2) // res55: Person = Person(name = \"Eleven\") либо через методы вида ._i, где i - порядковый номер (начиная с 1, в отличие от индекса) t._1 // res56: Int = 11 t._2 // res57: String = \"eleven\" t._3 // res58: Person = Person(name = \"Eleven\") Также можно использовать extractor для присвоения переменным значений полей кортежа: val (num, str, person) = t // num: Int = 11 // str: String = \"eleven\" // person: Person = Person(name = \"Eleven\") Кортежи хороши для случаев, когда необходимо поместить коллекцию разнородных типов в небольшую структуру, похожую на коллекцию. Подробнее Для дополнительной информации о коллекциях, см. следующие ресурсы: Неизменяемые классы коллекций Изменяемые классы коллекций Как устроены коллекции? Какую из них выбирать? References: Scala3 book Scala3 book, Collections Types"
    } ,    
    {
      "title": "Коллекции",
      "url": "/scalaworkbook/docs/collections.html",
      "content": "Коллекции Scala поставляется с большим количеством типов коллекций, на изучение которых может уйти время, поэтому желательно начать с нескольких из них, а затем использовать остальные по мере необходимости. Точно так же у каждого типа коллекции есть десятки методов, облегчающих разработку, но также желательно начать с нескольких из них. Поэтому в этом разделе продемонстрированы наиболее распространенные типы и методы коллекций. Более подробная информация о типах коллекций, показанных в этой главе, доступна в Scaladoc: List Vector ArrayBuffer Range Также упоминаются неизменяемые Map и Set: Map Set и изменяемые Map и Set: Map Set References: Scala3 book, Collections intro Scala3 book"
    } ,    
    {
      "title": "Eta расширение",
      "url": "/scalaworkbook/docs/functions/eta.html",
      "content": "Eta расширение Если посмотреть на Scaladoc для метода map в классах коллекций Scala, то можно увидеть, что метод определен для приема функции: def map[B](f: (A) =&gt; B): List[B] ----------- Действительно, в Scaladoc сказано: “f — это функция, применяемая к каждому элементу”. Но, несмотря на это, каким-то образом в map можно передать метод, и он все еще работает: def times10(i: Int) = i * 10 List(1, 2, 3).map(times10) // res0: List[Int] = List(10, 20, 30) Как это работает? Как можно передать метод в map, который ожидает функцию? Технология, стоящая за этим, известна как Eta Expansion. Она преобразует выражение типа метода в эквивалентное выражение типа функции, и делает это легко и незаметно. Различия между методами и функциями Исторически методы были частью определения класса, хотя в Scala 3 методы могут быть вне классов, такие как определения верхнего уровня и методы расширения. В отличие от методов, функции сами по себе являются полноценными объектами, что делает их объектами первого класса. Их синтаксис также отличается. В этом примере показано, как задать метод и функцию, которые выполняют одну и ту же задачу, определяя, является ли заданное целое число четным: def isEvenMethod(i: Int) = i % 2 == 0 // метод val isEvenFunction = (i: Int) =&gt; i % 2 == 0 // функция Функция действительно является объектом, поэтому ее можно использовать так же, как и любую другую переменную, например, помещая в список: val functions = List(isEvenFunction) И наоборот, технически метод не является объектом, поэтому в Scala 2 метод нельзя было поместить в список, по крайней мере, напрямую, как показано в этом примере: // В этом примере показано сообщение об ошибке в Scala 2 val methods = List(isEvenMethod) ^ error: missing argument list for method isEvenMethod Unapplied methods are only converted to functions when a function type is expected. You can make this conversion explicit by writing `isEvenMethod _` or `isEvenMethod(_)` instead of `isEvenMethod`. Как показано в этом сообщении об ошибке, в Scala 2 существует ручной способ преобразования метода в функцию, но важной частью для Scala 3 является то, что технология Eta Expansion улучшена, поэтому теперь, когда попытаться использовать метод в качестве переменной, он просто работает — не нужно самостоятельно выполнять ручное преобразование: val functions = List(isEvenFunction) val methods = List(isEvenMethod) Важно отметить следующее: Eta Expansion — технология Scala, позволяющая использовать методы так же, как и функции Технология была улучшена в Scala 3, чтобы быть почти полностью бесшовной References: Scala3 book"
    } ,    
    {
      "title": "Моделирование FP",
      "url": "/scalaworkbook/docs/modeling/fp.html",
      "content": "Моделирование FP В этой главе представлено введение в моделирование предметной области с использованием функционального программирования (FP). При моделировании с помощью FP обычно используются следующие конструкции Scala: Enums Case classes Traits Введение В FP данные и операции над этими данными — это две разные вещи; их необязательно инкапсулировать вместе, как в ООП. Концепция аналогична числовой алгебре. Когда вы думаете о целых числах, значения которых больше или равны нулю, то у вас есть набор возможных значений, который выглядит следующим образом: 0, 1, 2 ... Int.MaxValue Игнорируя деление целых чисел, возможные операции над этими значениями такие: +, -, * Схема FP реализуется аналогичным образом: описывается свой набор значений (данные) описываются операции, которые работают с этими значениями (функции) Как будет видно, рассуждения о программах в этом стиле сильно отличаются от объектно-ориентированного программирования. Отделение функциональности от данных позволяет проверять свои данные, не беспокоясь о поведении. В этой главе мы смоделируем данные и операции для “пиццы” в пиццерии. Будет показано, как реализовать часть “данных” модели Scala/FP, а затем - несколько различных способов организации операций с этими данными. Моделирование данных В Scala достаточно просто описать модель данных: если необходимо смоделировать данные с различными альтернативами, то используется конструкция enum если необходимо только сгруппировать сущности (или нужен более детальный контроль), то используются case class-ы Описание альтернатив Данные, которые просто состоят из различных альтернатив, таких как размер корочки, тип корочки и начинка, кратко моделируются с помощью конструкции enum: enum CrustSize: case Small, Medium, Large enum CrustType: case Thin, Thick, Regular enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions Типы данных, которые описывают различные альтернативы (например, CrustSize), также иногда называют типами суммы (sum types). Описание основных данных Пиццу можно рассматривать как составной контейнер с различными атрибутами, указанными выше. Мы можем использовать case class, чтобы описать, что пицца состоит из размеров корки, типа корки и, возможно, нескольких начинок: import CrustSize.* import CrustType.* import Topping.* case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) Типы данных, объединяющие несколько компонентов (например, Pizza), также иногда называют типами продуктов (product types). И все. Это модель данных для системы доставки пиццы в стиле FP. Решение очень лаконично, поскольку оно не требует объединения модели данных с операциями с пиццей. Модель данных легко читается, как объявление дизайна для реляционной базы данных. Также очень легко создавать значения нашей модели данных и проверять их: val myFavPizza = Pizza(Small, Regular, Seq(Cheese, Pepperoni)) // myFavPizza: Pizza = Pizza( // crustSize = Small, // crustType = Regular, // toppings = List(Cheese, Pepperoni) // ) println(myFavPizza.crustType) // Regular Подробнее о модели данных Таким же образом можно было бы смоделировать всю систему заказа пиццы. Вот несколько других case class-ов, которые используются для моделирования такой системы: case class Address( street1: String, street2: Option[String], city: String, state: String, zipCode: String ) case class Customer( name: String, phone: String, address: Address ) case class Order( pizzas: Seq[Pizza], customer: Customer ) “Узкие доменные объекты” В своей книге Functional and Reactive Domain Modeling, Debasish Ghosh утверждает, что там, где специалисты по ООП описывают свои классы как “широкие модели предметной области”, которые инкапсулируют данные и поведение, модели данных FP можно рассматривать как “узкие объекты предметной области”. Это связано с тем, что, как показано выше, модели данных определяются как case class-ы с атрибутами, но без поведения, что приводит к коротким и лаконичным структурам данных. Моделирование операций Возникает интересный вопрос: поскольку FP отделяет данные от операций над этими данными, то как эти операции реализуются в Scala? Ответ на самом деле довольно прост: пишутся функции/методы, работающие со значениями смоделированных данных. Например, можно определить функцию, которая вычисляет цену пиццы. def pizzaPrice(p: Pizza): Double = p match case Pizza(crustSize, crustType, toppings) =&gt; val base = 6.00 val crust = crustPrice(crustSize, crustType) val tops = toppings.map(toppingPrice).sum base + crust + tops Можно заметить, что реализация функции просто повторяет форму данных: поскольку Pizza является case class-ом, используется сопоставление с образцом для извлечения компонентов, а затем вызываются вспомогательные функции для вычисления отдельных цен. def toppingPrice(t: Topping): Double = t match case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 Точно так же, поскольку Topping является перечислением, используется сопоставление с образцом, чтобы разделить варианты. Сыр и лук продаются по 50 центов за штуку, остальные — по 75. def crustPrice(s: CrustSize, t: CrustType): Double = (s, t) match case (Small | Medium, _) =&gt; 0.25 // игнорируем значение t case (Large, Thin) =&gt; 0.50 case (Large, Regular) =&gt; 0.75 case (Large, Thick) =&gt; 1.00 Чтобы рассчитать цену корки, мы одновременно сопоставляем образцы как по размеру, так и по типу корки. Важным моментом во всех показанных выше функциях является то, что они являются чистыми функциями (pure functions): они не изменяют данные и не имеют других побочных эффектов (таких, как выдача исключений или запись в файл). Всё, что они делают - это просто получают значения и вычисляют результат. Как организовать функциональность? При реализации функции расчета цены пиццы, описанной выше, не было сказано, где ее определять. В Scala 3 вполне допустимо определить функцию на верхнем уровне файла. Тем не менее язык предоставляет множество отличных инструментов для организации логики в различных пространствах имен и модулях. Существует несколько способов реализации и организации поведения: определить функции в сопутствующих объектах (companion object) использовать модульный стиль программирования использовать подход “функциональных объектов” определить функциональность в методах расширения Эти различные решения показаны в оставшейся части этого раздела. Companion Object Первый подход — определить поведение (функции) в сопутствующем объекте. Как обсуждалось в разделе “Инструменты моделирования предметной области”, сопутствующий объект — это объект с тем же именем, что и у класса, и объявленный в том же файле, что и класс. При таком подходе в дополнение к enum или case class также определяется companion object с таким же именем, который содержит поведение (функции). case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) // companion object для кейс класса Pizza object Pizza: def price(p: Pizza): Double = ... // тоже самое, что и pizzaPrice enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions // companion object для перечисления Topping object Topping: def price(t: Topping): Double = t match // тоже самое, что и toppingPrice case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 При таком подходе можно создать Pizza и вычислить ее цену следующим образом: val pizza1 = Pizza(Small, Thin, Seq(Cheese, Onions)) Pizza.price(pizza1) Группировка функциональности с помощью сопутствующих объектов имеет несколько преимуществ: связывает функциональность с данными и облегчает их поиск программистам (и компилятору). создает пространство имен и, например, позволяет использовать price в качестве имени метода, не полагаясь на перегрузку. реализация Topping.price может получить доступ к значениям перечисления, таким как Cheese, без необходимости их импорта. Однако также есть несколько компромиссов, которые следует учитывать: модель данных тесно связывается с функциональностью. В частности, сопутствующий объект должен быть определен в том же файле, что и case class. неясно, где определять такие функции, как crustPrice, которые с одинаковым успехом можно поместить в сопутствующий объект CrustSize или CrustType. Модули Второй способ организации поведения — использование “модульного” подхода. В книге “Программирование на Scala” модуль определяется как “небольшая часть программы с четко определенным интерфейсом и скрытой реализацией”. Давайте посмотрим, что это значит. Создание интерфейса PizzaService Первое, о чем следует подумать, — это “поведение” Pizza. Делая это, определяем trait PizzaServiceInterface следующим образом: trait PizzaServiceInterface: def price(p: Pizza): Double def addTopping(p: Pizza, t: Topping): Pizza def removeAllToppings(p: Pizza): Pizza def updateCrustSize(p: Pizza, cs: CrustSize): Pizza def updateCrustType(p: Pizza, ct: CrustType): Pizza Как показано, каждый метод принимает Pizza в качестве входного параметра вместе с другими параметрами, а затем возвращает экземпляр Pizza в качестве результата. Когда пишется такой чистый интерфейс, можно думать о нем как о контракте, в котором говорится: “Все неабстрактные классы, расширяющие этот trait, должны предоставлять реализацию этих сервисов”. На этом этапе также можно представить, что вы являетесь потребителем этого API. Когда вы это сделаете, будет полезно набросать некоторый пример “потребительского” кода, чтобы убедиться, что API выглядит так, как хотелось: val p = Pizza(Small, Thin, Seq(Cheese)) val p1 = addTopping(p, Pepperoni) val p2 = addTopping(p1, Onions) val p3 = updateCrustType(p2, Thick) val p4 = updateCrustSize(p3, Large) Если с этим кодом все в порядке, как правило, можно начать набрасывать другой API, например API для заказов, но, поскольку сейчас рассматривается только Pizza, перейдем к созданию конкретной реализации этого интерфейса. Обратите внимание, что обычно это двухэтапный процесс. На первом шаге набрасывается контракт API в качестве интерфейса. На втором шаге создается конкретная реализация этого интерфейса. В некоторых случаях в конечном итоге создается несколько конкретных реализаций базового интерфейса. Создание конкретной реализации Теперь, когда известно, как выглядит PizzaServiceInterface, можно создать конкретную реализацию, написав тело для всех методов, определенных в интерфейсе: object PizzaService extends PizzaServiceInterface: def price(p: Pizza): Double = p match case Pizza(crustSize, crustType, toppings) =&gt; val base = 6.00 val crust = crustPrice(crustSize, crustType) val tops = toppings.map(toppingPrice).sum base + crust + tops def addTopping(p: Pizza, t: Topping): Pizza = p.copy(toppings = p.toppings :+ t) def removeAllToppings(p: Pizza): Pizza = p.copy(toppings = Seq.empty) def updateCrustSize(p: Pizza, cs: CrustSize): Pizza = p.copy(crustSize = cs) def updateCrustType(p: Pizza, ct: CrustType): Pizza = p.copy(crustType = ct) private def toppingPrice(t: Topping): Double = t match case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 private def crustPrice(s: CrustSize, t: CrustType): Double = (s, t) match case (Small | Medium, _) =&gt; 0.25 case (Large, Thin) =&gt; 0.50 case (Large, Regular) =&gt; 0.75 case (Large, Thick) =&gt; 1.00 end PizzaService Хотя двухэтапный процесс создания интерфейса с последующей реализацией не всегда необходим, явное продумывание API и его использования — хороший подход. Когда все готово, можно использовать Pizza и PizzaService: import PizzaService.* val p = Pizza(Small, Thin, Seq(Cheese)) // p: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese)) val p1 = addTopping(p, Pepperoni) // p1: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese, Pepperoni)) val p2 = addTopping(p1, Onions) // p2: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese, Pepperoni, Onions)) val p3 = updateCrustType(p2, Thick) // p3: Pizza = Pizza(crustSize = Small, crustType = Thick, toppings = List(Cheese, Pepperoni, Onions)) val p4 = updateCrustSize(p3, Large) // p4: Pizza = Pizza(crustSize = Large, crustType = Thick, toppings = List(Cheese, Pepperoni, Onions)) println(price(p4)) // 8.75 Функциональные объекты В книге “Программирование на Scala” авторы определяют термин “Функциональные объекты” как “объекты, которые не имеют никакого изменяемого состояния”. Это также относится к типам в scala.collection.immutable. Например, методы в List не изменяют внутреннего состояния, а вместо этого создают в результате копию List. Об этом подходе можно думать, как о “гибридном дизайне ФП/ООП”, потому что: данные моделируются, используя неизменяемые case class-ы. определяется поведение (методы) того же типа, что и данные. поведение реализуется как чистые функции: они не изменяют никакого внутреннего состояния; скорее - возвращают копию. Это действительно гибридный подход: как и в дизайне ООП, методы инкапсулированы в класс с данными, но, как это обычно бывает в дизайне ФП, методы реализованы как чистые функции, которые данные не изменяют. Пример Используя этот подход, можно напрямую реализовать функциональность пиццы в case class: case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ): // операции этой модели данных def price: Double = ... // такая же имплементация, как и выше в PizzaService.price def addTopping(t: Topping): Pizza = this.copy(toppings = this.toppings :+ t) def removeAllToppings: Pizza = this.copy(toppings = Seq.empty) def updateCrustSize(cs: CrustSize): Pizza = this.copy(crustSize = cs) def updateCrustType(ct: CrustType): Pizza = this.copy(crustType = ct) Обратите внимание, что в отличие от предыдущих подходов, поскольку это методы класса Pizza, они не принимают ссылку Pizza в качестве входного параметра. Вместо этого у них есть собственная ссылка на текущий экземпляр пиццы - this. Теперь можно использовать этот новый дизайн следующим образом: Pizza(Small, Thin, Seq(Cheese)) .addTopping(Pepperoni) .updateCrustType(Thick) .price Методы расширения Методы расширения - подход, который находится где-то между первым (определение функций в сопутствующем объекте) и последним (определение функций как методов самого типа). Методы расширения позволяют создавать API, похожий на API функционального объекта, без необходимости определять функции как методы самого типа. Это может иметь несколько преимуществ: модель данных снова очень лаконична и не упоминает никакого поведения. можно задним числом развить функциональность типов дополнительными методами, не изменяя исходного определения. помимо сопутствующих объектов или прямых методов типов, методы расширения могут быть определены извне в другом файле. Вернемся к примеру: case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) extension (p: Pizza) def price: Double = pizzaPrice(p) // имплементация выше def addTopping(t: Topping): Pizza = p.copy(toppings = p.toppings :+ t) def removeAllToppings: Pizza = p.copy(toppings = Seq.empty) def updateCrustSize(cs: CrustSize): Pizza = p.copy(crustSize = cs) def updateCrustType(ct: CrustType): Pizza = p.copy(crustType = ct) В приведенном выше коде различные методы для пиццы определяются как методы расширения (extension methods). Код extension (p: Pizza) говорит о том, что мы хотим сделать методы доступными для экземпляров Pizza, и в дальнейшем ссылаемся на экземпляр, который расширяем, как p. Таким образом, получается тот же API, что и раньше: Pizza(Small, Thin, Seq(Cheese)) .addTopping(Pepperoni) .updateCrustType(Thick) .price При этом методы расширения можно определить в любом другом модуле. Как правило, если вы являетесь разработчиком модели данных, вы определяете свои методы расширения в сопутствующем объекте. Таким образом, они уже доступны всем пользователям. В противном случае методы расширения должны быть импортированы явно, чтобы их можно было использовать. Резюме функционального подхода Определение модели данных в Scala/FP, как правило, простое: моделируются варианты данных с помощью enum-ов и составных данных с помощью case class-ов. Затем, чтобы смоделировать поведение, определяются функции, которые работают со значениями модели данных. Были рассмотрены разные способы организации функций: можно поместить методы в сопутствующие объекты можно использовать модульный стиль программирования, разделяющий интерфейс и реализацию можно использовать подход “функциональных объектов” и хранить методы в определенном типе данных можно использовать методы расширения, чтобы снабдить модель данных функциональностью References: Scala3 book, domain modeling fp Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Функциональное программирование",
      "url": "/scalaworkbook/docs/fp.html",
      "content": "Функциональное программирование ??? References: Scala3 book"
    } ,    
    {
      "title": "Функции",
      "url": "/scalaworkbook/docs/functions.html",
      "content": "Функции В этой главе представлены функции Scala. Рассматриваемые темы включают в себя анонимные функции (лямбды), переменные в функциях и функции высшего порядка (HOF - higher-order functions), в том числе способы создания собственных HOF. Функция высшего порядка (HOF) часто определяется как функция, которая принимает другие функции в качестве входных параметров или возвращает функцию в качестве ее значения. В Scala это возможно, потому что функции являются объектами первого класса. Ключевые моменты, которые здесь рассматриваются: как писать анонимные функции в виде небольших фрагментов кода как передать их в десятки HOF (методов) в классах коллекций, то есть в такие методы, как filter, map и т.д. как с помощью этих небольших фрагментов кода и HOF создать множество функциональных возможностей с помощью всего лишь небольшого кода что функциональные переменные - это просто анонимные функции, которые привязаны к переменной как написать методы, которые принимают функции в качестве входных параметров как вернуть функцию из метода как объявлять сигнатуры типов для функций использование одинакового синтаксиса для определения параметров функций, анонимных функций и функциональных переменных References: Scala3 book"
    } ,    
    {
      "title": "Hello, world!",
      "url": "/scalaworkbook/docs/hello_world.html",
      "content": "Hello, world! Пример Scala “Hello, world!” выглядит следующим образом. Сначала поместите этот код в файл с именем Hello.scala: @main def hello = println(\"Hello, world!\") В этом коде hello - это метод. Он определен с помощью def и объявлен как метод “main” с аннотацией @main. Он выводит строку “Hello, world!” в стандартный вывод (STDOUT) с использованием метода println. Затем скомпилируйте код с помощью scalac: &gt; scalac Hello.scala References: Scala3 book"
    } ,    
    {
      "title": "Функции высшего порядка",
      "url": "/scalaworkbook/docs/functions/hofs.html",
      "content": "Функции высшего порядка Функция высшего порядка (HOF - higher-order function) часто определяется как функция, которая принимает другие функции в качестве входных параметров или возвращает функцию в качестве результата. В Scala HOF возможны, потому что функции являются объектами первого класса. В качестве важного примечания: хотя в этом документе используется общепринятый термин “функция высшего порядка”, в Scala эта фраза применима как к методам, так и к функциям. Благодаря технологии Eta Expansion их, как правило, можно использовать в одних и тех же местах. От потребителя к разработчику В примерах, приведенных ранее в документации, было видно, как пользоваться методами, которые принимают другие функции в качестве входных параметров, например, map и filter. В следующих разделах будет показано, как создавать HOF, в том числе: как писать методы, принимающие функции в качестве входных параметров как возвращать функции из методов В процессе будет видно: синтаксис, который используется для определения входных параметров функции как вызвать функцию, если есть на нее ссылка В качестве полезного побочного эффекта, как только синтаксис станет привычным, его можно начать использовать для определения параметров функций, анонимных функций и функциональных переменных, а также станет легче читать Scaladoc для функций высшего порядка. Понимание Scaladoc метода filter Чтобы понять, как работают функции высшего порядка, рассмотрим пример: определим, какой тип функций принимает filter, взглянув на его Scaladoc. Вот определение filter в классе List[A]: def filter(p: (A) =&gt; Boolean): List[A] Это определение указывает на то, что filter - метод, который принимает параметр функции с именем p. По соглашению, p обозначает предикат, который представляет собой просто функцию, возвращающую Boolean. Таким образом, filter принимает предикат p в качестве входного параметра и возвращает List[A], где A - тип, содержащийся в списке; если filter вызывается для List[Int], то A - это тип Int. На данный момент, если не учитывать назначение метода filter, все, что известно, так это то, что алгоритм каким-то образом использует предикат p для создания и возврата List[A]. Если посмотреть конкретно на параметр функции p: p: (A) =&gt; Boolean, то эта часть описания filter означает, что любая передаваемая функция должна принимать тип A в качестве входного параметра и возвращать Boolean. Итак, если список представляет собой список List[Int], то можно заменить универсальный тип A на Int и прочитать эту подпись следующим образом: p: (Int) =&gt; Boolean. Поскольку isEven имеет такой же тип — преобразует входное значение Int в результирующее Boolean — его можно использовать с filter. Написание методов, которые принимают параметры функции Рассмотрим пример написания методов, которые принимают функции в качестве входных параметров. Для определенности, будем называть код, который пишется, методом, а код, принимаемый в качестве входного параметра, — функцией. Пример Чтобы создать метод, который принимает функцию в качестве параметра, необходимо: в списке параметров метода определить сигнатуру принимаемой функции использовать эту функцию внутри метода Чтобы продемонстрировать это, вот метод, который принимает входной параметр с именем f, где f — функция: def sayHello(f: () =&gt; Unit): Unit = f() Эта часть кода — сигнатура типа (type signature) — утверждает, что f является функцией, и определяет типы функций, которые будет принимать метод sayHello: f: () =&gt; Unit. Как это работает: f — имя входного параметра функции. Аналогично тому, как параметр String обычно называется s или параметр Int - i сигнатура типа f определяет тип функций, которые будет принимать метод часть () подписи f (слева от символа =&gt;) указывает на то, что f не принимает входных параметров часть сигнатуры Unit (справа от символа =&gt;) указывает на то, что функция f не должна возвращать осмысленный результат в теле метода sayHello (справа от символа =) оператор f() вызывает переданную функцию Теперь, когда sayHello определен, создадим функцию, соответствующую сигнатуре f, чтобы ее можно было проверить. Следующая функция не принимает входных параметров и ничего не возвращает, поэтому она соответствует сигнатуре типа f: def helloJoe(): Unit = println(\"Hello, Joe\") Поскольку сигнатуры типов совпадают, можно передать helloJoe в sayHello: sayHello(helloJoe) // Hello, Joe Был определен метод с именем sayHello, который принимает функцию в качестве входного параметра, а затем вызывает эту функцию в теле своего метода. sayHello может принимать разные функции Важно знать, что преимущество этого подхода заключается не в том, что sayHello может принимать одну функцию в качестве входного параметра; преимущество в том, что sayHello может принимать любую функцию, соответствующую сигнатуре f. Например, поскольку следующая функция не принимает входных параметров и ничего не возвращает, она также работает с sayHello: def bonjourJulien(): Unit = println(\"Bonjour, Julien\") sayHello(bonjourJulien) // Bonjour, Julien Рассмотрим ещё несколько примеров того, как определять сигнатуры различных типов для параметров функции. Общий синтаксис для определения входных параметров функции В методе: def sayHello(f: () =&gt; Unit): Unit сигнатурой типа для f является () =&gt; Unit. Это сигнатура означает “функцию, которая не принимает входных параметров и не возвращает ничего значимого (Unit)”. Вот сигнатура функции, которая принимает параметр String и возвращает Int: f: (String) =&gt; Int Какие функции принимают строку и возвращают целое число? Например, такие, как “длина строки” и контрольная сумма. Эта функция принимает два параметра Int и возвращает Int: f: (Int, Int) =&gt; Int Какие функции соответствуют данной сигнатуре? Любая функция, которая принимает два входных параметра Int и возвращает Int, соответствует этой сигнатуре, поэтому все “функции” ниже (точнее, методы) подходят: def add(a: Int, b: Int): Int = a + b def subtract(a: Int, b: Int): Int = a - b def multiply(a: Int, b: Int): Int = a * b Из примеров выше можно сделать вывод, что общий синтаксис сигнатуры функций такой: variableName: (parameterTypes ...) =&gt; returnType Поскольку функциональное программирование похоже на создание и объединение ряда алгебраических уравнений, обычно много думают о типах при разработке функций и приложений. Можно сказать, что «думают типами». Параметр функции вместе с другими параметрами Чтобы HOFs стали действительно полезными, им также нужны некоторые данные для работы. Для класса, подобного List, в его методе map уже есть данные для работы: элементы в List. Но для автономного приложения, у которого нет собственных данных, метод также должен принимать в качестве других входных параметров данные. Рассмотрим пример метода с именем executeNTimes, который имеет два входных параметра: функцию и Int: def executeNTimes(f: () =&gt; Unit, n: Int): Unit = for i &lt;- 1 to n do f() Как видно из кода, executeNTimes выполняет функцию f n раз. Поскольку простой цикл for, подобный этому, не имеет возвращаемого значения, executeNTimes возвращает Unit. Чтобы протестировать executeNTimes, определим метод, соответствующий сигнатуре f: def helloWorld(): Unit = println(\"Hello, world\") Затем передадим этот метод в executeNTimes вместе с Int: executeNTimes(helloWorld, 3) // Hello, world // Hello, world // Hello, world Метод executeNTimes трижды выполняет функцию helloWorld. Столько параметров, сколько необходимо Методы могут усложняться по мере необходимости. Например, этот метод принимает функцию типа (Int, Int) =&gt; Int вместе с двумя входными параметрами: def executeAndPrint(f: (Int, Int) =&gt; Int, i: Int, j: Int): Unit = println(f(i, j)) Поскольку методы sum и multiply соответствуют сигнатуре f, их можно передать в executeAndPrint вместе с двумя значениями Int: def sum(x: Int, y: Int) = x + y def multiply(x: Int, y: Int) = x * y executeAndPrint(sum, 3, 11) // 14 executeAndPrint(multiply, 3, 9) // 27 Согласованность подписи типа функции Самое замечательное в изучении сигнатур типов функций Scala заключается в том, что синтаксис, используемый для определения входных параметров функции, — это тот же синтаксис, что используется для написания литералов функций. Например, если необходимо написать функцию, вычисляющую сумму двух целых чисел, её можно было бы написать так: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b Этот код состоит из сигнатуры типа: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----------------- входных параметров: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ------ и тела функции: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----- Согласованность Scala состоит в том, что тип функции: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----------------- совпадает с сигнатурой типа, используемого для определения входного параметра функции: def executeAndPrint(f: (Int, Int) =&gt; Int, ... ----------------- По мере освоения этого синтаксиса, становится привычным его использование для определения параметров функций, анонимных функций и функциональных переменных, а также становится легче читать Scaladoc для функций высшего порядка. References: Scala3 book"
    } ,    
    {
      "title": "Обзор Scala",
      "url": "/scalaworkbook/docs/",
      "content": "Обзор Scala Цель этой документации - дать неофициальное описание языка Scala на русском языке. В ней относительно легко затрагиваются все темы Scala. Для получения дополнительной информации об описываемой теме внизу страницы даны ссылки на справочную документацию, в которой более подробно рассматриваются многие функции языка Scala. Scala - это красивый, выразительный язык программирования с чистым, современным синтаксисом, который обеспечивает безопасную систему статических типов. Он поддерживает как функциональное программирование, так и объектно-ориентированное программирование. Но основной акцент будет сделан именно на функциональном программировании. Особенности Scala 3 References: Scala home page Scala3 book"
    } ,    
    {
      "title": "Основная",
      "url": "/scalaworkbook/",
      "content": "Описание В этом справочнике изложены основные принципы функциональной разработки на Scala, в том числе с помощью популярных фреймворков. Код написан на версии Scala - 3.1.1. Документация Обзор Scala"
    } ,    
    {
      "title": "main методы",
      "url": "/scalaworkbook/docs/methods/main-methods.html",
      "content": "main методы Scala предлагает следующий способ определения программ, которые можно вызывать из командной строки: добавление аннотации @main к методу превращает его в точку входа исполняемой программы: @main def hello() = println(\"Hello, world\") Достаточно сохранить эту строку кода в файле с именем, например, Hello.scala (имя файла необязательно должно совпадать с именем метода) и скомпилировать его с помощью scalac: $ scalac Hello.scala Затем запустить с помощью scala: $ scala hello Hello, world Аннотированный метод @main может быть написан либо на верхнем уровне (как показано), либо внутри статически доступного объекта. В любом случае имя программы - это имя метода без каких-либо префиксов объектов. Аргументы командной строки Метод @main может обрабатывать аргументы командной строки с разными типами. Например, данный метод @main, который принимает параметры Int, String и дополнительные строковые параметры: @main def happyBirthday(age: Int, name: String, others: String*) = val suffix = (age % 100) match case 11 | 12 | 13 =&gt; \"th\" case _ =&gt; (age % 10) match case 1 =&gt; \"st\" case 2 =&gt; \"nd\" case 3 =&gt; \"rd\" case _ =&gt; \"th\" val sb = StringBuilder(s\"Happy $age$suffix birthday, $name\") for other &lt;- others do sb.append(\" and \").append(other) sb.toString После компиляции кода создается основная программа с именем happyBirthday, которая вызывается следующим образом: $ scala happyBirthday 23 Lisa Peter Happy 23rd Birthday, Lisa and Peter! Как показано, метод @main может иметь произвольное количество параметров. Для каждого типа параметра должен быть экземпляр scala.util.FromString, который преобразует аргумент из String в требуемый тип параметра. Также, как показано, список параметров основного метода может заканчиваться повторяющимся параметром типа String*, который принимает все оставшиеся аргументы, указанные в командной строке. Программа, реализованная с помощью метода @main, проверяет, что в командной строке достаточно аргументов для заполнения всех параметров, и что строки аргументов могут быть преобразованы в требуемые типы. Если проверка завершается неудачей, программа завершается с сообщением об ошибке: $ scala happyBirthday 22 Illegal command line after first argument: more arguments expected $ scala happyBirthday sixty Fred Illegal command line: java.lang.NumberFormatException: For input string: \"sixty\" Детали Компилятор Scala генерирует программу из @main метода f следующим образом: он создает класс с именем f в пакете, где был найден метод @main. класс имеет статический метод main с обычной сигнатурой Java main метода: принимает Array[String] в качестве аргумента и возвращает Unit. сгенерированный main метод вызывает метод f с аргументами, преобразованными с помощью методов в объекте scala.util.CommandLineParser. Например, приведенный выше метод happyBirthday генерирует дополнительный код, эквивалентный следующему классу: final class happyBirthday { import scala.util.{CommandLineParser as CLP} &lt;static&gt; def main(args: Array[String]): Unit = try happyBirthday( CLP.parseArgument[Int](args, 0), CLP.parseArgument[String](args, 1), CLP.parseRemainingArguments[String](args, 2)) catch { case error: CLP.ParseError =&gt; CLP.showError(error) } } Примечание: В этом сгенерированном коде модификатор &lt;static&gt; выражает, что main метод генерируется как статический метод класса happyBirthday. Эта функция недоступна для пользовательских программ в Scala. Вместо неё обычные “статические” члены генерируются в Scala с использованием object. @main методы — это рекомендуемый способ создания программ, вызываемых из командной строки в Scala 3. Они заменяют предыдущий подход, который заключался в создании объекта, расширяющего класс App. References: Scala3 book Scala3 book, main Methods"
    } ,    
    {
      "title": "Особенности методов",
      "url": "/scalaworkbook/docs/methods/method-features.html",
      "content": "Особенности методов В этом разделе представлены различные аспекты определения и вызова методов. Определение методов Методы Scala имеют много особенностей, в том числе следующие: Generic параметры Значения параметров по умолчанию Несколько групп параметров Контекстные параметры Параметры по имени (by name parameters) … Синтаксис простого метода выглядит следующим образом: def methodName(param1: Type1, param2: Type2): ReturnType = // здесь тело метода end methodName // опционально, можно не указывать В этом синтаксисе: ключевое слово def используется для определения метода для наименования методов согласно стандартам Scala используется camel case convention у параметров метода необходимо всегда указывать тип возвращаемый тип метода указывать необязательно методы могут состоять как только из одной строки, так и из нескольких строк метку окончания метода end methodName указывать необязательно, её рекомендуется указывать только для длинных методов Вот два примера однострочного метода с именем add, который принимает два входных параметра Int. Первая версия явно показывает возвращаемый тип метода - Int, а вторая - нет: def add(a: Int, b: Int): Int = a + b def add(a: Int, b: Int) = a + b У публичных методов рекомендуется всегда указывать тип возвращаемого значения. Объявление возвращаемого типа может упростить его понимание при просмотре кода другого человека или своего кода спустя некоторое время. Вызов методов Вызов методов прост: val x = add(1, 2) Коллекции Scala имеют десятки встроенных методов. Эти примеры показывают, как их вызывать: val x = List(1, 2, 3) // x: List[Int] = List(1, 2, 3) x.size // res1: Int = 3 x.contains(1) // res2: Boolean = true x.map(_ * 10) // res3: List[Int] = List(10, 20, 30) Внимание: size не принимает аргументов и возвращает количество элементов в списке метод contains принимает один аргумент — значение для поиска map принимает один аргумент - функцию; в данном случае в него передается анонимная функция Многострочные методы Если метод длиннее одной строки, начинайте тело метода со второй строки с отступом вправо: def addThenDouble(a: Int, b: Int): Int = val sum = a + b sum * 2 addThenDouble(1, 1) // res5: Int = 4 В этом методе: sum — неизменяемая локальная переменная; к ней нельзя получить доступ вне метода последняя строка удваивает значение sum - именно это значение возвращается из метода Обратите внимание, что нет необходимости в операторе return в конце метода. Поскольку почти все в Scala является выражением — то это означает, что каждая строка кода возвращает (или вычисляет) значение — нет необходимости использовать return. Это видно на примере того же метода, но в более сжатой форме: def addThenDouble(a: Int, b: Int): Int = (a + b) * 2 В теле метода можно использовать все возможности Scala: if/else выражения match выражения циклы while циклы for и for выражения присвоение переменных вызовы других методов определения других методов В качестве ещё одного примера многострочного метода, getStackTraceAsString преобразует свой входной параметр Throwable в правильно отформатированную строку: def getStackTraceAsString(t: Throwable): String = val sw = StringWriter() t.printStackTrace(PrintWriter(sw)) sw.toString В этом методе: в первой строке переменная sw принимает значение нового экземпляра StringWriter вторая строка сохраняет содержимое трассировки стека в StringWriter третья строка возвращает строковое представление трассировки стека Параметры по умолчанию В параметрах метода можно указывать значения по умолчанию. В этом примере значения по умолчанию заданы как для timeout, так и для protocol: def makeConnection(timeout: Int = 5_000, protocol: String = \"http\") = println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\") Поскольку параметры имеют значения по умолчанию, метод можно вызвать следующими способами: makeConnection() // timeout = 5000, protocol = http makeConnection(2_000) // timeout = 2000, protocol = http makeConnection(3_000, \"https\") // timeout = 3000, protocol = https Ключевые моменты: в первом примере метод вызывается без аргументов, поэтому он использует значения параметров по умолчанию: 5_000 и http во втором примере для значения timeout указано 2_000 - оно используется вместе со значением по умолчанию для protocol в третьем примере указаны значения для обоих параметров, поэтому используются именно они Обратите внимание, что при использовании значений параметров по умолчанию создается впечатление, что используются три разных переопределенных метода. Именованные параметры При вызове метода при желании можно использовать имена параметров. Например, makeConnection также можно вызывать следующими способами: makeConnection(timeout=10_000) // timeout = 10000, protocol = http makeConnection(protocol=\"https\") // timeout = 5000, protocol = https makeConnection(timeout=10_000, protocol=\"https\") // timeout = 10000, protocol = https makeConnection(protocol=\"https\", timeout=10_000) // timeout = 10000, protocol = https Именованные параметры особенно полезны, когда несколько параметров метода имеют один и тот же тип. Без помощи IDE очень сложно понять, какие параметры установлены в значение true или false, и поэтому код может быть трудночитаемым: engage(true, true, true, false) Гораздо более понятным выглядит использование именованных переменных: engage( speedIsSet = true, directionIsSet = true, picardSaidMakeItSo = true, turnedOffParkingBrake = false ) Рекомендации о методах, которые не принимают параметров Когда метод не принимает параметров, говорят, что он имеет arity уровень 0 (arity-0). Аналогично, если метод принимает один параметр - это метод с arity-1. Когда создаются методы arity-0: если метод выполняет побочные эффекты, такие как вызов println, метод объявляется с пустыми скобками. если метод не выполняет побочных эффектов, например, получение размера коллекции, что аналогично доступу к полю в коллекции, круглые скобки опускаются. Например, этот метод выполняет побочный эффект, поэтому он объявлен с пустыми скобками: def speak() = println(\"hi\") При вызове метода нужно обязательно указывать круглые скобки, если он был объявлен с ними: speak // error: \"method speak must be called with () argument\" speak() // prints \"hi\" Хотя это всего лишь соглашение, его соблюдение значительно улучшает читаемость кода: с первого взгляда становится понятно, что метод с arity-0 имеет побочные эффекты. Использование if в качестве тела метода Поскольку выражения if/else возвращают значение, их можно использовать в качестве тела метода. Вот метод с именем isTruthy, реализующий Perl-определения true и false: def isTruthy(a: Any) = if a == 0 || a == \"\" || a == false then false else true Примеры показывают, как работает метод: isTruthy(0) // res13: Boolean = false isTruthy(\"\") // res14: Boolean = false isTruthy(\"hi\") // res15: Boolean = true isTruthy(1.0) // res16: Boolean = true Использование match в качестве тела метода Довольно часто в качестве тела метода используются match-выражения. Вот еще одна версия isTruthy, написанная с match выражением: def isTruthy(a: Matchable) = a match case 0 | \"\" | false =&gt; false case _ =&gt; true Этот метод работает точно так же, как и предыдущий, в котором использовалось выражение if/else. Вместо Any в качестве типа параметра используется Matchable, чтобы принять любое значение, поддерживающее сопоставление с образцом (pattern matching). Контроль видимости методов в классах В классах, объектах, trait-ах и enum-ах методы Scala по умолчанию общедоступны, поэтому созданный здесь экземпляр Dog может получить доступ к методу speak: class Dog: def speak() = println(\"Woof\") val d = new Dog // d: Dog = repl.MdocSession$App4$Dog@625290a4 d.speak() // Woof Также методы можно помечать как private. Это делает их закрытыми в текущем классе, поэтому их нельзя вызвать или переопределить в подклассах: class Animal: private def breathe() = println(\"I’m breathing\") class Cat extends Animal: // this method won’t compile override def breathe() = println(\"Yo, I’m totally breathing\") Если необходимо сделать метод закрытым в текущем классе, но разрешить подклассам вызывать или переопределять его, метод помечается как protected, как показано в примере с методом speak: class Animal: private def breathe() = println(\"I’m breathing\") def walk() = breathe() println(\"I’m walking\") protected def speak() = println(\"Hello?\") class Cat extends Animal: override def speak() = println(\"Meow\") val cat = new Cat cat.walk() cat.speak() cat.breathe() // won’t compile because it’s private Настройка protected означает: к методу (или полю) могут обращаться другие экземпляры того же класса метод (или поле) не виден в текущем пакете он доступен для подклассов Методы в объектах Ранее было показано, что trait-ы и классы могут иметь методы. Ключевое слово object используется для создания одноэлементного класса, и object также может содержать методы. Это хороший способ сгруппировать набор “служебных” методов. Например, этот объект содержит набор методов, которые работают со строками: object StringUtils: def truncate(s: String, length: Int): String = s.take(length) def lettersAndNumbersOnly_?(s: String): Boolean = s.matches(\"[a-zA-Z0-9]+\") def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\") end StringUtils Расширяемые методы Основная цель расширяемых методов (extension methods) - позволить добавлять новые функциональные возможности в закрытые классы. Представим, что у нас есть класс Circle, но мы не можем изменить его исходный код. Например, он может быть определен следующим образом в сторонней библиотеке: case class Circle(x: Double, y: Double, radius: Double) Если необходимо добавить методы в этот класс, можно их определить как методы расширения, например: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 def diameter: Double = c.radius * 2 def area: Double = math.Pi * c.radius * c.radius Ключевое слово extension объявляет о намерении определить один или несколько методов расширения для параметра, заключенного в круглые скобки. Как показано в примере выше, параметры типа Circle затем могут быть использованы в теле методов расширения. Теперь, если есть экземпляр Circle с именем aCircle, можно вызвать эти методы следующим образом: val aCircle = Circle(0.0, 0.0, 1.0) // aCircle: Circle = Circle(x = 0.0, y = 0.0, radius = 1.0) aCircle.circumference // res18: Double = 6.283185307179586 aCircle.diameter // res19: Double = 2.0 aCircle.area // res20: Double = 3.141592653589793 Дополнительно В дальнейшем будет раскрыто еще больше информации о методах, в том числе: вызов методов суперкласса определение и использование параметров по имени (by-name parameters) метод, который принимает функцию inline методы обработка исключений использование изменяемых параметров метода методы, которые имеют несколько групп параметров (частично применяемые функции) методы с generic параметрами References: Scala3 book Scala3 book, Method Features"
    } ,    
    {
      "title": "Методы в коллекциях",
      "url": "/scalaworkbook/docs/collections/methods.html",
      "content": "Методы в коллекциях Важным преимуществом коллекций Scala является то, что они поставляются с десятками методов “из коробки”, которые доступны для неизменяемых и изменяемых типов коллекций. Больше нет необходимости писать пользовательские циклы for каждый раз, когда нужно работать с коллекцией. При переходе от одного проекта к другому, можно обнаружить, что используются одни и те же методы. В коллекциях доступны десятки методов, поэтому здесь показаны не все из них. Показаны только некоторые из наиболее часто используемых методов, в том числе: map filter foreach head tail take, takeWhile drop, dropWhile reduce Следующие методы работают со всеми типами последовательностей, включая List, Vector, ArrayBuffer и т. д.. Примеры рассмотрены на List-е, если не указано иное. Важно напомнить, что ни один из методов в List не изменяет список. Все они работают в функциональном стиле, то есть возвращают новую коллекцию с измененными результатами. Примеры распространенных методов Для общего представления в примерах ниже показаны некоторые из наиболее часто используемых методов коллекций. Вот несколько методов, которые не используют лямбда-выражения: val a = List(10, 20, 30, 40, 10) // a: List[Int] = List(10, 20, 30, 40, 10) a.distinct // res0: List[Int] = List(10, 20, 30, 40) a.drop(2) // res1: List[Int] = List(30, 40, 10) a.dropRight(2) // res2: List[Int] = List(10, 20, 30) a.head // res3: Int = 10 a.headOption // res4: Option[Int] = Some(value = 10) a.init // res5: List[Int] = List(10, 20, 30, 40) a.intersect(List(19,20,21)) // res6: List[Int] = List(20) a.last // res7: Int = 10 a.lastOption // res8: Option[Int] = Some(value = 10) a.slice(2,4) // res9: List[Int] = List(30, 40) a.tail // res10: List[Int] = List(20, 30, 40, 10) a.take(3) // res11: List[Int] = List(10, 20, 30) a.takeRight(2) // res12: List[Int] = List(40, 10) Функции высшего порядка и лямбда-выражения Далее будут показаны некоторые часто используемые функции высшего порядка (HOF), которые принимают лямбды (анонимные функции). Для начала приведем несколько вариантов лямбда-синтаксиса, начиная с самой длинной формы, поэтапно переходящей к наиболее сжатой: a.filter((i: Int) =&gt; i &lt; 25) // res13: List[Int] = List(10, 20, 10) a.filter((i) =&gt; i &lt; 25) // res14: List[Int] = List(10, 20, 10) a.filter(i =&gt; i &lt; 25) // res15: List[Int] = List(10, 20, 10) a.filter(_ &lt; 25) // res16: List[Int] = List(10, 20, 10) В этих примерах: Первый пример показывает самую длинную форму. Такое многословие требуется редко, только в самых сложных случаях. Компилятор знает, что a содержит Int, поэтому нет необходимости повторять это в функции. Если в функции только один параметр, например i, то скобки не нужны. В случае одного параметра, если он появляется в анонимной функции только раз, его можно заменить на _. В главе Анонимные функции представлена более подробная информация и примеры правил, связанных с сокращением лямбда-выражений. Примеры других HOF, использующих краткий лямбда-синтаксис: a.dropWhile(_ &lt; 25) // res17: List[Int] = List(30, 40, 10) a.filter(_ &gt; 35) // res18: List[Int] = List(40) a.filterNot(_ &lt; 25) // res19: List[Int] = List(30, 40) a.find(_ &gt; 20) // res20: Option[Int] = Some(value = 30) a.takeWhile(_ &lt; 30) // res21: List[Int] = List(10, 20) Важно отметить, что HOF также принимают в качестве параметров методы и функции, а не только лямбда-выражения. Вот несколько примеров, в которых используется метод с именем double. Снова показаны несколько вариантов лямбда-выражений: def double(i: Int) = i * 2 a.map(i =&gt; double(i)) // res22: List[Int] = List(20, 40, 60, 80, 20) a.map(double(_)) // res23: List[Int] = List(20, 40, 60, 80, 20) a.map(double) // res24: List[Int] = List(20, 40, 60, 80, 20) В последнем примере, когда анонимная функция состоит из одного вызова функции, принимающей один аргумент, нет необходимости указывать имя аргумента, поэтому даже _ не требуется. Наконец, HOF можно комбинировать: a.filter(_ &lt; 40) .takeWhile(_ &lt; 30) .map(_ * 10) // res25: List[Int] = List(100, 200) P.S. Пример призван показать только то, как принято последовательно вызывать функции на неизменяемых коллекциях. Его недостаток в том, что обход коллекции происходит целых три раза. Пример данных В следующих разделах используются следующие списки: val oneToTen = (1 to 10).toList // oneToTen: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val names = List(\"adam\", \"brandy\", \"chris\", \"david\") // names: List[String] = List(\"adam\", \"brandy\", \"chris\", \"david\") map Метод map проходит через каждый элемент в списке, применяя переданную функцию к элементу, по одному за раз; затем возвращается новый список с измененными элементами. Вот пример применения метода map к списку oneToTen: val doubles = oneToTen.map(_ * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) Также можно писать анонимные функции, используя более длинную форму, например: val doubles = oneToTen.map(i =&gt; i * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) Однако в этом документе будет всегда использоваться первая, более короткая форма. Вот еще несколько примеров применения метода map к oneToTen и names: val capNames = names.map(_.capitalize) // capNames: List[String] = List(\"Adam\", \"Brandy\", \"Chris\", \"David\") val nameLengthsMap = names.map(s =&gt; (s, s.length)).toMap // nameLengthsMap: Map[String, Int] = Map(\"adam\" -&gt; 4, \"brandy\" -&gt; 6, \"chris\" -&gt; 5, \"david\" -&gt; 5) val isLessThanFive = oneToTen.map(_ &lt; 5) // isLessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false) Как показано в последних двух примерах, совершенно законно (и распространено) использование map для возврата коллекции, которая имеет тип, отличный от исходного типа. filter Метод filter создает новый список, содержащий только те элементы, которые удовлетворяют предоставленному предикату. Предикат или условие — это функция, которая возвращает Boolean (true или false). Вот несколько примеров: val lessThanFive = oneToTen.filter(_ &lt; 5) // lessThanFive: List[Int] = List(1, 2, 3, 4) val evens = oneToTen.filter(_ % 2 == 0) // evens: List[Int] = List(2, 4, 6, 8, 10) val shortNames = names.filter(_.length &lt;= 4) // shortNames: List[String] = List(\"adam\") Отличительной особенностью функциональных методов коллекций является то, что их можно объединять вместе для решения задач. Например, в этом примере показано, как связать filter и map: oneToTen.filter(_ &lt; 4).map(_ * 10) // res26: List[Int] = List(10, 20, 30) Если filter используется перед map, flatMap или foreach, то для лучшей производительности он заменяется на withFilter, например, oneToTen.withFilter(_ &lt; 4).map(_ * 10) foreach Метод foreach используется для перебора всех элементов коллекции. Стоит обратить внимание, что foreach используется для побочных эффектов, таких как печать информации. Вот пример с names: names.foreach(println) // adam // brandy // chris // david head Метод head взят из Lisp и других более ранних языков функционального программирования. Он используется для доступа к первому элементу (головному (head) элементу) списка: oneToTen.head // res28: Int = 1 names.head // res29: String = \"adam\" String можно рассматривать как последовательность символов, т.е. строка также является коллекцией и имеет многие методы коллекций. Вот как head работает со строками: \"foo\".head // res30: Char = 'f' \"bar\".head // res31: Char = 'b' На пустой коллекции head выдает исключение: val emptyList = List[Int]() // emptyList: List[Int] = List() emptyList.head // java.util.NoSuchElementException: head of empty list // at scala.collection.immutable.Nil$.head(List.scala:662) // at scala.collection.immutable.Nil$.head(List.scala:661) // at repl.MdocSession$App.$init$$$anonfun$17(methods.md:252) Чтобы не натыкаться на исключение вместо head желательно использовать headOption, особенно при разработке в функциональном стиле: emptyList.headOption // res32: Option[Int] = None headOption не генерирует исключение, а возвращает тип Option со значением None. Более подробно о функциональном стиле программирования будет рассказано в соответствующей главе. tail Метод tail также взят из Lisp и используется для вывода всех элементов в списке после head. oneToTen.head // res33: Int = 1 oneToTen.tail // res34: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10) names.head // res35: String = \"adam\" names.tail // res36: List[String] = List(\"brandy\", \"chris\", \"david\") Так же, как и head, tail можно использовать со строками: \"foo\".tail // res37: String = \"oo\" \"bar\".tail // res38: String = \"ar\" tail выбрасывает исключение java.lang.UnsupportedOperationException, если список пуст, поэтому, как и в случае с head и headOption, существует также метод tailOption, который предпочтительнее в функциональном программировании. Список матчится, поэтому можно использовать такие выражения: val x :: xs = names // x: String = \"adam\" // xs: List[String] = List(\"brandy\", \"chris\", \"david\") x - это head списка, а xs - tail. Подобный pattern matching полезен во многих случаях, например, при написании метода суммирования с использованием рекурсии: def sum(list: List[Int]): Int = list match case Nil =&gt; 0 case x :: xs =&gt; x + sum(xs) take, takeRight, takeWhile Методы take, takeRight и takeWhile предоставляют удобный способ “брать” (take) элементы из списка для создания нового. Примеры take и takeRight: oneToTen.take(1) // res39: List[Int] = List(1) oneToTen.take(2) // res40: List[Int] = List(1, 2) oneToTen.takeRight(1) // res41: List[Int] = List(10) oneToTen.takeRight(2) // res42: List[Int] = List(9, 10) Обратите внимание, как эти методы работают с «пограничными» случаями, когда запрашивается больше элементов, чем есть в последовательности, или запрашивается ноль элементов: oneToTen.take(Int.MaxValue) // res43: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.takeRight(Int.MaxValue) // res44: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.take(0) // res45: List[Int] = List() oneToTen.takeRight(0) // res46: List[Int] = List() А это takeWhile, который работает с функцией-предикатом: oneToTen.takeWhile(_ &lt; 5) // res47: List[Int] = List(1, 2, 3, 4) names.takeWhile(_.length &lt; 5) // res48: List[String] = List(\"adam\") drop, dropRight, dropWhile drop, dropRight и dropWhile удаляют элементы из списка и, по сути, противоположны своим аналогам “take”. Вот некоторые примеры: oneToTen.drop(1) // res49: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.drop(5) // res50: List[Int] = List(6, 7, 8, 9, 10) oneToTen.dropRight(8) // res51: List[Int] = List(1, 2) oneToTen.dropRight(7) // res52: List[Int] = List(1, 2, 3) Пограничные случаи: oneToTen.drop(Int.MaxValue) // res53: List[Int] = List() oneToTen.dropRight(Int.MaxValue) // res54: List[Int] = List() oneToTen.drop(0) // res55: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.dropRight(0) // res56: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) А это dropWhile, который работает с функцией-предикатом: oneToTen.dropWhile(_ &lt; 5) // res57: List[Int] = List(5, 6, 7, 8, 9, 10) names.dropWhile(_ != \"chris\") // res58: List[String] = List(\"chris\", \"david\") reduce Метод reduce позволяет свертывать коллекцию до одного агрегируемого значения. Он принимает функцию (или анонимную функцию) и последовательно применяет эту функцию к элементам в списке. Лучший способ объяснить reduce — создать небольшой вспомогательный метод. Например, метод add, который складывает вместе два целых числа, а также предоставляет хороший вывод отладочной информации: def add(x: Int, y: Int): Int = val theSum = x + y println(s\"received $x and $y, their sum is $theSum\") theSum Рассмотрим список: val a = List(1,2,3,4) вот что происходит, когда в reduce передается метод add: a.reduce(add) // received 1 and 2, their sum is 3 // received 3 and 3, their sum is 6 // received 6 and 4, their sum is 10 // res59: Int = 10 Как видно из результата, функция reduce использует add для сокращения списка a до единственного значения, в данном случае — суммы всех чисел в списке. reduce можно использовать с анонимными функциями: a.reduce(_ + _) // res60: Int = 10 Аналогично можно использовать другие функции, например, перемножение всех чисел: a.reduce(_ * _) // res61: Int = 24 Дальнейшее изучение коллекций В коллекциях Scala есть десятки дополнительных методов, которые избавят от необходимости писать еще один цикл for. Более подробную информацию о коллекциях Scala см. в разделе Изменяемые и неизменяемые коллекции и Архитектура коллекций Scala. А также в API. В качестве последнего примечания, при использовании Java-кода в проекте Scala, коллекции Java можно преобразовать в коллекции Scala. После этого, их можно использовать в выражениях for, а также воспользоваться преимуществами методов функциональных коллекций Scala. Более подробную информацию можно найти в разделе Взаимодействие с Java. References: Scala3 book Scala3 book, Collections Methods Изменяемые и неизменяемые коллекции Архитектура коллекций Scala collections API"
    } ,    
    {
      "title": "Методы",
      "url": "/scalaworkbook/docs/methods.html",
      "content": "Методы Scala classes, case classes, case objects, traits, enums, и objects могут содержать методы. Кроме того, они могут быть определены вне любой из перечисленных конструкций. Методы являются определениями “верхнего уровня”, поскольку не вложены в другое определение. Проще говоря, методы теперь могут быть определены где угодно. Многие особенности методов продемонстрированы в следующем разделе. Отдельно выделен раздел для main методов. References: Scala3 book"
    } ,    
    {
      "title": "Моделирование данных",
      "url": "/scalaworkbook/docs/modeling.html",
      "content": "Моделирование данных В этой главе показано моделирование данных с помощью Scala 3: в разделе “Инструменты” представлены доступные инструменты, включая class-ы, trait-ы, enum-ы и многое другое в разделе “Моделирование ООП” рассматриваются атрибуты и поведение моделирования в стиле объектно-ориентированного программирования (ООП) в разделе “Моделирование FP” рассматривается моделирование предметной области в стиле функционального программирования (FP) References: Scala3 book"
    } ,    
    {
      "title": "Моделирование ООП",
      "url": "/scalaworkbook/docs/modeling/oop.html",
      "content": "Моделирование ООП Введение Scala предоставляет все необходимые инструменты для объектно-ориентированного проектирования: Traits позволяют указывать (абстрактные) интерфейсы, а также конкретные реализации. Mixin Composition предоставляет инструменты для создания компонентов из более мелких деталей. Классы могут реализовывать интерфейсы, заданные traits. Экземпляры классов могут иметь свое собственное приватное состояние. Subtyping позволяет использовать экземпляр одного класса там, где ожидается экземпляр его суперкласса. Модификаторы доступа позволяют управлять, к каким членам класса можно получить доступ с помощью какой части кода. Traits Возможно, в отличие от других языков программирования с поддержкой ООП таких, как Java, основным инструментом декомпозиции в Scala являются не классы, а traits. Они могут служить для описания абстрактных интерфейсов, таких как: trait Showable: def show: String , а также могут содержать конкретные реализации: trait Showable: def show: String def showHtml = \"&lt;p&gt;\" + show + \"&lt;/p&gt;\" На примере видно, что метод showHtml определяется в терминах абстрактного метода show. Odersky и Zenger представляют сервис-ориентированную компонентную модель и рассматривают: абстрактные члены как требуемые службы: их все еще необходимо реализовать в подклассе. конкретные члены как предоставляемые услуги: они предоставляются подклассу. Это видно на примере со Showable: определяя класс Document, который расширяет Showable, все еще нужно определить show, но showHtml уже предоставляется: class Document(text: String) extends Showable: def show = text Абстрактные методы Абстрактными в trait могут оставаться не только методы. trait может содержать: абстрактные методы (def m(): T) абстрактные переменные (val x: T) абстрактные типы (type T), потенциально с ограничениями (type T &lt;: S) абстрактные given (given t: T) - подробнее об given в следующих главах Каждая из вышеперечисленных функций может быть использована для определения той или иной формы требований к реализатору trait. Mixin Composition Кроме того, что trait-ы могут содержать абстрактные и конкретные определения, Scala также предоставляет мощный способ создания нескольких trait: структура, которую часто называют смешанной композицией. Предположим, что следующие два (потенциально независимо определенные) trait-а: trait GreetingService: def translate(text: String): String def sayHello = translate(\"Hello\") trait TranslationService: def translate(text: String): String = \"...\" Чтобы скомпоновать два сервиса, можно просто создать новый trait, расширяющий их: trait ComposedService extends GreetingService, TranslationService Абстрактные элементы в одном trait-е (например, translate в GreetingService) автоматически сопоставляются с конкретными элементами в другом trait-е. Это работает не только с методами, как в этом примере, но и со всеми другими абстрактными членами, упомянутыми выше (то есть типами, переменными и т.д.). Классы trait-ы отлично подходят для модуляции компонентов и описания интерфейсов (обязательных и предоставляемых). Но в какой-то момент возникнет необходимость создавать их экземпляры. При разработке программного обеспечения в Scala часто бывает полезно рассмотреть возможность использования классов только на начальных этапах модели наследования: Traits - T1, T2, T3 Composed traits - S extends T1, T2, S extends T2, T3 Classes - C extends S, T3 Instances - C() Это еще более актуально в Scala 3, где trait-ы теперь также могут принимать параметры конструктора, что еще больше устраняет необходимость в классах. Определение класса Подобно trait-ам, классы могут расширять несколько trait-ов (но только один суперкласс): class MyService(name: String) extends ComposedService, Showable: def show = s\"$name says $sayHello\" Subtyping Экземпляр MyService создается следующим образом: val s1: MyService = MyService(\"Service 1\") С помощью подтипов экземпляр s1 можно использовать везде, где ожидается любое из расширенных свойств: val s2: GreetingService = s1 val s3: TranslationService = s1 val s4: Showable = s1 // ... и т.п. ... Планирование расширения Как упоминалось ранее, можно расширить еще один класс: class Person(name: String) class SoftwareDeveloper(name: String, favoriteLang: String) extends Person(name) Однако, поскольку trait-ы разработаны как основное средство декомпозиции, класс, определенный в одном файле, не может быть расширен в другом файле. Чтобы разрешить это, базовый класс должен быть помечен как открытый: open class Person(name: String) Маркировка классов с помощью open - это новая функция Scala 3. Необходимость явно помечать классы как открытые позволяет избежать многих распространенных ошибок в ООП. В частности, это требует, чтобы разработчики библиотек явно планировали расширение и, например, документировали классы, помеченные как открытые. Экземпляры и приватное изменяемое состояние Как и в других языках с поддержкой ООП, trait-ы и классы в Scala могут определять изменяемые поля: class Counter: private var currentCount = 0 def tick(): Unit = currentCount += 1 def count: Int = currentCount Каждый экземпляр класса Counter имеет собственное приватное состояние, которое можно наблюдать только через метод count, как показано в следующем примере: val c1 = Counter() c1.count // res1: Int = 0 c1.tick() c1.tick() c1.count // res4: Int = 2 Модификаторы доступа По умолчанию все определения элементов в Scala являются общедоступными. Чтобы скрыть детали реализации, можно определить элементы (методы, поля, типы и т.д.) как private или protected. Таким образом можно контролировать, как к ним обращаются или как их переопределяют. Закрытые (private) члены видны только самому классу/trait-у и его сопутствующему объекту. Защищенные (protected) члены также видны подклассам класса. Дополнительный пример: сервис-ориентированный дизайн Далее будут проиллюстрированы некоторые расширенные возможности Scala и показано, как их можно использовать для структурирования более крупных программных компонентов. Примеры взяты из статьи Мартина Одерски и Маттиаса Зенгера Масштабируемые компонентные абстракции. Пример в первую очередь предназначен для демонстрации того, как использовать несколько функций типа для создания более крупных компонентов. Цель состоит в том, чтобы определить программный компонент с семейством типов, которые могут быть уточнены позже при реализации компонента. Конкретно, следующий код определяет компонент SubjectObserver как trait с двумя членами абстрактного типа, S (для субъектов) и O (для наблюдателей): trait SubjectObserver: type S &lt;: Subject type O &lt;: Observer trait Subject { self: S =&gt; private var observers: List[O] = List() def subscribe(obs: O): Unit = observers = obs :: observers def publish() = for obs &lt;- observers do obs.notify(this) } trait Observer { def notify(sub: S): Unit } Есть несколько вещей, которые нуждаются в объяснении. Члены абстрактного типа Тип объявления S &lt;: Subject говорит, что внутри trait SubjectObserver можно ссылаться на некоторый неизвестный (то есть абстрактный) тип, который называется S. Однако этот тип не является полностью неизвестным: мы знаем, по крайней мере, что это какой-то подтип Subject. Все trait-ы и классы, расширяющие SubjectObserver, могут свободно выбирать любой тип для S, если выбранный тип является подтипом Subject. Часть &lt;: Subject декларации также упоминается как верхняя граница на S. Вложенные trait-ы В рамках trait-а SubjectObserver определяются два других trait-а. trait Observer, который определяет только один абстрактный метод notify с одним аргументом типа S. Как будет видно, важно, чтобы аргумент имел тип S, а не тип Subject. Второй trait, Subject, определяет одно приватное поле observers для хранения всех наблюдателей, подписавшихся на этот конкретный объект. Подписка на объект просто сохраняет объект в списке. Опять же, тип параметра obs - это O, а не Observer. Аннотации собственного типа Наконец, что означает self: S =&gt; в trait-е Subject? Это называется аннотацией собственного типа. И требует, чтобы подтипы Subject также были подтипами S. Это необходимо, чтобы иметь возможность вызывать obs.notify с this в качестве аргумента, поскольку для этого требуется значение типа S. Если бы S был конкретным типом, аннотацию собственного типа можно было бы заменить на trait Subject, расширяющий S. Реализация компонента Теперь можно реализовать вышеуказанный компонент и определить члены абстрактного типа как конкретные типы: object SensorReader extends SubjectObserver: type S = Sensor type O = Display class Sensor(val label: String) extends Subject: private var currentValue = 0.0 def value = currentValue def changeValue(v: Double) = currentValue = v publish() class Display extends Observer: def notify(sub: Sensor) = println(s\"${sub.label} has value ${sub.value}\") В частности, мы определяем singleton object SensorReader, который расширяет SubjectObserver. В реализации SensorReader говорится, что type S теперь определяется как type Sensor, а type O определяется как type Display. И Sensor, и Display определяются как вложенные классы в SensorReader, реализующие trait-ы Subject и Observer соответственно. Помимо того, что этот код является примером сервис-ориентированного дизайна, он также освещает многие аспекты объектно-ориентированного программирования: Класс Sensor вводит свое собственное частное состояние (currentValue) и инкапсулирует изменение состояния за методом changeValue. Реализация changeValue использует метод publish, определенный в родительском trait-е. Класс Display расширяет trait Observer и реализует отсутствующий метод notify. Важно отметить, что реализация notify может безопасно получить доступ только к label и value sub, поскольку мы изначально объявили параметр типа S. Использование компонента Наконец, следующий код иллюстрирует, как использовать компонент SensorReader: import SensorReader.* // настройка сети val s1 = Sensor(\"sensor1\") val s2 = Sensor(\"sensor2\") val d1 = Display() val d2 = Display() s1.subscribe(d1) s1.subscribe(d2) s2.subscribe(d1) // распространение обновлений по сети s1.changeValue(2) // sensor1 has value 2.0 // sensor1 has value 2.0 s2.changeValue(3) // sensor2 has value 3.0 Имея под рукой все утилиты объектно-ориентированного программирования, в следующем разделе будет продемонстрировано, как разрабатывать программы в функциональном стиле. References: Scala3 book, domain modeling oop Scala3 book, taste modeling Scala3 book, taste objects Odersky and Zenger. Scalable component abstractions"
    } ,    
    {
      "title": "Распределение по пакетам и импорт",
      "url": "/scalaworkbook/docs/packaging.html",
      "content": "Распределение по пакетам и импорт Scala использует packages для создания пространств имен, которые позволяют модульно разбивать программы. Scala поддерживает стиль именования пакетов, используемый в Java, а также нотацию пространства имен “фигурные скобки”, используемую такими языками, как C++ и C#. Подход Scala к импорту похож на Java, но более гибкий. С помощью Scala можно: импортировать пакеты, классы, объекты, trait-ы и методы размещать операторы импорта в любом месте скрывать и переименовывать участников при импорте Эти особенности демонстрируются в следующих примерах. Создание пакета Пакеты создаются путем объявления одного или нескольких имен пакетов в начале файла Scala. Например, если ваше доменное имя acme.com и вы работаете с пакетом model приложения с именем myapp, объявление пакета выглядит следующим образом: package com.acme.myapp.model class Person ... По соглашению все имена пакетов должны быть строчными, а формальным соглашением об именах является &lt;top-level-domain&gt;.&lt;domain-name&gt;.&lt;project-name&gt;.&lt;module-name&gt;. Хотя это и не обязательно, имена пакетов обычно совпадают с именами иерархии каталогов. Поэтому, если следовать этому соглашению, класс Person в этом проекте будет найден в файле MyApp/src/main/scala/com/acme/myapp/model/Person.scala. Использование нескольких пакетов в одном файле Показанный выше синтаксис применяется ко всему исходному файлу: все определения в файле Person.scala принадлежат пакету com.acme.myapp.model в соответствии с package в начале файла. В качестве альтернативы можно написать package, которые применяются только к содержащимся в них определениям: package users: package administrators: // полное имя пакета - users.administrators class AdminUser // полное имя файла - users.administrators.AdminUser package normalusers: // полное имя пакета - users.normalusers class NormalUser // полное имя файла - users.normalusers.NormalUser Обратите внимание, что за именами пакетов следует двоеточие, а определения внутри пакета имеют отступ. Преимущество этого подхода заключается в том, что он допускает вложение пакетов и обеспечивает более очевидный контроль над областью действия и инкапсуляцией, особенно в пределах одного файла. Операторы импорта Операторы импорта используются для доступа к сущностям в других пакетах. Операторы импорта делятся на две основные категории: импорт классов, trait-ов, объектов, функций и методов импорт given предложений Первая категория операторов импорта аналогична тому, что использует Java, с немного другим синтаксисом, обеспечивающим большую гибкость. Пример: import users.* // импортируется все из пакета `users` import users.User // импортируется только класс `User` import users.{User, UserPreferences} // импортируются только два члена пакета import users.{UserPreferences as UPrefs} // переименование импортированного члена Эти примеры предназначены для того, чтобы дать представление о том, как работает первая категория операторов import. Более подробно они объясняются в следующих подразделах. Операторы импорта также используются для импорта given экземпляров в область видимости. Они обсуждаются в конце этой главы. import не требуется для доступа к членам одного и того же пакета. Импорт одного или нескольких членов В Scala импортировать один элемент из пакета можно следующим образом: import scala.concurrent.Future несколько: import scala.concurrent.Future import scala.concurrent.Promise import scala.concurrent.blocking При импорте нескольких элементов можно импортировать их более лаконично: import scala.concurrent.{Future, Promise, blocking} Если необходимо импортировать все из пакета scala.concurrent, используется такой синтаксис: import scala.concurrent.* Переименование элементов при импорте Иногда необходимо переименовать объекты при их импорте, чтобы избежать конфликтов имен. Например, если нужно использовать Scala класс List вместе с java.util.List, то можно переименовать java.util.List при импорте: import java.util.{List as JavaList} Теперь имя JavaList можно использовать для ссылки на класс java.util.List и использовать List для ссылки на Scala класс List. Также можно переименовывать несколько элементов одновременно, используя следующий синтаксис: import java.util.{Date as JDate, HashMap as JHashMap, *} В этой строке кода говорится следующее: “Переименуйте классы Date и HashMap, как показано, и импортируйте все остальное из пакета java.util, не переименовывая”. Скрытие членов при импорте При импорте часть объектов можно скрывать. Следующий оператор импорта скрывает класс java.util.Random, в то время как все остальное в пакете java.util импортируется: import java.util.{Random as _, *} Если попытаться получить доступ к классу Random, то выдается ошибка, но есть доступ ко всем остальным членам пакета java.util: val r = new Random // не скомпилируется new ArrayList // доступ есть Скрытие нескольких элементов Чтобы скрыть в import несколько элементов, их можно перечислить перед использованием *: import java.util.{List as _, Map as _, Set as _, *} Перечисленные классы скрыты, но можно использовать все остальное в java.util: val arr = new ArrayList[String] // arr: ArrayList[String] = [] Поскольку эти Java классы скрыты, можно использовать классы Scala List, Set и Map без конфликта имен: val a = List(1, 2, 3) // a: List[Int] = List(1, 2, 3) val b = Set(1, 2, 3) // b: Set[Int] = Set(1, 2, 3) val c = Map(1 -&gt; 1, 2 -&gt; 2) // c: Map[Int, Int] = Map(1 -&gt; 1, 2 -&gt; 2) Импорт можно использовать в любом месте В Scala операторы импорта могут быть объявлены где угодно. Их можно использовать в верхней части файла исходного кода: package foo import scala.util.Random class ClassA: def printRandom: val r = new Random // класс Random здесь доступен // ещё код... Также операторы импорта можно использовать ближе к тому месту, где они необходимы: package foo class ClassA: import scala.util.Random // внутри ClassA def printRandom { val r = new Random // ещё код... class ClassB: // класс Random здесь невидим val r = new Random // этот код не скомпилится “Статический” импорт Если необходимо импортировать элементы способом, аналогичным подходу «статического импорта» в Java, то есть для того, чтобы напрямую обращаться к членам класса, не добавляя к ним префикс с именем класса, используется следующий подход. Синтаксис для импорта всех статических членов Java класса Math: import java.lang.Math.* Теперь можно получить доступ к статическим методам класса Math, таким как sin и cos, без необходимости предварять их именем класса: import java.lang.Math.* val a = sin(0) // a: Double = 0.0 val b = cos(PI) // b: Double = -1.0 Пакеты, импортированные по умолчанию Два пакета неявно импортируются во все файлы исходного кода: java.lang.* scala.* Члены object Predef также импортируются по умолчанию. Например, такие классы, как List, Vector, Map и т. д. можно использовать явно, не импортируя их - они доступны, потому что определены в object Predef Обработка конфликтов имен Если необходимо импортировать что-то из корня проекта и возникает конфликт имен, достаточно просто добавить к имени пакета префикс _root_: package accounts import _root_.accounts.* Импорт given Как будет показано в главе “Контекстные абстракции”, для импорта экземпляров given используется специальная форма оператора import. Базовая форма показана в этом примере: object A: class TC given tc as TC def f(using TC) = ??? object B: import A.* // import all non-given members import A.given // import the given instance В этом коде предложение import A.* объекта B импортирует все элементы A, кроме given экземпляра tc. И наоборот, второй импорт, import A.given, импортирует только given экземпляр. Два предложения импорта также могут быть объединены в одно: object B: import A.{given, *} Селектор с подстановочным знаком * помещает в область видимости все определения, кроме given, тогда как селектор выше помещает в область действия все данные, включая те, которые являются результатом расширений. Эти правила имеют два основных преимущества: более понятно, откуда берутся данные given. В частности, невозможно скрыть импортированные given в длинном списке других импортируемых подстановочных знаков. есть возможность импортировать все given, не импортируя ничего другого. Это особенно важно, поскольку given могут быть анонимными, поэтому обычное использование именованного импорта нецелесообразно. Импорт по типу Поскольку given-ы могут быть анонимными, не всегда практично импортировать их по имени, и вместо этого обычно используется импорт подстановочных знаков. Импорт по типу предоставляет собой более конкретную альтернативу импорту с подстановочными знаками, делая понятным то, что импортируется. Этот код импортирует из A любой given тип, соответствующий TC: import A.{given TC} Если импортируется только один given, то фигурные скобки можно опустить: import A.given TC Импорт данных нескольких типов T1,...,Tn выражается несколькими given селекторами: import A.{given T1, ..., given Tn} Импорт всех given экземпляров параметризованного типа достигается аргументами с подстановочными знаками. Например, есть такой объект: object Instances: given intOrd as Ordering[Int] given listOrd[T: Ordering] as Ordering[List[T]] given ec as ExecutionContext = ... given im as Monoid[Int] Оператор import ниже импортирует экземпляры intOrd, listOrd и ec, но пропускает экземпляр im, поскольку он не соответствует ни одному из указанных шаблонов: import Instances.{given Ordering[?], given ExecutionContext} Импорт по типу можно смешивать с импортом по имени. Если оба присутствуют в предложении import, импорт по типу идет последним. Например, это предложение импорта импортирует im, intOrd и listOrd, но не включает ec: import Instances.{im, given Ordering[?]} Пример В качестве конкретного примера представим, что у нас есть объект MonthConversions, который содержит два определения given: object MonthConversions: trait MonthConverter[A]: def convert(a: A): String given intMonthConverter: MonthConverter[Int] with def convert(i: Int): String = i match case 1 =&gt; \"January\" case 2 =&gt; \"February\" case _ =&gt; \"Other\" given stringMonthConverter: MonthConverter[String] with def convert(s: String): String = s match case \"jan\" =&gt; \"January\" case \"feb\" =&gt; \"February\" case _ =&gt; \"Other\" Чтобы импортировать эти given-ы в текущую область, используем два оператора import: import MonthConversions.* import MonthConversions.given MonthConverter[?] Теперь создаем метод, использующий эти экземпляры: def genericMonthConverter[A](a: A)(using monthConverter: MonthConverter[A]): String = monthConverter.convert(a) Вызов метода: genericMonthConverter(1) // res1: String = \"January\" genericMonthConverter(\"jan\") // res2: String = \"January\" Как уже упоминалось ранее, одно из ключевых преимуществ синтаксиса “import given” состоит в том, чтобы прояснить, откуда берутся данные в области действия, и в import операторах выше ясно, что данные поступают из объекта MonthConversions. References: Scala3 book"
    } ,      
    {
      "title": "Написание метода возвращающего функцию",
      "url": "/scalaworkbook/docs/functions/returns-function.html",
      "content": "Написание метода возвращающего функцию Благодаря согласованности Scala написание метода, возвращающего функцию, похоже на то, что было описано в предыдущих разделах. Еще раз начнем с постановки проблемы: Необходимо создать метод greet, возвращающий функцию. Эта функция должна принимать строковый параметр и печатать его с помощью println. Начнем с простого шага: greet не принимает никаких входных параметров, а просто создает функцию и возвращает её. Учитывая это утверждение, можно начать создавать greet. Известно, что это будет метод: def greet() Также известно, что этот метод должен возвращать функцию, которая: принимает параметр String и печатает эту строку с помощью println. Следовательно, эта функция имеет тип String =&gt; Unit: def greet(): String =&gt; Unit = ??? ---------------- Теперь нужно создать тело метода. Возвращаемая функция соответствует следующему описанию: (name: String) =&gt; println(s\"Hello, $name\") Добавляем эту функцию в тело метода: def greet(): String =&gt; Unit = (name: String) =&gt; println(s\"Hello, $name\") Поскольку метод возвращает функцию, мы получаем ее, вызывая greet(). val greetFunction = greet() // greetFunction: Function1[String, Unit] = repl.MdocSession$App$$Lambda$7777/0x00000001022bf040@435acd30 Теперь можно вызвать greetFunction: greetFunction(\"Joe\") // Hello, Joe Доработка метода Метод greet() был бы более полезным, если бы была возможность задавать приветствие. Например, передать его в качестве параметра методу greet() и использовать внутри println: def greet(theGreeting: String): String =&gt; Unit = (name: String) =&gt; println(s\"$theGreeting, $name\") Теперь, при вызове этого метода, процесс становится более гибким, потому что приветствие можно изменить. Вот как это выглядит, когда создается функция из этого метода: val sayHello = greet(\"Hello\") // sayHello: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$7778/0x00000001022c0840@2f4ae6ef Выходные данные подписи типа показывают, что sayHello — это функция, которая принимает входной параметр String и возвращает Unit. Так что теперь, при передаче sayHello строки, печатается приветствие: sayHello(\"Joe\") // Hello, Joe Приветствие можно менять для создания новых функций: val sayCiao = greet(\"Ciao\") // sayCiao: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$7778/0x00000001022c0840@99aabbb val sayHola = greet(\"Hola\") // sayHola: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$7778/0x00000001022c0840@693f8336 sayCiao(\"Isabella\") // Ciao, Isabella sayHola(\"Carlos\") // Hola, Carlos Более реалистичный пример Этот метод может быть еще более полезным, когда возвращает одну из многих возможных функций, например, фабрику пользовательских функций. Например, представим, что необходимо написать метод, который возвращает функции, приветствующие людей на разных языках. Ограничим это функциями, которые приветствуют на английском или французском языках, в зависимости от параметра, переданного в метод. Созданный метод должен: принимать “желаемый язык” в качестве входных данных и возвращать функцию в качестве результата. Кроме того, поскольку эта функция печатает заданную строку, известно, что она имеет тип String =&gt; Unit. С помощью этой информации сигнатура метода должна выглядеть так: def createGreetingFunction(desiredLanguage: String): String =&gt; Unit = ??? Далее, поскольку возвращаемые функции, берут строку и печатают ее, можно прикинуть две анонимные функции для английского и французского языков: (name: String) =&gt; println(s\"Hello, $name\") (name: String) =&gt; println(s\"Bonjour, $name\") Для большей читабельности дадим этим анонимным функциям имена и назначим двум переменным: val englishGreeting = (name: String) =&gt; println(s\"Hello, $name\") val frenchGreeting = (name: String) =&gt; println(s\"Bonjour, $name\") Теперь все, что осталось, это вернуть englishGreeting, если desiredLanguage — английский, и вернуть frenchGreeting, если desiredLanguage — французский. Один из способов сделать это - pattern matching: def createGreetingFunction(desiredLanguage: String): String =&gt; Unit = val englishGreeting = (name: String) =&gt; println(s\"Hello, $name\") val frenchGreeting = (name: String) =&gt; println(s\"Bonjour, $name\") desiredLanguage match case \"english\" =&gt; englishGreeting case \"french\" =&gt; frenchGreeting Обратите внимание, что возврат значения функции из метода ничем не отличается от возврата строкового или целочисленного значения. Вот как createGreetingFunction создает функцию приветствия на французском языке: val greetInFrench = createGreetingFunction(\"french\") greetInFrench(\"Jonathan\") // Bonjour, Jonathan И вот как - на английском: val greetInEnglish = createGreetingFunction(\"english\") greetInEnglish(\"Joe\") // Hello, Joe References: Scala3 book"
    } ,      
    {
      "title": "Источники",
      "url": "/scalaworkbook/sources.html",
      "content": "Список источников Книги: Scala 3, official documentation Michael Pilquist, Rúnar Bjarnason, and Paul Chiusano - Functional Programming in Scala, Second Edition Статьи … Курсы …"
    } ,    
    {
      "title": "Структуры управления",
      "url": "/scalaworkbook/docs/structures.html",
      "content": "{{page.title}} В Scala есть все ожидаемые структуры управления, в том числе: if/then/else циклы for циклы while try/catch/finally Здесь также есть две другие мощные конструкции, присутствующие не во всех языках программирования: for выражения (также известные как for comprehensions) match выражения if/else Однострочное if выражение выглядит так: val x = 1 if x == 1 then println(x) // 1 Когда необходимо выполнить несколько строк кода после if, используется синтаксис: if x == 1 then println(\"x is 1, as you can see:\") println(x) // x is 1, as you can see: // 1 if/else синтаксис выглядит так: if x == 1 then println(\"x is 1, as you can see:\") println(x) else println(\"x was not 1\") // x is 1, as you can see: // 1 if/else if/else выглядит так же, как и в других языках: def detect(x: Int) = if x &lt; 0 then println(\"negative\") else if x == 0 then println(\"zero\") else println(\"positive\") detect(-1) // negative detect(0) // zero detect(1) // positive При желании можно дополнительно включить оператор end if в конце каждого выражения: if x == 1 then println(\"x is 1, as you can see:\") println(x) end if if/else выражение всегда возвращает результат Сравнения if/else образуют выражения - это означает, что они возвращают значение, которое можно присвоить переменной. Поэтому нет необходимости в специальном тернарном операторе. Пример: val minValue = if a &lt; b then a else b Можно использовать if/else выражение в качестве тела метода: def compare(a: Int, b: Int): Int = if a &lt; b then -1 else if a == b then 0 else 1 Как будет видно дальше, все структуры управления Scala можно использовать в качестве выражений. Программирование, ориентированное на выражения (expression-oriented programming или EOP) - стиль разработки, когда каждое написанное выражение возвращает значение. И наоборот, строки кода, которые не возвращают значения, называются операторами или утверждениями и используются для получения побочных эффектов. По мере погружения в Scala можно обнаружить, что пишется больше выражений и меньше утверждений. for loops В самом простом случае цикл for в Scala можно использовать для перебора элементов в коллекции. Например, имея последовательность целых чисел, можно перебрать ее элементы и вывести значения следующим образом: val ints = List(1, 2, 3, 4, 5) for i &lt;- ints do println(i) // 1 // 2 // 3 // 4 // 5 Код i &lt;- ints называется генератором. Если необходим многострочный блок кода после генератора for, используется следующий синтаксис: for i &lt;- ints do val x = i * 2 println(s\"i = $i, x = $x\") // i = 1, x = 2 // i = 2, x = 4 // i = 3, x = 6 // i = 4, x = 8 // i = 5, x = 10 Несколько генераторов В цикле for можно использовать несколько генераторов, например: for i &lt;- 1 to 2 j &lt;- 'a' to 'b' k &lt;- 1 to 10 by 5 do println(s\"i = $i, j = $j, k = $k\") // i = 1, j = a, k = 1 // i = 1, j = a, k = 6 // i = 1, j = b, k = 1 // i = 1, j = b, k = 6 // i = 2, j = a, k = 1 // i = 2, j = a, k = 6 // i = 2, j = b, k = 1 // i = 2, j = b, k = 6 Guards Циклы for также могут содержать условия, называемые guards: for i &lt;- 1 to 5 if i % 2 == 0 do println(i) // 2 // 4 Можно добавлять столько условий, сколько необходимо: for i &lt;- 1 to 10 if i &gt; 3 if i &lt; 6 if i % 2 == 0 do println(i) // 4 Использование for с Map-ами Циклы for можно использовать с Map-ами. Например, если есть карта ключ/значение: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AR\" -&gt; \"Arizona\" ) Можно обойти все пары ключ/значение так: for (abbrev, fullName) &lt;- states do println(s\"$abbrev: $fullName\") // AK: Alaska // AL: Alabama // AR: Arizona Когда цикл for перебирает Map, каждая пара ключ/значение привязывается к переменным abbrev и fullName. По мере выполнения цикла переменная abbrev принимает значение текущего ключа, а переменная fullName - соответствующему ключу значению. for expressions В предыдущих примерах все циклы for использовались для побочных эффектов, в частности, для вывода результата в STDOUT с помощью println. Важно знать, что for также можно использовать для выражений, возвращающих значения. Для этого for создается с ключевым словом yield вместо do и возвращаемым выражением, например: val list = for i &lt;- 10 to 12 yield i * 2 // list: IndexedSeq[Int] = Vector(20, 22, 24) После присваивания list содержит Vector с отображаемыми значениями. Вот как работает это выражение: Выражение for начинает перебирать значения в диапазоне (10, 11, 12). Сначала оно работает со значением 10, умножает его на 2, затем выдает результат - 20. Далее берет 11 — второе значение в диапазоне. Умножает его на 2, а затем выдает значение 22. Можно представить эти полученные значения как накопление во временном хранилище. Наконец, цикл берет число 12 из диапазона, умножает его на 2, получая число 24. Цикл завершается в этой точке и выдает конечный результат - (20, 22, 24). В данном случае показанное выражение for эквивалентно вызову метода map: val list = (10 to 12).map(i =&gt; i * 2) // list: IndexedSeq[Int] = Vector(20, 22, 24) Выражения for можно использовать всегда, когда нужно обойти все элементы в коллекции и применить алгоритм к этим элементам для создания нового списка. Вот пример, который показывает, как использовать блок кода после yield: val names = List(\"_olivia\", \"_walter\", \"_peter\") // names: List[String] = List(\"_olivia\", \"_walter\", \"_peter\") val capNames = for name &lt;- names yield val nameWithoutUnderscore = name.drop(1) val capName = nameWithoutUnderscore.capitalize capName // capNames: List[String] = List(\"Olivia\", \"Walter\", \"Peter\") Поскольку выражение for возвращает результат, его можно использовать в качестве тела метода. Пример: def between3and10(xs: List[Int]): List[Int] = for x &lt;- xs if x &gt;= 3 if x &lt;= 10 yield x between3and10(List(1, 3, 7, 11)) // res15: List[Int] = List(3, 7) while loops Цикл while имеет следующий синтаксис: var x = 1 // x: Int = 1 while x &lt; 3 do println(x) x += 1 // 1 // 2 В Scala не приветствуется использование изменяемых переменных var, поэтому следует избегать while. Аналогичный результат можно достигнуть используя вспомогательный метод: def loop(x: Int): Unit = if x &lt; 3 then println(x) loop(x + 1) loop(1) match expressions Сопоставление с образцом (pattern matching) является основой функциональных языков программирования, и Scala включает в себя pattern matching, обладающий множеством возможностей. В самом простом случае можно использовать выражение match, подобное оператору Java switch, сопоставляя на основе целочисленного значения. Как и предыдущие структуры, pattern matching - это действительно выражение, поскольку оно вычисляет результат: import scala.annotation.switch val i = 6 // i: Int = 6 val day = (i: @switch) match case 0 =&gt; \"Sunday\" case 1 =&gt; \"Monday\" case 2 =&gt; \"Tuesday\" case 3 =&gt; \"Wednesday\" case 4 =&gt; \"Thursday\" case 5 =&gt; \"Friday\" case 6 =&gt; \"Saturday\" case _ =&gt; \"invalid day\" // day: String = \"Saturday\" В примере выше переменная i сопоставляется с числом и если равна от 0 до 6, то в day возвращается день недели. Иной случай обозначается символом _ и если i не равен от 0 до 6, то возвращается значение invalid day. При написании простых выражений соответствия, подобных этому, рекомендуется использовать аннотацию @switch для переменной i. Эта аннотация содержит предупреждение во время компиляции, если switch не может быть скомпилирован в tableswitch или lookupswitch, которые лучше подходят с точки зрения производительности. Значение по умолчанию Когда нужно получить доступ к универсальному значению по умолчанию в pattern matching, достаточно указать имя переменной в левой части оператора case, а затем использовать это имя в правой части оператора: i match case 0 =&gt; println(\"1\") case 1 =&gt; println(\"2\") case what =&gt; println(s\"Получено значение: $what\" ) // Получено значение: 6 Переменной можно дать любое допустимое имя. Можно также использовать _ в качестве имени, чтобы игнорировать значение. Обработка нескольких возможных значений в одной строке В этом примере показано, как использовать несколько возможных совпадений с образцом в каждом операторе case: val evenOrOdd = i match case 1 | 3 | 5 | 7 | 9 =&gt; println(\"odd\") case 2 | 4 | 6 | 8 | 10 =&gt; println(\"even\") case _ =&gt; println(\"some other number\") // even Использование if в pattern matching В pattern matching можно использовать условия: i match case 1 =&gt; println(\"one, a lonely number\") case x if x == 2 || x == 3 =&gt; println(\"two’s company, three’s a crowd\") case x if x &gt; 3 =&gt; println(\"4+, that’s a party\") case _ =&gt; println(\"i’m guessing your number is zero or less\") // 4+, that’s a party Ещё пример: i match case a if 0 to 9 contains a =&gt; println(s\"0-9 range: $a\") case b if 10 to 19 contains b =&gt; println(s\"10-19 range: $b\") case c if 20 to 29 contains c =&gt; println(s\"20-29 range: $c\") case _ =&gt; println(\"Hmmm...\") // 0-9 range: 6 case classes и выражение match Также можно извлекать поля из case class-ов — и классов, которые имеют правильно написанные методы apply/unapply — и использовать их в pattern matching. Вот пример использования простого case class Person case class Person(name: String) def speak(p: Person) = p match case Person(name) if name == \"Fred\" =&gt; println(s\"$name says, Yubba dubba doo\") case Person(name) if name == \"Bam Bam\" =&gt; println(s\"$name says, Bam bam!\") case _ =&gt; println(\"Watch the Flintstones!\") speak(Person(\"Fred\")) // Fred says, Yubba dubba doo speak(Person(\"Bam Bam\")) // Bam Bam says, Bam bam! speak(Person(\"Wilma\")) // Watch the Flintstones! Использование выражения match в теле метода Поскольку выражения match возвращают значение, их можно использовать в теле метода. Этот метод принимает значение Matchable в качестве входного параметра и возвращает логическое значение на основе результата выражения соответствия: def isTruthy(a: Matchable) = a match case 0 | \"\" | false =&gt; false case _ =&gt; true Входной параметр a определяется как тип Matchable, который является родителем всех типов Scala. Для Matchable может выполняться сопоставление с образцом. Метод реализуется путем сопоставления входных данных, обеспечивая два случая: первый проверяет, является ли заданное значение целым числом 0, пустой строкой или false, и в этом случае возвращает false. Для иных случаев возвращается значение true. Эти примеры показывают, как работает метод: isTruthy(0) // res23: Boolean = false isTruthy(false) // res24: Boolean = false isTruthy(\"\") // res25: Boolean = false isTruthy(1) // res26: Boolean = true isTruthy(\" \") // res27: Boolean = true isTruthy(2F) // res28: Boolean = true Использование pattern matching в качестве тела метода очень распространено. Использование различных шаблонов в pattern matching Для выражения match можно использовать множество различных шаблонов. Например: Сравнение с константой (case 3 =&gt;) Сравнение с последовательностями (case List(els : _*) =&gt;) Сравнение с кортежами (case (x, y) =&gt;) Сравнение с конструктором класса (case Person(first, last) =&gt;) Сравнение по типу (case p: Person =&gt;) Все эти виды шаблонов показаны в следующем примере: def pattern(x: Matchable): String = x match // Сравнение с константой case 0 =&gt; \"ноль\" case true =&gt; \"true\" case \"hello\" =&gt; \"строка 'hello'\" case Nil =&gt; \"пустой List\" // Сравнение с последовательностями case List(0, _, _) =&gt; \"список из 3 элементов с 0 в качестве первого элемента\" case List(1, _*) =&gt; \"Непустой список, начинающийся с 1, и имеющий любой размер &gt; 0\" case Vector(1, _*) =&gt; \"Vector, начинающийся с 1, и имеющий любой размер &gt; 0\" // Сравнение с кортежами case (a, b) =&gt; s\"получено $a и $b\" case (a, b, c) =&gt; s\"получено $a, $b и $c\" // Сравнение с конструктором класса case Person(first, \"Alexander\") =&gt; s\"Alexander, first name = $first\" case Dog(\"Zeus\") =&gt; \"Собака с именем Zeus\" // Сравнение по типу case s: String =&gt; s\"получена строка: $s\" case i: Int =&gt; s\"получено число: $i\" case f: Float =&gt; s\"получено число с плавающей точкой: $f\" case a: Array[Int] =&gt; s\"массив чисел: ${a.mkString(\",\")}\" case as: Array[String] =&gt; s\"массив строк: ${as.mkString(\",\")}\" case d: Dog =&gt; s\"Экземпляр класса Dog: ${d.name}\" case list: List[?] =&gt; s\"получен List: $list\" case m: Map[?, ?] =&gt; m.toString // Сравнение по умолчанию case _ =&gt; \"Unknown\" try/catch/finally Как и в Java, в Scala есть конструкция try/catch/finally, позволяющая перехватывать исключения и управлять ими. Для обеспечения согласованности Scala использует тот же синтаксис, что и выражения match, и поддерживает pattern matching для различных возможных исключений. В следующем примере openAndReadAFile - это метод, который выполняет то, что следует из его названия: он открывает файл и считывает текст в нем, присваивая результат изменяемой переменной text: var text = \"\" try text = openAndReadAFile(filename) catch case fnf: FileNotFoundException =&gt; fnf.printStackTrace() case ioe: IOException =&gt; ioe.printStackTrace() finally println(\"Здесь необходимо закрыть ресурсы.\") Предполагая, что метод openAndReadAFile использует Java java.io.* классы для чтения файла и не перехватывает его исключения, попытка открыть и прочитать файл может привести как к FileNotFoundException, так и к IOException, и эти два исключения перехватываются в блоке catch этого примера. References: Scala3 book, taste Control Structures Scala3 book, Control Structures"
    } ,    
    {
      "title": "Инструменты",
      "url": "/scalaworkbook/docs/modeling/tools.html",
      "content": "{{page.title}} В Scala 3 есть множество различных конструкций для моделирования: Классы (Classes) Объекты (Objects) Сопутствующие объекты (Companion objects) Трейты (Traits) Абстрактные классы (Abstract classes) Перечисления (Enums) Case classes Case objects В этом разделе кратко представлена каждая из этих языковых конструкций. Classes Как и в других языках, класс в Scala — это шаблон для создания экземпляров объекта. Вот несколько примеров классов: class Person(var name: String, var vocation: String) class Book(var title: String, var author: String, var year: Int) class Movie(var name: String, var director: String, var year: Int) Эти примеры показывают, как в Scala объявляются классы. В примере выше все параметры классов определены как поля var, что означает, что они изменяемы. Если необходимо, чтобы они были неизменяемыми, можно определить их как val или использовать case class. Новый экземпляр класса создается следующим образом (без ключевого слова new, благодаря универсальным apply методам): val p = Person(\"Robert Allen Zimmerman\", \"Harmonica Player\") Если есть экземпляр класса, такого как p, то можно получить доступ к его полям, которые в этом примере являются параметрами конструктора: p.name // res0: String = \"Robert Allen Zimmerman\" p.vocation // res1: String = \"Harmonica Player\" Как уже упоминалось, все эти параметры были созданы как поля var, поэтому их можно изменять: p.name = \"Bob Dylan\" p.vocation = \"Musician\" Поля и методы Классы также могут иметь методы и дополнительные поля, не являющиеся частью конструкторов. Они определены в теле класса. Тело инициализируется как часть конструктора по умолчанию: class Person(var firstName: String, var lastName: String): println(\"initialization begins\") val fullName = s\"$firstName $lastName\" def printFullName: Unit = println(fullName) printFullName println(\"initialization ends\") Пример демонстрирует, как происходит инициализация класса: val john = Person(\"John\", \"Doe\") // initialization begins // John Doe // initialization ends // john: Person = repl.MdocSession$App4$Person@1db52cd3 john.printFullName // John Doe Классы также могут расширять trait-ы и абстрактные классы, которые будут рассмотрены в специальных разделах ниже. Параметры по умолчанию Параметры конструктора класса также могут иметь значения по умолчанию: class Socket(val timeout: Int = 5_000, val linger: Int = 5_000): override def toString = s\"timeout: $timeout, linger: $linger\" Отличительной особенностью этой функции является то, что она позволяет пользователям кода создавать классы различными способами, как если бы у класса были альтернативные конструкторы: Socket() // res6: Socket = timeout: 5000, linger: 5000 Socket(2_500) // res7: Socket = timeout: 2500, linger: 5000 Socket(10_000, 10_000) // res8: Socket = timeout: 10000, linger: 10000 Socket(timeout = 10_000) // res9: Socket = timeout: 10000, linger: 5000 Socket(linger = 10_000) // res10: Socket = timeout: 5000, linger: 10000 При создании нового экземпляра класса также можно использовать именованные параметры. Это приветствуется и особенно полезно, когда параметры имеют одинаковый тип: Socket(10_000, 10_001) // res11: Socket = timeout: 10000, linger: 10001 Socket(timeout = 10_000, linger = 10_001) // res12: Socket = timeout: 10000, linger: 10001 Socket(linger = 10_000, timeout = 10_001) // res13: Socket = timeout: 10001, linger: 10000 Вспомогательные конструкторы В классе можно определить несколько конструкторов. Например, предположим, что нужно определить три конструктора класса Student: с именем и государственным ID (1) с именем, государственным ID и датой подачи заявления (2) с именем, государственным ID и студенческим ID (3) Пример описания класса с тремя этими конструкторами: import java.time.* class Student(var name: String, var govtId: String): // [1] основной конструктор private var _applicationDate: Option[LocalDate] = None private var _studentId: Int = 0 def this(name: String, govtId: String, applicationDate: LocalDate) = // [2] конструктор с датой подачи заявления this(name, govtId) _applicationDate = Some(applicationDate) def this(name: String, govtId: String, studentId: Int) = // [3] конструктор со студенческим id this(name, govtId) _studentId = studentId Эти конструкторы могут быть вызваны следующим образом: Student(\"Mary\", \"123\") Student(\"Mary\", \"123\", LocalDate.now) Student(\"Mary\", \"123\", 456) Для возможности создания классов несколькими способами можно использовать как параметры по умолчанию, так и несколько конструкторов, как в примере выше. Objects В Scala ключевое слово object создает одноэлементный объект (singleton). Другими словами, объект определяет класс, который имеет ровно один экземпляр. Он инициализируется лениво, когда ссылаются на его элементы, аналогично lazy val. Объекты в Scala позволяют группировать методы и поля в одном пространстве имен, аналогично тому, как используются статические члены класса в Java, Javascript (ES6) или @staticmethod в Python. Объекты имеют несколько применений: Они используются для создания коллекций служебных методов. companion object - это объект, имеющий то же имя, что и класс, с которым он совместно использует файл. В этой ситуации класс называется companion class. Они используются для имплементации traits для создания модулей. Объявление объекта аналогично объявлению класса. Вот пример объекта StringUtils, который содержит набор методов для работы со строками: object StringUtils: def truncate(s: String, length: Int): String = s.take(length) def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\") def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty Поскольку StringUtils является одноэлементным, его методы могут вызываться непосредственно в объекте: StringUtils.truncate(\"Chuck Bartowski\", 5) // res17: String = \"Chuck\" Импорт в Scala очень гибкий и позволяет импортировать все члены объекта: import StringUtils.* truncate(\"Chuck Bartowski\", 5) // res18: String = \"Chuck\" containsWhitespace(\"Sarah Walker\") // res19: Boolean = true isNullOrEmpty(\"John Casey\") // res20: Boolean = false Можно импортировать только часть методов: import StringUtils.{truncate, containsWhitespace} truncate(\"Charles Carmichael\", 7) containsWhitespace(\"Captain Awesome\") isNullOrEmpty(\"Morgan Grimes\") // Not found: isNullOrEmpty (error) Объекты также могут иметь поля, к которым можно обратиться, как к статистическим методам: object MathConstants: val PI = 3.14159 val E = 2.71828 println(MathConstants.PI) // 3.14159 Companion objects Объект, который имеет то же имя, что и класс, и объявлен в том же файле, что и класс, называется “сопутствующим объектом” (companion object). Аналогично, соответствующий класс называется сопутствующим классом объекта (companion class). Сопутствующий класс или объект может получить доступ к закрытым членам своего “соседа”. Сопутствующие объекты используются для методов и значений, которые не являются специфичными для экземпляров сопутствующего класса. В следующем примере класс Circle содержит метод с именем area, который специфичен для каждого экземпляра. А его сопутствующий объект содержит метод с именем calculateArea, который (а) не специфичен для экземпляра и (б) доступен для каждого экземпляра: import scala.math.* case class Circle(radius: Double): import Circle.* def area: Double = calculateArea(radius) object Circle: private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0) val circle = Circle(5.0) circle.area // res22: Double = 78.53981633974483 В этом примере метод area, доступный для каждого экземпляра Circle, использует метод calculateArea, определенный в сопутствующем объекте. Кроме того, поскольку calculateArea является закрытым, к нему нельзя получить доступ с помощью другого кода, но, как показано, его могут видеть экземпляры класса Circle. Другие виды использования сопутствующих объектов Сопутствующие объекты могут использоваться для нескольких целей: их можно использовать для группировки “статических” методов в пространстве имен, как в примере выше эти методы могут быть public или private если бы calculateArea был public, к нему можно было бы получить доступ из любого места как Circle.calculateArea они могут содержать методы apply, которые — благодаря некоторому синтаксическому сахару — работают как фабричные методы для создания новых экземпляров они могут содержать методы unapply, которые используются для деконструкции объектов, например, с помощью pattern matching Вот краткий обзор того, как методы apply можно использовать в качестве фабричных методов для создания новых объектов: class Person: var name = \"\" var age = 0 override def toString = s\"$name is $age years old\" object Person: def apply(name: String): Person = // a one-arg factory method val p = new Person p.name = name p def apply(name: String, age: Int): Person = // a two-arg factory method val p = new Person p.name = name p.age = age p end Person val joe = Person(\"Joe\") // joe: Person = Joe is 0 years old val fred = Person(\"Fred\", 29) // fred: Person = Fred is 29 years old Traits Если провести аналогию с Java, то Scala trait похож на интерфейс в Java 8+. trait-ы могут содержать: абстрактные методы и поля конкретные методы и поля могут иметь параметры конструктора, как и классы В базовом использовании trait может использоваться как интерфейс, определяющий только абстрактные члены, которые будут реализованы другими классами: trait Employee: def id: Int def firstName: String def lastName: String traits также могут содержать определенные методы: trait HasLegs: def numLegs: Int def walk(): Unit def stop() = println(\"Stopped walking\") trait HasTail: def tailColor: String def wagTail() = println(\"Tail is wagging\") def stopTail() = println(\"Tail is stopped\") Классы и объекты могут расширять несколько traits, что позволяет с их помощью создавать небольшие модули. class IrishSetter(name: String) extends HasLegs, HasTail: val numLegs = 4 val tailColor = \"Red\" def walk() = println(\"I’m walking\") override def toString = s\"$name is a Dog\" В классе IrishSetter реализованы все абстрактные параметры и методы, поэтому можно создать его экземпляр: val d = IrishSetter(\"Big Red\") // d: IrishSetter = Big Red is a Dog Класс также может переопределять методы trait-ов при необходимости. Абстрактные классы Когда необходимо написать класс, но известно, что в нем будут абстрактные члены, можно создать либо trait, либо абстрактный класс. В большинстве случаев желательно использовать trait, но исторически сложилось так, что было две ситуации, когда предпочтительнее использование абстрактного класса: необходимо создать базовый класс, который принимает аргументы конструктора код будет вызван из Java-кода Базовый класс, который принимает аргументы конструктора До Scala 3, когда базовому классу нужно было принимать аргументы конструктора, он объявлялся как абстрактный класс: abstract class Pet(name: String): def greeting: String def age: Int override def toString = s\"My name is $name, I say $greeting, and I’m $age\" class Dog(name: String, age: Int) extends Pet(name): val greeting = \"Woof\" val d = Dog(\"Fido\", 1) Однако в Scala 3 trait-ы могут иметь параметры, так что теперь в той же ситуации можно использовать trait-ы: trait Pet(name: String): def greeting: String def age: Int override def toString = s\"My name is $name, I say $greeting, and I’m $age\" class Dog(name: String, var age: Int) extends Pet(name): val greeting = \"Woof\" val d = Dog(\"Fido\", 1) trait-ы более гибки в составлении, потому что можно смешивать (наследовать) несколько trait-ов, но только один класс. В большинстве случаев trait-ы следует предпочитать классам и абстрактным классам. Правило выбора состоит в том, чтобы использовать классы всякий раз, когда необходимо создавать экземпляры определенного типа, и trait-ы, когда желательно разложить и повторно использовать поведение. Enums Перечисление (an enumeration) может быть использовано для определения типа, состоящего из конечного набора именованных значений (в разделе, посвященном моделированию FP, будут показаны дополнительные возможности enums). Базовые перечисления используются для определения наборов констант, таких как месяцы в году, дни в неделе, направления, такие как север/юг/восток/запад, и многое другое. В качестве примера, рассмотрим перечисления, определяющие наборы атрибутов, связанных с пиццами: enum CrustSize: case Small, Medium, Large enum CrustType: case Thin, Thick, Regular enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions Для использования в коде enum необходимо импортировать: import CrustSize.* val currentCrustSize = Small Значения enum-ов можно сравнивать и использовать в матчинге: if (currentCrustSize == Small) println(\"If you buy a large pizza, you'll get a prize!\") // If you buy a large pizza, you'll get a prize! currentCrustSize match case Small =&gt; println(\"small\") case Medium =&gt; println(\"medium\") case Large =&gt; println(\"large\") // small Дополнительные возможности enums Перечисления могут иметь параметры конструктора: enum Color(val rgb: Int): case Red extends Color(0xFF0000) case Green extends Color(0x00FF00) case Blue extends Color(0x0000FF) а также содержать параметры и методы: enum Planet(mass: Double, radius: Double): private final val G = 6.67300E-11 def surfaceGravity = G * mass / (radius * radius) def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity case Mercury extends Planet(3.303e+23, 2.4397e6) case Earth extends Planet(5.976e+24, 6.37814e6) // more planets here ... Совместимость с Java enums Если необходимо использовать определенные в Scala перечисления в качестве перечислений Java, можно сделать это, расширив класс java.lang.Enum (который импортируется по умолчанию) следующим образом: enum Color extends Enum[Color] { case Red, Green, Blue } Параметр типа берется из определения Java enum и должен совпадать с типом перечисления. Нет необходимости предоставлять аргументы конструктора (как определено в документах Java API) для java.lang.Enum при его расширении — компилятор генерирует их автоматически. После определения Color его можно использовать так же, как если бы использовался Java enum: Color.Red.compareTo(Color.Green) Case classes Scala case class позволяет моделировать концепции с неизменяемыми структурами данных. case class обладает всеми функциональными возможностями класса, а также имеет встроенные дополнительные функции, которые делают их полезными для функционального программирования. case class имеет следующие эффекты и преимущества: Параметры конструктора case class по умолчанию являются общедоступными полями val, поэтому поля являются неизменяемыми, а методы доступа генерируются для каждого параметра. Генерируется метод unapply, который позволяет использовать case class в match выражениях. В классе создается метод copy, который позволяет создавать копии объекта без изменения исходного объекта. генерируются методы equals и hashCode для проверки структурного равенства, что позволяет использовать экземпляры case class в Map. генерируется метод toString, который полезен для отладки. Этот код демонстрирует несколько функций case class: case class Person(name: String, vocation: String) val person = Person(\"Reginald Kenneth Dwight\", \"Singer\") // person: Person = Person( // name = \"Reginald Kenneth Dwight\", // vocation = \"Singer\" // ) person.name // res27: String = \"Reginald Kenneth Dwight\" Необходимо помнить, что поля в case class-е неизменяемые: person.name = \"Joe\" // error: Reassignment to val name Остальные возможности продемонстрированы в коде: println(person) // Person(Reginald Kenneth Dwight,Singer) person match case Person(n, r) =&gt; println(\"name is \" + n) // name is Reginald Kenneth Dwight val elton = Person(\"Elton John\", \"Singer\") // elton: Person = Person(name = \"Elton John\", vocation = \"Singer\") person == elton // res30: Boolean = false case class BaseballTeam(name: String, lastWorldSeriesWin: Int) val cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908) // cubs1908: BaseballTeam = BaseballTeam( // name = \"Chicago Cubs\", // lastWorldSeriesWin = 1908 // ) val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016) // cubs2016: BaseballTeam = BaseballTeam( // name = \"Chicago Cubs\", // lastWorldSeriesWin = 2016 // ) Поддержка функционального программирования Как уже упоминалось ранее, case class-ы поддерживают функциональное программирование (FP): FP избегает изменения структур данных. Поэтому поля конструктора по умолчанию имеют значение val. Поскольку экземпляры case class не могут быть изменены, ими можно легко делиться, не опасаясь мутаций или условий гонки. вместо изменения экземпляра можно использовать метод copy в качестве шаблона для создания нового (потенциально измененного) экземпляра. Этот процесс можно назвать “обновлением по мере копирования”. наличие автоматически сгенерированного метода unapply позволяет использовать case class в сопоставлении шаблонов. Case objects Case object-ы относятся к объектам так же, как case class-ы относятся к классам: они предоставляют ряд автоматически генерируемых методов, чтобы сделать их более мощными. Case object-ы особенно полезны тогда, когда необходим одноэлементный объект, который нуждается в небольшой дополнительной функциональности, например, для использования с сопоставлением шаблонов в выражениях match. Case object-ы полезны, когда необходимо передавать неизменяемые сообщения. Например, представим проект музыкального проигрывателя, и создадим набор команд или сообщений: sealed trait Message case class PlaySong(name: String) extends Message case class IncreaseVolume(amount: Int) extends Message case class DecreaseVolume(amount: Int) extends Message case object StopPlaying extends Message Затем в других частях кода можно написать методы, которые используют сопоставление с образцом для обработки входящего сообщения (при условии, что методы playSong, changeVolume и stopPlayingSong определены где-то еще): def handleMessages(message: Message): Unit = message match case PlaySong(name) =&gt; playSong(name) case IncreaseVolume(amount) =&gt; changeVolume(amount) case DecreaseVolume(amount) =&gt; changeVolume(-amount) case StopPlaying =&gt; stopPlayingSong() References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Верхнеуровневые определения",
      "url": "/scalaworkbook/docs/toplevel-definitions.html",
      "content": "{{page.title}} В Scala 3 все виды определений могут быть записаны на “верхнем уровне” файлов исходного кода. Например, можно создать файл с именем MyCoolApp.scala и поместить в него данное содержимое: import scala.collection.mutable.ArrayBuffer enum Topping: case Cheese, Pepperoni, Mushrooms import Topping.* class Pizza: val toppings = ArrayBuffer[Topping]() val p = Pizza() extension (s: String) def capitalizeAllWords = s.split(\" \").map(_.capitalize).mkString(\" \") val hwUpper = \"hello, world\".capitalizeAllWords type Money = BigDecimal // по желанию дополнительные определения... @main def myApp = p.toppings += Cheese println(\"show me the code\".capitalizeAllWords) Как показано, нет необходимости помещать эти определения внутри пакета, класса или другой конструкции. Этот подход заменяет package objects из Scala 2. Но, будучи намного проще в использовании, они работают аналогично: когда вы помещаете определение в пакет с именем foo, вы можете получить доступ к этому определению во всех других пакетах в foo, например, в пакете foo.bar в этом примере: package foo { def double(i: Int) = i * 2 } package foo { package bar { @main def fooBarMain = println(s\"${double(1)}\") } } Фигурные скобки используются в этом примере, чтобы подчеркнуть вложенность пакета (они не обязательны для использования). Преимуществом такого подхода является то, что можно размещать определения в пакете с именем com.acme.myapp, а затем можно ссылаться на эти определения в com.acme.myapp.model, com.acme.myapp.controller и т.д. References: Scala3 book"
    } ,    
    {
      "title": "Переменные и типы данных",
      "url": "/scalaworkbook/docs/types.html",
      "content": "{{page.title}} В этом разделе представлен обзор переменных и типов данных Scala. Два вида переменных Переменная может быть неизменяемой или изменяемой: Тип Описание val Создает неизменяемую переменную, подобную final в Java. Согласно стандартам Scala и функционального программирования желательно всегда создавать переменную с помощью val. var Создает изменяемую переменную. Практически не используется в Scala, т.к. изменяемая переменная противоречит принципам функционального программирования. В примере показано, как создавать val и var переменные: val a = 0 // a: Int = 0 var b = 1 // b: Int = 1 Значение val не может быть переназначено. Если попытаться переназначить, то будет получена ошибка компиляции: val msg = \"Hello, world\" msg = \"Aloha\" // error: // Reassignment to val msg // msg = \"Aloha\" // ^^^^^^^^^^^^^ И наоборот, var может быть переназначен: var msg = \"Hello, world\" // msg: String = \"Hello, world\" msg = \"Aloha\" msg // res1: String = \"Aloha\" Объявление типов переменных Когда создается переменная, можно явно объявить ее тип или позволить определить тип компилятору: val x: Int = 1 val x = 1 Вторая форма известна как вывод типа (type inference), и это отличный способ помочь сохранить код кратким. Компилятор Scala обычно может определить тип данных, как показано в выходных данных этих примеров: val x = 1 // x: Int = 1 val s = \"a string\" // s: String = \"a string\" val nums = List(1, 2, 3) // nums: List[Int] = List(1, 2, 3) Всегда можно явно объявить тип переменной, но в простых примерах, подобных этим, в этом нет необходимости: val x: Int = 1 val s: String = \"a string\" val p: Person = Person(\"Richard\") В Scala все значения имеют тип, включая числовые значения и функции. Иерархия типов в Scala Приведенная ниже диаграмма иллюстрирует подмножество иерархии типов. Any - это супертип всех типов, также называемый the top type. Он определяет универсальные методы, такие как equals, hashCode и toString. У верхнего типа Any есть подтип Matchable, который используется для обозначения всех типов, для которых возможно выполнить pattern matching. Важно гарантировать вызов свойства “параметричность”, что вкратце означает, что мы не можем сопоставлять шаблоны для значений типа Any, а только для значений, которые являются подтипом Matchable. Справочная документация содержит более подробную информацию о Matchable. Matchable имеет два важных подтипа: AnyVal и AnyRef. AnyVal представляет типы значений. Существует несколько предопределенных типов значений, и они non-nullable: Double, Float, Long, Int, Short, Byte, Char, Unit и Boolean. Unit - это тип значения, который не несет никакой значимой информации. Существует ровно один экземпляр Unit - (). AnyRef представляет ссылочные типы. Все типы, не являющиеся значениями, определяются как ссылочные типы. Каждый пользовательский тип в Scala является подтипом AnyRef. Если Scala используется в контексте среды выполнения Java, AnyRef соответствует java.lang.Object. В языках, основанных на операторах, void используется для методов, которые ничего не возвращают. В Scala для методов, которые не имеют возвращаемого значения, такие как следующий метод, для той же цели используется Unit: def printIt(a: Any): Unit = println(a) Вот пример, демонстрирующий, что строки, целые числа, символы, логические значения и функции являются экземплярами Any и могут обрабатываться так же, как и любой другой объект: val list: List[Any] = List( \"a string\", 732, 'c', true, () =&gt; \"an anonymous function returning a string\" ) // list: List[Any] = List( // \"a string\", // 732, // 'c', // true, // &lt;function&gt; // ) Код определяет список значений типа List[Any]. Список инициализируется элементами различных типов, но каждый из них является экземпляром scala.Any, поэтому мы можем добавить их в список. Типы значений в Scala Как показано выше, числовые типы Scala расширяют AnyVal, и все они являются полноценными объектами. В этих примерах показано, как объявлять переменные этих числовых типов: val b: Byte = 1 val i: Int = 1 val l: Long = 1 val s: Short = 1 val d: Double = 2.0 val f: Float = 3.0 В первых четырех примерах, если явно не указать тип, то число 1 по умолчанию будет равно Int, поэтому, если нужен один из других типов данных — Byte, Long или Short — необходимо явно объявить эти типы. Числа с десятичной дробью (например, 2.0) по умолчанию будут иметь значение Double, поэтому, если необходим Float, нужно объявить Float явно, как показано в последнем примере. Поскольку Int и Double являются числовыми типами по умолчанию, их можно создавать без явного объявления типа данных: val i = 123 // i: Int = 123 val j = 1.0 // j: Double = 1.0 Также можно добавить символы L, D, and F (или их эквивалент в нижнем регистре) для того, чтобы задать Long, Double, или Float значения: val x = 1_000L // x: Long = 1000L val y = 2.2D // y: Double = 2.2 val z = 3.3F // z: Float = 3.3F В Scala также есть типы String (значение заключается в двойные кавычки или три двойных) и Char (значение заключается в одинарные кавычки): val name = \"Bill\" // name: String = \"Bill\" val c = 'a' // c: Char = 'a' BigInt и BigDecimal Для действительно больших чисел можно использовать типы BigInt и BigDecimal: var a = BigInt(1_234_567_890_987_654_321L) // a: BigInt = 1234567890987654321 var b = BigDecimal(123_456.789) // b: BigDecimal = 123456.789 Где Double и Float являются приблизительными десятичными числами, а BigDecimal используется для точной арифметики, например, при работе с валютой. BigInt и BigDecimal поддерживают все привычные числовые операторы: val b = BigInt(1234567890) // b: BigInt = 1234567890 val c = b + b // c: BigInt = 2469135780 val d = b * b // d: BigInt = 1524157875019052100 Строки Строки Scala похожи на строки Java, но у них есть две замечательные дополнительные функции: они поддерживают интерполяцию строк создавать многострочные строки очень просто String interpolation Интерполяция строк обеспечивает очень удобный способ использования переменных внутри строк. Например, учитывая эти три переменные: val firstName = \"John\" val mi = 'C' val lastName = \"Doe\" их комбинацию можно получить так: s\"Name: $firstName $mi $lastName\" // res4: String = \"Name: John C Doe\" Достаточно поставить перед строкой букву s, а затем - символ $ перед именами переменных внутри строки. Чтобы вставить произвольные выражения в строку, они заключаются в фигурные скобки: s\"2 + 2 = ${2 + 2}\" // res6: String = \"2 + 2 = 4\" val x = -1 // x: Int = -1 s\"x.abs = ${x.abs}\" // res7: String = \"x.abs = 1\" Символ s, помещенный перед строкой, является лишь одним из возможных интерполяторов. Если использовать f вместо s, можно использовать синтаксис форматирования в стиле printf в строке. Кроме того, интерполятор строк - это всего лишь специальный метод, и его можно определить самостоятельно. Например, некоторые библиотеки баз данных определяют очень мощный интерполятор sql. Multiline strings Многострочные строки создаются путем включения строки в три двойные кавычки: println(\"\"\"The essence of Scala: Fusion of functional and object-oriented programming in a typed setting.\"\"\") // The essence of Scala: // Fusion of functional and object-oriented // programming in a typed setting. Одним из недостатков базового подхода является то, что строки после первой имеют отступ. Если важно исключить отступ, можно поставить символ | перед всеми строками после первой и вызвать метод stripMargin после строки: println(\"\"\"The essence of Scala: |Fusion of functional and object-oriented |programming in a typed setting.\"\"\".stripMargin) // The essence of Scala: // Fusion of functional and object-oriented // programming in a typed setting. Теперь все строки выравниваются по левому краю. Здесь также можно использовать переменные внутри строки, добавив s перед первыми \"\"\". Приведение типов Типы значений могут быть приведены следующим образом: Например: val x: Int = 987654321 // x: Int = 987654321 val y: Long = x // y: Long = 987654321L val face: Char = '☺' // face: Char = '☺' val number: Int = face // number: Int = 9786 Приведение типов однонаправленное, следующий код не будет компилиться: val a: Long = 987654321 val b: Float = a val c: Long = b // val c: Long = b // ^ // Found: (b : Float) // Required: Long Неявное приведение типов в некоторых случаях помечено как deprecated и может быть запрещено в будущих версиях: val x: Long = 987654321 val y: Float = x // method long2float in object Long is deprecated since 2.13.1: Implicit conversion from Long to Float is dangerous because it loses precision. Write `.toFloat` instead. // val y: Float = x // ^ Nothing и null Nothing является подтипом всех типов, также называемым the bottom type. Нет значения, которое имело бы тип Nothing. Он обычно сигнализирует о прекращении, таком как thrown exception, выходе из программы или бесконечном цикле - т.е. это тип выражения, который не вычисляется до определенного значения, или метод, который нормально не возвращается. Null - это подтип всех ссылочных типов (т.е. любой подтип AnyRef). Он имеет единственное значение, определяемое ключевым словом null. В настоящее время применение null считается плохой практикой. Его следует использовать в основном для взаимодействия с другими языками JVM. Опция opt-in compiler изменяет статус Null, делая все ссылочные типы non-nullable. Этот параметр может стать значением по умолчанию в будущей версии Scala. Более подробная информация доступна по ссылке. В то же время null почти никогда не следует использовать в коде Scala. Альтернативы null обсуждаются в главе о функциональном программировании и в документации API. References: Scala3 book, Variables and Data Types Scala3 book, A First Look at Types"
    } ,    
    {
      "title": "Параметры функции",
      "url": "/scalaworkbook/docs/functions/variables.html",
      "content": "{{page.title}} Вернемся к примеру из предыдущего раздела: val doubledInts = ints.map((i: Int) =&gt; i * 2) Анонимной функцией является следующая часть: (i: Int) =&gt; i * 2 Причина, по которой она называется анонимной (anonymous), заключается в том, что она не присваивается переменной и, следовательно, не имеет имени. Однако анонимная функция, также известная как функциональный литерал (function literal), может быть назначена переменной для создания функциональной переменной (function variable): val double = (i: Int) =&gt; i * 2 Код выше создает функциональную переменную с именем double. В этом выражении исходный литерал функции находится справа от символа =, а новое имя переменной - слева. Список параметров функции подчеркнут: val double = (i: Int) =&gt; i * 2 -------- Как и список параметров для метода, список параметров функции означает, что функция double принимает один параметр с типом Int и именем i. Как можно видеть ниже, double имеет тип Int =&gt; Int, что означает, что он принимает один параметр Int и возвращает Int: val double = (i: Int) =&gt; i * 2 // double: Int =&gt; Int = ... Вызов метода Функция double может быть вызвана так: val x = double(2) // x: Int = 4 double также можно передать в вызов map: List(1, 2, 3).map(double) // res0: List[Int] = List(2, 4, 6) Кроме того, когда есть другие функции типа Int =&gt; Int: val triple = (i: Int) =&gt; i * 3 можно сохранить их в List или Map: val functionList: List[Int =&gt; Int] = List(double, triple) val functionMap: Map[String, Int =&gt; Int] = Map( \"2x\" -&gt; double, \"3x\" -&gt; triple ) functionList имеет тип List[Int =&gt; Int], functionMap - Map[String, Int =&gt; Int]. Ключевые моменты Ключевые моменты: чтобы создать функциональную переменную, достаточно присвоить имя переменной функциональному литералу когда есть функция, с ней можно обращаться как с любой другой переменной, то есть как со String или Int переменной А благодаря улучшенной функциональности Eta Expansion в Scala 3 с методами можно обращаться точно так же. References: Scala3 book Scala3 book, Function Variables"
    } ,    
    {
      "title": "Взаимодействие с Java",
      "url": "/scalaworkbook/docs/with_java.html",
      "content": "{{page.title}} ??? References: Scala3 book"
    } ,    
    {
      "title": "Написание своего собственного метода map",
      "url": "/scalaworkbook/docs/functions/write-map.html",
      "content": "{{page.title}} Теперь, когда известно, как писать собственные функции высшего порядка, рассмотрим более реальный пример. Представим, что у класса List нет метода map, и есть необходимость его написать. Первым шагом при создании функций является точное определение проблемы. Сосредоточившись только на List[Int], получаем: Необходимо написать метод map, который можно использовать для применения функции к каждому элементу в List[Int], возвращая преобразованные элементы в виде нового списка. Учитывая это утверждение, начнем писать сигнатуру метода. Во-первых, известно, что функция должна приниматься в качестве параметра, и эта функция должна преобразовать Int в какой-то общий тип A, поэтому получаем: def map(f: (Int) =&gt; A) Синтаксис использования универсального типа требует объявления этого символа типа перед списком параметров, поэтому добавляем объявление типа: def map[A](f: (Int) =&gt; A) Далее известно, что map также должен принимать List[Int]: def map[A](f: (Int) =&gt; A, xs: List[Int]) Наконец, также известно, что map возвращает преобразованный список, содержащий элементы универсального типа A: def map[A](f: (Int) =&gt; A, xs: List[Int]): List[A] = ??? Теперь все, что нужно сделать, это написать тело метода. Метод map применяет заданную им функцию к каждому элементу в заданном списке для создания нового преобразованного списка. Один из способов сделать это - использовать выражение for: for x &lt;- xs yield f(x) for выражения зачастую делают код удивительно простым, и в данном случае - это все тело метода. Объединив for с сигнатурой метода, получим автономный метод map, который работает с List[Int]: def map[A](f: (Int) =&gt; A, xs: List[Int]): List[A] = for x &lt;- xs yield f(x) Обобщим метод map Обратим внимание, что выражение for не делает ничего, что зависит от типа Int внутри списка. Следовательно, можно заменить Int в сигнатуре типа параметром универсального типа B: def map[A, B](f: (B) =&gt; A, xs: List[B]): List[A] = for x &lt;- xs yield f(x) Получился метод map, который работает с любым списком. Демонстрация работы получившегося map: def double(i : Int) = i * 2 def strlen(s: String) = s.length map(double, List(1, 2, 3)) // res0: List[Int] = List(2, 4, 6) map(strlen, List(\"a\", \"bb\", \"ccc\")) // res1: List[Int] = List(1, 2, 3) Теперь, когда рассмотрены методы, принимающие функции в качестве входных параметров, перейдем к методам, возвращающим функции. References: Scala3 book"
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
