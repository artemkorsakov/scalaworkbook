// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Контекстуальные абстракции",
      "url": "/scalaworkbook/docs/abstractions.html",
      "content": "Контекстуальные абстракции Background Implicits в Scala 2 были главной отличительной особенностью дизайна. Это основной способ абстрагироваться от контекста. Implicits представляют собой единую парадигму с большим разнообразием вариантов использования, среди которых: реализация type classes установление контекста внедрение зависимости (dependency injection) выражение возможностей вычисление новых типов и доказательство взаимосвязей между ними С тех пор этому примеру последовали другие языки, например, traits в Rust или protocol extensions в Swift. Предложения по дизайну также представлены для Kotlin в качестве разрешения зависимостей во время компиляции, для C# в качестве Shapes и Extensions или для F# в качестве Traits. Implicits также являются общей особенностью тех, кто доказывает теоремы, таких как Coq или Agda. Несмотря на то, что в этих проектах используется разная терминология, все они являются вариантами основной идеи вывода терминов (term inference): учитывая тип, компилятор синтезирует “канонический” термин, который имеет этот тип. Редизайн Scala 3 включает в себя переработку контекстных абстракций. Хотя эти концепции постепенно “открывались” в Scala 2, теперь они хорошо известны и понятны, и редизайн использует эти знания. Дизайн Scala 3 фокусируется на намерении, а не на механизме. Вместо того, чтобы предлагать одну очень мощную функцию имплицитов, Scala 3 предлагает несколько функций, ориентированных на варианты использования: Отвлечение контекстной информации. Предложения Using позволяют программистам абстрагироваться от информации, которая доступна в контексте вызова и должна передаваться неявно. В качестве улучшения по сравнению со Scala 2 подразумевается, что предложения using могут быть указаны по типу, освобождая сигнатуры функций от имен переменных, на которые никогда не ссылаются явно. Предоставление экземпляров Type-class. Given экземпляры позволяют программистам определять каноническое значение определенного типа. Это делает программирование с type-classes более простым без утечек деталей реализации. Ретроактивное продление классов. В Scala 2 методы расширения должны были кодироваться с использованием неявных преобразований или неявных классов. Напротив, в Scala 3 методы расширения теперь встроены непосредственно в язык, что приводит к улучшению сообщений об ошибках и улучшению вывода типов. Просмотр одного типа как другого. Неявное преобразование было переработано с нуля как экземпляры type-class Conversion. Контекстные абстракции более высокого порядка. Совершенно новая функция контекстных функций делает контекстные абстракции объектами первого класса. Они являются важным инструментом для авторов библиотек и позволяют выражать лаконичный DSL. Полезная обратная связь от компилятора. Если компилятор не может разрешить неявный параметр, теперь он предлагает предложения по импорту, которые могут решить проблему. Преимущества Эти изменения в Scala 3 обеспечивают лучшее разделение вывода терминов от остального языка: существует единственный способ определить данные существует единственный способ ввести неявные параметры и аргументы существует отдельный способ импорта данных, который не позволяет им прятаться в море обычного импорта существует единственный способ определить неявное преобразование, которое четко обозначено как таковое и не требует специального синтаксиса К преимуществам этих изменений относятся: новый дизайн позволяет избежать взаимодействия функций и делает язык более согласованным implicits становятся более легкими для изучения и более сложными для злоупотреблений значительно улучшается ясность 95% программ Scala, использующих implicits В этой главе в следующих разделах представлены многие из этих новых функций. References: Scala3 book, Contextual Abstractions"
    } ,    
    {
      "title": "Анонимные функции",
      "url": "/scalaworkbook/docs/functions/anonymous.html",
      "content": "Анонимные функции Анонимная функция, также называемая лямбда, представляет собой блок кода, который передается в качестве аргумента функции более высокого порядка. Википедия определяет анонимную функцию как “определение функции, не привязанное к идентификатору”. Например, возьмем коллекцию: val ints = List(1, 2, 3) Можно создать новый список, удвоив каждый элемент в целых числах, используя метод map класса List и свою пользовательскую анонимную функцию: val doubledInts = ints.map(_ * 2) // doubledInts: List[Int] = List(2, 4, 6) Как видно из комментария, doubleInts содержит список List(2, 4, 6). В этом примере анонимной функцией является часть кода: _ * 2. Это сокращенный способ сказать: “Умножить данный элемент на 2”. Более длинные формы Более длинными формами предыдущего примера являются следующие функции: val doubledInts = ints.map((i: Int) =&gt; i * 2) val doubledInts = ints.map((i) =&gt; i * 2) val doubledInts = ints.map(i =&gt; i * 2) Все эти строки имеют одно и то же значение: удваивайте каждый элемент в ints, чтобы создать новый список, doubledInts. Сокращение анонимных функций Если необходимо явно указать анонимную функцию, можно использовать эту длинную форму: val doubledInts = ints.map((i: Int) =&gt; i * 2) Анонимная функция в этом выражении такова: (i: Int) =&gt; i * 2 Если незнаком данный синтаксис, то можно воспринимать символ =&gt; как преобразователь, потому что выражение преобразует список параметров в левой части символа (переменная Int с именем i) в новый результат, используя алгоритм справа от символа =&gt; (в данном случае выражение, которое удваивает значение Int). Сокращение выражения Эту длинную форму можно сократить: val doubledInts = ints.map((i: Int) =&gt; i * 2) Поскольку компилятор Scala из данных в ints может сделать вывод, что i является Int, объявление Int можно удалить: val doubledInts = ints.map((i) =&gt; i * 2) Поскольку аргумент всего один, скобки вокруг параметра i можно не указывать: val doubledInts = ints.map(i =&gt; i * 2) Поскольку Scala позволяет использовать символ _ вместо имени переменной, если в функции только один параметр, код можно упростить еще больше: val doubledInts = ints.map(_ * 2) Ещё короче В других примерах можно еще больше упростить анонимные функции. Например, начиная с самой явной формы, можно распечатать каждый элемент в целых числах, используя эту анонимную функцию с методом foreach класса List: ints.foreach((i: Int) =&gt; println(i)) Как и раньше, объявление Int не требуется, а поскольку аргумент всего один, скобки вокруг i не нужны: ints.foreach(i =&gt; println(i)) Поскольку i используется в теле функции только один раз, выражение можно еще больше упростить с помощью символа _: ints.foreach(println(_)) Наконец, если анонимная функция состоит из одного вызова метода с одним аргументом, нет необходимости явно называть и указывать аргумент, можно написать только имя метода (здесь, println): ints.foreach(println) References: Scala3 book Scala3 book, Anonymous Functions"
    } ,    
    {
      "title": "Контекстные привязки",
      "url": "/scalaworkbook/docs/abstractions/ca-context-bounds.html",
      "content": "Контекстные привязки Во многих ситуациях необязательно указывать имя параметра контекста явно, поскольку оно используется компилятором только в синтезированных аргументах для других параметров контекста. В таких случаях имя параметра определять не нужно и можно просто указать его тип. Background Например, этот метод maximum принимает параметр контекста типа Ord только для того, чтобы передать его в качестве аргумента функции max: def maximum[A](xs: List[A])(using ord: Ord[A]): A = xs.reduceLeft(max(ord)) В этом коде имя параметра ord на самом деле не требуется; его можно передать в качестве предполагаемого аргумента в max, поэтому достаточно просто указать, что maximum использует тип Ord[A], не называя его: def maximum[A](xs: List[A])(using Ord[A]): A = xs.reduceLeft(max) Контекстные привязки Учитывая вышесказанное, контекстная привязка (context bound) — это сокращенный синтаксис для выражения шаблона “параметр контекста, который зависит от параметра типа”. Используя привязку к контексту, метод maximum можно записать следующим образом: def maximum[A: Ord](xs: List[A]): A = xs.reduceLeft(max) Привязка типа : Ord к параметру типа A метода или класса указывает параметр контекста Ord[A]. Дополнительные сведения о границах контекста см. в ответе “Что такое границы контекста?”. References: Scala3 book"
    } ,    
    {
      "title": "Методы расширения",
      "url": "/scalaworkbook/docs/abstractions/ca-extension-methods.html",
      "content": "Методы расширения Методы расширения (extension methods) позволяют добавлять методы к типу после его определения, т.е. позволяют добавлять новые методы в закрытые классы. Например, предположим, что кто-то другой создал класс Circle: case class Circle(x: Double, y: Double, radius: Double) Теперь представим, что необходим метод circumference, но нет возможности изменить исходный код Circle. До того как концепция вывода терминов была введена в языки программирования, единственное, что можно было сделать, это написать метод в отдельном классе или объекте, подобном этому: object CircleHelpers: def circumference(c: Circle): Double = c.radius * math.Pi * 2 Затем этот метод можно было использовать следующим образом: val aCircle = Circle(2, 3, 5) CircleHelpers.circumference(aCircle) Методы расширения позволяют создать метод circumference для работы с экземплярами Circle: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 В этом коде: Circle — это тип, к которому будет добавлен метод расширения circumference Синтаксис c: Circle позволяет ссылаться на переменную c в методах расширения Затем в коде метод circumference можно использовать так же, как если бы он был изначально определен в классе Circle: aCircle.circumference Импорт методов расширения Представим, что circumference определен в пакете lib - его можно импортировать с помощью import lib.circumference aCircle.circumference Если импорт отсутствует, то компилятор выводит подробное сообщение об ошибке, подсказывая возможный импорт, например так: value circumference is not a member of Circle, but could be made available as an extension method. The following import might fix the problem: import lib.circumference Обсуждение Ключевое слово extension объявляет о намерении определить один или несколько методов расширения для типа, заключенного в круглые скобки. Чтобы определить для типа несколько методов расширения, используется следующий синтаксис: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 def diameter: Double = c.radius * 2 def area: Double = math.Pi * c.radius * c.radius References: Scala3 book"
    } ,    
    {
      "title": "Given imports",
      "url": "/scalaworkbook/docs/abstractions/ca-given-imports.html",
      "content": "Given imports Для большей ясности, откуда берутся данные в текущей области видимости, для импорта экземпляров given используется специальная форма оператора import. Базовая форма показана в этом примере: object A: class TC given tc: TC = ??? def f(using TC) = ??? object B: import A.* // импорт всех non-given членов import A.given // импорт given членов В этом коде предложение import A.* объекта B импортирует все элементы A, кроме given экземпляра tc. И наоборот, второй импорт, import A.given, импортирует только экземпляр given. Два предложения импорта также могут быть объединены в одно: object B: import A.{given, *} Обсуждение Селектор с подстановочным знаком * помещает в область видимости все определения, кроме givens или расширений, тогда как селектор given помещает в область видимости все данные, включая те, которые являются результатом расширений. Эти правила имеют два основных преимущества: понятнее, откуда берутся данные в текущей области видимости. В частности, невозможно скрыть импортированные givens в длинном списке других импортов. есть возможность импортировать все given, не импортируя ничего другого. Это важно, потому что givens могут быть анонимными, поэтому обычное использование именованного импорта нецелесообразно. Дополнительные примеры синтаксиса “импорт given” показаны в главе “Упаковка и импорт”. References: Scala3 book"
    } ,    
    {
      "title": "Given и Using",
      "url": "/scalaworkbook/docs/abstractions/ca-given-using.html",
      "content": "Given и Using Scala 3 предлагает две важные функции для контекстной абстракции: Using предложения позволяют указать параметры, которые на месте вызова могут быть опущены программистом и должны автоматически предоставляться контекстом Экземпляры given позволяют определять термины, которые компилятор Scala может использовать для заполнения отсутствующих аргументов Using предложения При проектировании системы часто необходимо предоставлять различным компонентам контекстную информацию, такую как конфигурация или настройки. Одним из распространенных способов добиться этого является передача конфигурации в качестве дополнительного аргумента метода. В следующем примере определяется case класс Config для моделирования некоторой конфигурации веб-сайта и передачи ее в различные методы: case class Config(port: Int, baseUrl: String) def renderWebsite(path: String, c: Config): String = \"&lt;html&gt;\" + renderWidget(List(\"cart\"), c) + \"&lt;/html&gt;\" def renderWidget(items: List[String], c: Config): String = ??? val config = Config(8080, \"docs.scala-lang.org\") renderWebsite(\"/home\", config) Предположим, что конфигурация не меняется на протяжении большей части кодовой базы. Передача c для каждого вызова метода (например, renderWidget) становится очень утомительной и затрудняет чтение программы, поскольку нужно игнорировать аргумент c. Использование using для обозначения параметров как контекстных В Scala 3 некоторые параметры можно отмечать как контекстные. def renderWebsite(path: String)(using c: Config): String = \"&lt;html&gt;\" + renderWidget(List(\"cart\")) + \"&lt;/html&gt;\" // ^^^ // аргумент 'c' теперь можно не указывать def renderWidget(items: List[String])(using c: Config): String = ??? Начав секцию параметров с ключевого слова using, мы сообщаем компилятору Scala, что на месте вызова он должен автоматически найти аргумент с правильным типом. Таким образом, компилятор Scala выполняет вывод терминов (term inference). В вызове renderWidget(List(\"cart\")) компилятор Scala увидит, что в области действия (c) есть терм типа Config, и автоматически предоставит его в renderWidget. Таким образом, программа эквивалентна приведенной выше. На самом деле, поскольку больше не нужно ссылаться на c в последней реализации renderWebsite, можно даже не указывать его имя в подписи: // не нужно придумывать имя параметра // vvvvvvvvvvvv def renderWebsite(path: String)(using Config): String = \"&lt;html&gt;\" + renderWidget(List(\"cart\")) + \"&lt;/html&gt;\" Явное предоставление контекстных аргументов Было показано, как абстрагироваться от контекстных параметров и что компилятор Scala может автоматически предоставлять аргументы. Но подобно тому, как задается раздел параметров с using, контекстные аргументы можно указать явно с помощью того же using: renderWebsite(\"/home\")(using config) Явное предоставление контекстных параметров может быть полезно, если в области видимости доступны несколько разных подходящих по типу значений, и мы хотим убедиться, что в функцию передается правильное значение. Для всех остальных случаев, как будет видно в следующем разделе, есть еще один способ ввести контекстуальные значения в область видимости. Экземпляры given Было показано, что можно явно передавать аргументы в качестве контекстных параметров, пометив раздел аргументов вызова с помощью using. Однако, если есть единственное каноническое значение для определенного типа, существует другой предпочтительный способ сделать его доступным для компилятора Scala: пометив его как given. val config = Config(8080, \"docs.scala-lang.org\") // это тип, который мы хотим предоставить // в качестве канонического значения для // vvvvvv given Config = config // ^^^^^^ // это значение, которое выведет компилятор Scala // в качестве аргумента для контекстного параметра типа Config В приведенном выше примере указано, что всякий раз, когда контекстный параметр типа Config опускается в текущей области видимости, компилятор должен выводить config в качестве аргумента. Определив given для Config, можно просто вызвать renderWebsite: renderWebsite(\"/home\") // ^^^^^ // аргумент не нужен References: Scala3 book"
    } ,    
    {
      "title": "Implicit conversions",
      "url": "/scalaworkbook/docs/abstractions/ca-implicit-conversions.html",
      "content": "Implicit conversions Неявные преобразования определяются экземплярами given класса scala.Conversion. Например, без учета возможных ошибок преобразования, этот код определяет неявное преобразование из String в Int: given Conversion[String, Int] with def apply(s: String): Int = Integer.parseInt(s) Используя псевдоним, это можно выразить более кратко: given Conversion[String, Int] = Integer.parseInt(_) Используя любое из этих преобразований, теперь String можно использовать в местах, где ожидается Int: import scala.language.implicitConversions // метод, который ожидает Int def plus1(i: Int) = i + 1 // можно передать строку, которая преобразуется в Int plus1(\"1\") Обратите внимание на предложение import scala.language.implicitConversions в начале, чтобы разрешить неявные преобразования в файле. Обсуждение Пакет Predef содержит преобразования «автоматического упаковывания», которые сопоставляют примитивные числовые типы с подклассами java.lang.Number. Например, преобразование из Int в java.lang.Integer можно определить следующим образом: given int2Integer: Conversion[Int, java.lang.Integer] = java.lang.Integer.valueOf(_) References: Scala3 book"
    } ,    
    {
      "title": "Мультиуниверсальное равенство",
      "url": "/scalaworkbook/docs/abstractions/ca-multiversal-equality.html",
      "content": "Мультиуниверсальное равенство Раньше в Scala было универсальное равенство (universal equality): два значения любых типов можно было сравнивать друг с другом с помощью == и !=. Это произошло из-за того факта, что == и != реализованы в терминах метода equals Java, который также может сравнивать значения любых двух ссылочных типов. Всеобщее равенство удобно, но оно также опасно, поскольку подрывает безопасность типов. Например, предположим, что после некоторого рефакторинга осталась ошибочная программа, в которой значение y имеет тип S вместо правильного типа T: val x = ... // типа T val y = ... // типа S, но должно быть типа T x == y // проверки типов всегда будут выдавать false Если y сравнивается с другими значениями типа T, программа все равно будет проверять тип, так как значения всех типов можно сравнивать друг с другом. Но это, вероятно, даст неожиданные результаты и завершится ошибкой во время выполнения. Типобезопасный язык программирования может работать лучше, а мультиуниверсальное равенство — это дополнительный способ сделать универсальное равенство более безопасным. Он использует класс двоичного типа CanEqual, чтобы указать, что значения двух заданных типов можно сравнивать друг с другом. Разрешение сравнения экземпляров класса По умолчанию сравнение на равенство можно создать следующим образом: case class Cat(name: String) case class Dog(name: String) val d = Dog(\"Fido\") val c = Cat(\"Morris\") d == c // false, но он компилируется Но в Scala 3 такие сравнения можно отключить. При (а) импорте scala.language.strictEquality или (б) использовании флага компилятора -language:strictEquality это сравнение больше не компилируется: import scala.language.strictEquality val rover = Dog(\"Rover\") val fido = Dog(\"Fido\") println(rover == fido) // compiler error // compiler error message: // Values of types Dog and Dog cannot be compared with == or != Включение сравнений Есть два способа включить сравнение с помощью класса типов CanEqual. Для простых случаев класс может выводиться (derive) от класса CanEqual: // Способ 1 case class Dog(name: String) derives CanEqual Также можно использовать следующий синтаксис: // Способ 2 case class Dog(name: String) given CanEqual[Dog, Dog] = CanEqual.derived Любой из этих двух подходов позволяет сравнивать экземпляры Dog друг с другом. Более реалистичный пример В более реалистичном примере представим, что есть книжный интернет-магазин и мы хотим разрешить или запретить сравнение бумажных, печатных и аудиокниг. В Scala 3 для начала необходимо включить мультиуниверсальное равенство: // [1] добавить этот импорт или command line flag: -language:strictEquality import scala.language.strictEquality Затем создать объекты домена: // [2] создание иерархии классов trait Book: def author: String def title: String def year: Int case class PrintedBook( author: String, title: String, year: Int, pages: Int ) extends Book case class AudioBook( author: String, title: String, year: Int, lengthInMinutes: Int ) extends Book Наконец, используем CanEqual, чтобы определить, какие сравнения необходимо разрешить: // [3] создайте экземпляры класса типов, чтобы определить разрешенные сравнения. // разрешено `PrintedBook == PrintedBook` // разрешено `AudioBook == AudioBook` given CanEqual[PrintedBook, PrintedBook] = CanEqual.derived given CanEqual[AudioBook, AudioBook] = CanEqual.derived // [4a] сравнение двух печатных книг разрешено val p1 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328) val p2 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328) println(p1 == p2) // true // [4b] нельзя сравнивать печатную книгу и аудиокнигу val pBook = PrintedBook(\"1984\", \"George Orwell\", 1961, 328) val aBook = AudioBook(\"1984\", \"George Orwell\", 2006, 682) println(pBook == aBook) // compiler error Последняя строка кода приводит к следующему сообщению компилятора об ошибке: Values of types PrintedBook and AudioBook cannot be compared with == or != Вот как мультиуниверсальное равенство отлавливает недопустимые сравнения типов во время компиляции. Включение «PrintedBook == AudioBook» Если есть необходимость разрешить сравнение PrintedBook с AudioBook, то достаточно создать следующие два дополнительных сравнения равенства: // разрешить `PrintedBook == AudioBook` и `AudioBook == PrintedBook` given CanEqual[PrintedBook, AudioBook] = CanEqual.derived given CanEqual[AudioBook, PrintedBook] = CanEqual.derived Теперь можно сравнивать PrintedBook с AudioBook без ошибки компилятора: println(pBook == aBook) // false println(aBook == pBook) // false Внедрение «equals» Хотя эти сравнения теперь разрешены, они всегда будут ложными, потому что их методы equals не знают, как проводить подобные сравнения. Чтобы доработать сравнение, можно переопределить методы equals для каждого класса. Например, если переопределить метод equals для AudioBook: case class AudioBook( author: String, title: String, year: Int, lengthInMinutes: Int ) extends Book: // переопределить, чтобы разрешить сравнение AudioBook с PrintedBook override def equals(that: Any): Boolean = that match case a: AudioBook =&gt; if this.author == a.author &amp;&amp; this.title == a.title &amp;&amp; this.year == a.year &amp;&amp; this.lengthInMinutes == a.lengthInMinutes then true else false case p: PrintedBook =&gt; if this.author == p.author &amp;&amp; this.title == p.title then true else false case _ =&gt; false Теперь можно сравнить AudioBook с PrintedBook: println(aBook == pBook) // true (работает из-за переопределенного `equals` в `AudioBook`) println(pBook == aBook) // false Книга PrintedBook не имеет метода equals, поэтому второе сравнение возвращает false. Чтобы включить это сравнение, достаточно переопределить метод equals в PrintedBook. References: Scala3 book"
    } ,    
    {
      "title": "Имплементация type классов",
      "url": "/scalaworkbook/docs/abstractions/ca-type-classes.html",
      "content": "Имплементация type классов Класс типов — это абстрактный параметризованный тип, который позволяет добавлять новое поведение к любому закрытому типу данных без использования подтипов. Это полезно во многих случаях, например: выражение того, как тип, которым вы не владеете, например, из стандартной или сторонней библиотеки, соответствует такому поведению добавление поведения к нескольким типам без введения отношений подтипов между этими типами В Scala 3 классы типов — это просто trait-ы с одним или несколькими параметрами типа, реализации которых предоставляются заданными экземплярами. Пример Рассмотрим Show - хорошо известный класс типов в Haskell. Следующий код показывает один из способов его реализации в Scala 3. Предположим, что классы Scala не имеют метода toString. Можно определить класс Show, чтобы добавить это поведение к любому классу, который необходимо преобразовать в пользовательскую строку. Класс типа Первым шагом в создании класса типа является объявление параметризованного trait, который имеет один или несколько абстрактных методов. Поскольку у Showable есть только один метод с именем show, он написан так: // Класс типа trait Showable[A]: extension(a: A) def show: String В Scala 3 это способ сказать, что любой тип, который реализует этот trait, должен определять, как работает метод show. Обратите внимание, что синтаксис очень близок к обычному trait: // a trait trait Show: def show: String Следует отметить несколько важных моментов: классы типов, такие как Showable, принимают параметр типа A, чтобы установить, для какого типа предоставляется реализация show; Напротив, стандартные trait, такие, как Show, этого не делают. чтобы добавить функциональность show к определенному типу A, стандартный trait требует, чтобы A расширял Show, в то время как для классов типов требуется реализация Showable[A]. чтобы разрешить одинаковый синтаксис вызова метода в обоих Showable, который имитирует один из Show, Showable.show определяется как метод расширения. Реализация конкретных экземпляров Следующий шаг — определить, для каких классов должен работать Showable, а затем реализовать это поведение. Например, чтобы реализовать Showable для данного класса Person: case class Person(firstName: String, lastName: String) нужно определить given значение для Showable[Person]. Этот код предоставляет конкретный экземпляр Showable для класса Person: given Showable[Person] with extension(p: Person) def show: String = s\"${p.firstName} ${p.lastName}\" Как показано, Showable[Person] определяет метод расширения класса Person и использует ссылку p внутри тела метода show. Использование класса типов Этот класс типа можно использовать следующим образом: val person = Person(\"John\", \"Doe\") // person: Person = Person(firstName = \"John\", lastName = \"Doe\") println(person.show) // John Doe Опять же, если бы в Scala не было метода toString, доступного для каждого класса, можно было бы использовать эту технику, чтобы добавить поведение Showable к любому классу, который необходимо преобразовать в String. Написание методов, использующих класс типов Как и в случае с наследованием, можно определить методы, использующие Showable в качестве параметра типа: def showAll[S: Showable](xs: List[S]): Unit = xs.foreach(x =&gt; println(x.show)) showAll(List(Person(\"Jane\", \"Jackson\"), Person(\"Mary\", \"Jameson\"))) // Jane Jackson // Mary Jameson Класс типов с несколькими методами Если необходимо создать класс типов с несколькими методами, исходный синтаксис выглядит следующим образом: trait HasLegs[A]: extension (a: A) def walk(): Unit def run(): Unit Реальный пример Реальный пример того, как классы типов используются в Scala 3, см. в обсуждении CanEqual в разделе Multiversal Equality. References: Scala3 book"
    } ,    
    {
      "title": "Типы коллекций",
      "url": "/scalaworkbook/docs/collections/classes.html",
      "content": "Типы коллекций В этом разделе продемонстрированы наиболее распространенные типы коллекций и их методы. В конце этого раздела для получения более подробной информации представлены дополнительные ссылки для более глубокого изучения коллекций. Три основные категории коллекций Для коллекций Scala можно выделить три основные категории: Последовательности (Sequences/Seq) представляют собой последовательный набор элементов и могут быть индексированными (как массив) или линейными (как связанный список) Карты (Maps) содержат набор пар ключ/значение, например Java Map, Python dictionary или Ruby Hash Множества (Sets) — это неупорядоченный набор уникальных элементов Все они являются базовыми типами и имеют подтипы для конкретных целей, таких как параллелизм (concurrency), кэширование (caching) и потоковая передача (streaming). В дополнение к этим трем основным категориям существуют и другие полезные типы коллекций, включая диапазоны (ranges), стеки (stacks) и очереди (queues). Иерархия коллекций В качестве краткого обзора следующие три рисунка показывают иерархию классов и трейтов в коллекциях Scala. На первом рисунке показаны типы коллекций в пакете scala.collection. Все это высокоуровневые абстрактные классы или трейты, которые обычно имеют неизменяемые и изменяемые реализации. На этом рисунке показаны все коллекции в пакете scala.collection.immutable: А на этом рисунке показаны все коллекции в пакете scala.collection.mutable: В следующих разделах представлены некоторые из распространенных типов. Общие коллекции Основные коллекции, используемые чаще всего: Тип коллекции Неизменяемая Изменяемая Описание List ✓   Линейная неизменяемая последовательность (связный список) Vector ✓   Индексированная неизменяемая последовательность LazyList ✓   Ленивый неизменяемый связанный список, элементы которого вычисляются только тогда, когда они необходимы; подходит для больших или бесконечных последовательностей. ArrayBuffer   ✓ Подходящий тип для изменяемой индексированной последовательности ListBuffer   ✓ Используется, когда вам нужен изменяемый список; обычно преобразуется в List Map ✓ ✓ Итерируемая коллекция, состоящая из пар ключей и значений Set ✓ ✓ Итерируемая коллекция без повторяющихся элементов Как показано, Map и Set бывают как неизменяемыми, так и изменяемыми. Основы каждого типа демонстрируются в следующих разделах. В Scala буфер, такой как ArrayBuffer или ListBuffer, представляет собой последовательность, которая может увеличиваться и уменьшаться. Примечание о неизменяемых коллекциях В последующих разделах всякий раз, когда используется слово immutable, можно с уверенностью сказать, что тип предназначен для использования в стиле функционального программирования (ФП). С помощью таких типов коллекция не меняется, а при вызове функциональных методов возвращается новый результат - новая коллекция. Выбор последовательности При выборе последовательности нужно руководствоваться двумя основными вопросами: должна ли последовательность индексироваться (как массив), обеспечивая быстрый доступ к любому элементу, или она должна быть реализована как линейный связанный список? необходима изменяемая или неизменяемая коллекция? Рекомендуемые универсальные последовательности: Тип \\ Категория Неизменяемая Изменяемая индексируемая Vector ArrayBuffer линейный связанный список List ListBuffer Например, если нужна неизменяемая индексированная коллекция, в общем случае следует использовать Vector. И наоборот, если нужна изменяемая индексированная коллекция, используйте ArrayBuffer. List и Vector часто используются при написании кода в функциональном стиле. ArrayBuffer обычно используется при написании кода в императивном стиле. ListBuffer используется, когда стили смешиваются, например, при создании списка. Следующие несколько разделов кратко демонстрируют типы List, Vector и ArrayBuffer. List List представляет собой линейную неизменяемую последовательность. Каждый раз, когда в список добавляются или удаляются элементы, по сути создается новый список из существующего. Создание списка Список можно создать различными способами: val ints = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) val names = List(\"Joel\", \"Chris\", \"Ed\") // names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") val namesAgain = \"Joel\" :: \"Chris\" :: \"Ed\" :: Nil // namesAgain: List[String] = List(\"Joel\", \"Chris\", \"Ed\") При желании тип списка можно объявить, хотя обычно в этом нет необходимости: val ints: List[Int] = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) val names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") // names: List[String] = List(\"Joel\", \"Chris\", \"Ed\") Одно исключение — когда в коллекции смешанные типы; в этом случае тип желательно указывать явно: val things: List[Any] = List(1, \"two\", 3.0) // things: List[Any] = List(1, \"two\", 3.0) Добавление элементов в список Поскольку список неизменяем, в него нельзя добавлять новые элементы. Вместо этого создается новый список с добавленными к существующему списку элементами. Например, учитывая этот список: val a = List(1, 2, 3) Для добавления одного элемента используется метод ::, для добавления нескольких — :::, как показано здесь: val b = 0 :: a // b: List[Int] = List(0, 1, 2, 3) val c = List(-1, 0) ::: a // c: List[Int] = List(-1, 0, 1, 2, 3) Также можно добавить элементы в конец списка, но, поскольку список является односвязным, следует добавлять к нему элементы только в начало; добавление элементов в конец списка — относительно медленная операция, особенно при работе с большими последовательностями. Если необходимо добавлять к неизменяемой последовательности элементы в начало и конец, используйте Vector. Поскольку List является связанным списком, крайне нежелательно пытаться получить доступ к элементам больших списков по значению их индекса. Например, если есть List с миллионом элементов, доступ к такому элементу, как myList(999_999), займет относительно много времени, потому что этот запрос должен пройти почти через все элементы. Если есть большая коллекция и необходимо получать доступ к элементам по их индексу, вместо List используйте Vector или ArrayBuffer. Как запомнить названия методов В методах Scala символ : представляет сторону, на которой находится последовательность, поэтому, когда используется метод +:, список нужно указывать справа: 0 +: a // res2: List[Int] = List(0, 1, 2, 3) Аналогично, если используется :+, список должен быть слева: a :+ 4 // res3: List[Int] = List(1, 2, 3, 4) Кроме того, хорошей особенностью этих символических имен методов является то, что они стандартизированы. Те же имена методов используются с другими неизменяемыми последовательностями, такими как Seq и Vector. Также можно использовать несимволические имена методов для добавления элементов в начало (a.prepended(4)) или конец (a.appended(4)). Как пройтись по списку Представим, что есть список имён: val names = List(\"Joel\", \"Chris\", \"Ed\") Напечатать каждое имя можно следующим способом: for name &lt;- names do println(name) // Joel // Chris // Ed Преимуществом использования циклов for с коллекциями заключается в том, что Scala стандартизирован, и один и тот же подход работает со всеми последовательностями, включая Array, ArrayBuffer, List, Seq, Vector, Map, Set и т. д. Немного истории Список Scala подобен списку из языка программирования Lisp, который был впервые представлен в 1958 году. Действительно, в дополнение к привычному способу создания списка: val ints = List(1, 2, 3) // ints: List[Int] = List(1, 2, 3) точно такой же список можно создать следующим образом: val list = 1 :: 2 :: 3 :: Nil // list: List[Int] = List(1, 2, 3) Это работает, потому что List — односвязный список, оканчивающийся элементом Nil, а :: — это метод List, работающий как оператор “cons” в Lisp. LazyList Коллекции Scala также включают LazyList, который представляет собой ленивый неизменяемый связанный список. Он называется «ленивым» — или нестрогим — потому что вычисляет свои элементы только тогда, когда они необходимы. Примеры: val x = LazyList.range(1, Int.MaxValue) x.take(1) x.take(5) x.map(_ + 1) LazyList начинает вычислять свои элементы только при вызове некоторых методов, например, foreach: x.take(1).foreach(println) // 1 Для получения дополнительной информации об использовании, преимуществах и недостатках строгих и нестрогих (ленивых) коллекций см. обсуждение “строгих” и “нестрогих” коллекций на странице “Архитектура Scala 2.13’s Collections”. Vector Vector - это индексируемая неизменяемая последовательность. “Индексируемая” часть описания означает, что она обеспечивает произвольный доступ и обновление за практически постоянное время, поэтому можно быстро получить доступ к элементам Vector по значению их индекса, например, получить доступ к listOfPeople(123_456_789). В общем, за исключением той разницы, что (а) Vector индексируется, а List - нет, и (б) List имеет метод ::, эти два типа работают одинаково. Вот несколько способов создания Vector: val nums = Vector(1, 2, 3, 4, 5) // nums: Vector[Int] = Vector(1, 2, 3, 4, 5) val strings = Vector(\"one\", \"two\") // strings: Vector[String] = Vector(\"one\", \"two\") case class Person(name: String) val people = Vector( Person(\"Bert\"), Person(\"Ernie\"), Person(\"Grover\") ) // people: Vector[Person] = Vector( // Person(name = \"Bert\"), // Person(name = \"Ernie\"), // Person(name = \"Grover\") // ) Поскольку Vector неизменяем, в него нельзя добавить новые элементы. Вместо этого создается новая последовательность, с добавленными к существующему Vector в начало или в конец элементами. Например, так элементы добавляются в конец: val a = Vector(1,2,3) // a: Vector[Int] = Vector(1, 2, 3) val b = a :+ 4 // b: Vector[Int] = Vector(1, 2, 3, 4) val c = a ++ Vector(4, 5) // c: Vector[Int] = Vector(1, 2, 3, 4, 5) А так - в начало Vector-а: val a = Vector(1,2,3) // a: Vector[Int] = Vector(1, 2, 3) val b = 0 +: a // b: Vector[Int] = Vector(0, 1, 2, 3) val c = Vector(-1, 0) ++: a // c: Vector[Int] = Vector(-1, 0, 1, 2, 3) В дополнение к быстрому произвольному доступу и обновлениям, Vector обеспечивает быстрое добавление в начало и конец. Подробную информацию о производительности Vector и других коллекций см. в характеристиках производительности коллекций. Наконец, Vector в цикле for используется точно так же, как List, ArrayBuffer или любая другая последовательность: val names = Vector(\"Joel\", \"Chris\", \"Ed\") // names: Vector[String] = Vector(\"Joel\", \"Chris\", \"Ed\") for name &lt;- names do println(s\"My name is $name\") // My name is Joel // My name is Chris // My name is Ed ArrayBuffer ArrayBuffer используется тогда, когда нужна изменяемая индексированная последовательность общего назначения. Поскольку ArrayBuffer индексирован, произвольный доступ к элементам выполняется быстро. Создание ArrayBuffer Чтобы использовать ArrayBuffer, в отличие от предыдущих рассмотренных классов, его нужно вначале импортировать: import scala.collection.mutable.ArrayBuffer Если необходимо начать с пустого ArrayBuffer, просто укажите его тип: var strings = ArrayBuffer[String]() var ints = ArrayBuffer[Int]() var people = ArrayBuffer[Person]() Если известен примерный размер ArrayBuffer, его можно задать: val buf = new ArrayBuffer[Int](100_000) Чтобы создать новый ArrayBuffer с начальными элементами, достаточно просто указать начальные элементы, как для List или Vector: val nums = ArrayBuffer(1, 2, 3) val people = ArrayBuffer( Person(\"Bert\"), Person(\"Ernie\"), Person(\"Grover\") ) Добавление элементов в ArrayBuffer Новые элементы добавляются в ArrayBuffer с помощью методов += и ++=. Также можно использовать текстовый аналог: append, appendAll, insert, insertAll, prepend и prependAll. Вот несколько примеров с += и ++=: val nums = ArrayBuffer(1, 2, 3) // nums: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3) nums += 4 // res15: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4) nums ++= List(5, 6) // res18: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6) Удаление элементов из ArrayBuffer ArrayBuffer является изменяемым, поэтому у него есть такие методы, как -=, --=, clear, remove и другие. Примеры с -= и --=: val a = ArrayBuffer.range('a', 'h') // a: ArrayBuffer[Char] = ArrayBuffer('a', 'b', 'c', 'd', 'e', 'f', 'g') a -= 'a' // res20: ArrayBuffer[Char] = ArrayBuffer('b', 'c', 'd', 'e', 'f', 'g') a --= Seq('b', 'c') // res23: ArrayBuffer[Char] = ArrayBuffer('d', 'e', 'f', 'g') a --= Set('d', 'e') // res27: ArrayBuffer[Char] = ArrayBuffer('f', 'g') Обновление элементов в ArrayBuffer Элементы в ArrayBuffer можно обновлять, либо переназначать: val a = ArrayBuffer.range(1,5) // a: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4) a(2) = 50 println(a) // ArrayBuffer(1, 2, 50, 4) a.update(0, 10) println(a) // ArrayBuffer(10, 2, 50, 4) Maps Map — это итерируемая коллекция, состоящая из пар ключей и значений. В Scala есть как изменяемые, так и неизменяемые типы Map. В этом разделе показано, как использовать неизменяемый Map. Создание Map Неизменяемая Map создается следующим образом: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AZ\" -&gt; \"Arizona\" ) Перемещаться по элементам Map в цикле for можно следующим образом: for (k, v) &lt;- states do println(s\"key: $k, value: $v\") // key: AK, value: Alaska // key: AL, value: Alabama // key: AZ, value: Arizona Доступ к элементам Map Доступ к элементам Map осуществляется через указание в скобках значения ключа: val ak = states(\"AK\") // ak: String = \"Alaska\" val al = states(\"AL\") // al: String = \"Alabama\" На практике также используются такие методы, как keys, keySet, keysIterator, циклы for и функции высшего порядка, такие как map, для работы с ключами и значениями Map. Добавление элемента в Map При добавлении элементов в неизменяемую карту с помощью + и ++, создается новая карта: val a = Map(1 -&gt; \"one\") // a: Map[Int, String] = Map(1 -&gt; \"one\") val b = a + (2 -&gt; \"two\") // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") val c = b ++ Seq( 3 -&gt; \"three\", 4 -&gt; \"four\" ) // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\") Удаление элементов из Map Элементы удаляются с помощью методов - или --. В случае неизменяемой Map создается новый экземпляр, который нужно присвоить новой переменной: val a = Map( 1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\" ) // a: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\", 4 -&gt; \"four\") val b = a - 4 // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\") val c = a - 4 - 3 // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") Обновление элементов в Map Чтобы обновить элементы на неизменяемой Map, используется метод update (или оператор +): val a = Map( 1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\" ) // a: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\") val b = a.updated(3, \"THREE!\") // b: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"THREE!\") val c = a + (2 -&gt; \"TWO...\") // c: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"TWO...\", 3 -&gt; \"three\") Перебор элементов в Map Элементы в Map можно перебрать с помощью цикла for, как и для остальных коллекций: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AZ\" -&gt; \"Arizona\" ) // states: Map[String, String] = Map( // \"AK\" -&gt; \"Alaska\", // \"AL\" -&gt; \"Alabama\", // \"AZ\" -&gt; \"Arizona\" // ) for (k, v) &lt;- states do println(s\"key: $k, value: $v\") // key: AK, value: Alaska // key: AL, value: Alabama // key: AZ, value: Arizona Существует много способов работы с ключами и значениями на Map. Общие методы Map включают foreach, map, keys и values. В Scala есть много других специализированных типов Map, включая CollisionProofHashMap, HashMap, LinkedHashMap, ListMap, SortedMap, TreeMap, WeakHashMap и другие. Работа с множествами Множество (Set) - итерируемая коллекция без повторяющихся элементов. В Scala есть как изменяемые, так и неизменяемые типы Set. В этом разделе демонстрируется неизменяемое множество. Создание множества Создание нового пустого множества: val nums = Set[Int]() // nums: Set[Int] = Set() val letters = Set[Char]() // letters: Set[Char] = Set() Создание множества с исходными данными: val nums = Set(1, 2, 3, 3, 3) // nums: Set[Int] = Set(1, 2, 3) val letters = Set('a', 'b', 'c', 'c') // letters: Set[Char] = Set('a', 'b', 'c') Добавление элементов в множество В неизменяемое множество новые элементы добавляются с помощью + и ++, результат присваивается новой переменной: val a = Set(1, 2) // a: Set[Int] = Set(1, 2) val b = a + 3 // b: Set[Int] = Set(1, 2, 3) val c = b ++ Seq(4, 1, 5, 5) // c: Set[Int] = HashSet(5, 1, 2, 3, 4) Стоит отметить, что повторяющиеся элементы не добавляются в множество, а также, что порядок элементов произвольный. Удаление элементов из множества Элементы из множества удаляются с помощью методов - и --: val a = Set(1, 2, 3, 4, 5) // a: Set[Int] = HashSet(5, 1, 2, 3, 4) val b = a - 5 // b: Set[Int] = HashSet(1, 2, 3, 4) val c = b -- Seq(3, 4) // c: Set[Int] = HashSet(1, 2) Диапазон (Range) Range часто используется для заполнения структур данных и для циклов for. Эти примеры демонстрируют, как создавать диапазоны: 1 to 5 // res45: Inclusive = Range(1, 2, 3, 4, 5) 1 until 5 // res46: Range = Range(1, 2, 3, 4) 1 to 10 by 2 // res47: Range = Range(1, 3, 5, 7, 9) 'a' to 'c' // res48: Inclusive[Char] = NumericRange('a', 'b', 'c') Range можно использовать для заполнения коллекций: val x = (1 to 5).toList // x: List[Int] = List(1, 2, 3, 4, 5) val y = (1 to 5).toBuffer // y: Buffer[Int] = ArrayBuffer(1, 2, 3, 4, 5) Они также используются в циклах for: for i &lt;- 1 to 3 do println(i) // 1 // 2 // 3 Во многих коллекциях есть метод range: Vector.range(1, 5) // res50: Vector[Int] = Vector(1, 2, 3, 4) List.range(1, 10, 2) // res51: List[Int] = List(1, 3, 5, 7, 9) Set.range(1, 10) // res52: Set[Int] = HashSet(5, 1, 6, 9, 2, 7, 3, 8, 4) Диапазоны также полезны для создания тестовых коллекций: val evens = (0 to 10 by 2).toList // evens: List[Int] = List(0, 2, 4, 6, 8, 10) val odds = (1 to 10 by 2).toList // odds: List[Int] = List(1, 3, 5, 7, 9) val doubles = (1 to 5).map(_ * 2.0) // doubles: IndexedSeq[Double] = Vector(2.0, 4.0, 6.0, 8.0, 10.0) val map = (1 to 3).map(e =&gt; (e,s\"$e\")).toMap // map: Map[Int, String] = Map(1 -&gt; \"1\", 2 -&gt; \"2\", 3 -&gt; \"3\") Tuple (кортежи) Scala tuple - это тип, который позволяет помещать коллекцию разных типов в один и тот же контейнер. Например, учитывая case class Person: case class Person(name: String) можно построить кортеж, содержащий Int, String и Person: val t = (11, \"eleven\", Person(\"Eleven\")) // t: Tuple3[Int, String, Person] = (11, \"eleven\", Person(name = \"Eleven\")) Доступ к значениям кортежа осуществляется через индекс (начиная с 0): t(0) // res53: Int = 11 t(1) // res54: String = \"eleven\" t(2) // res55: Person = Person(name = \"Eleven\") либо через методы вида ._i, где i - порядковый номер (начиная с 1, в отличие от индекса) t._1 // res56: Int = 11 t._2 // res57: String = \"eleven\" t._3 // res58: Person = Person(name = \"Eleven\") Также можно использовать extractor для присвоения переменным значений полей кортежа: val (num, str, person) = t // num: Int = 11 // str: String = \"eleven\" // person: Person = Person(name = \"Eleven\") Кортежи хороши для случаев, когда необходимо поместить коллекцию разнородных типов в небольшую структуру, похожую на коллекцию. Подробнее Для дополнительной информации о коллекциях, см. следующие ресурсы: Неизменяемые классы коллекций Изменяемые классы коллекций Как устроены коллекции? Какую из них выбирать? References: Scala3 book Scala3 book, Collections Types"
    } ,    
    {
      "title": "Коллекции",
      "url": "/scalaworkbook/docs/collections.html",
      "content": "Коллекции Scala поставляется с большим количеством типов коллекций, на изучение которых может уйти время, поэтому желательно начать с нескольких из них, а затем использовать остальные по мере необходимости. Точно так же у каждого типа коллекции есть десятки методов, облегчающих разработку, но также желательно начать с нескольких из них. Поэтому в этом разделе продемонстрированы наиболее распространенные типы и методы коллекций. Более подробная информация о типах коллекций, показанных в этой главе, доступна в Scaladoc: List Vector ArrayBuffer Range Также упоминаются неизменяемые Map и Set: Map Set и изменяемые Map и Set: Map Set References: Scala3 book, Collections intro Scala3 book"
    } ,    
    {
      "title": "Параллелизм",
      "url": "/scalaworkbook/docs/concurrency.html",
      "content": "Параллелизм Для написания параллельных приложений на Scala, можно использовать нативный поток Java, но Scala Future предлагает более высокий уровень и идиоматический подход. Введение Вот описание Scala Future из его Scaladoc: “Future представляет собой значение, которое может быть или не быть доступным в настоящее время, но будет доступно в какой-то момент, или исключение, если это значение не может быть сделано доступным”. Чтобы продемонстрировать, что это значит, сначала рассмотрим однопоточное программирование. В однопоточном мире результат вызова метода привязывается к переменной следующим образом: def aShortRunningTask(): Int = 42 val x = aShortRunningTask() В этом коде значение 42 сразу привязывается к x. При работе с Future процесс назначения выглядит примерно так: def aLongRunningTask(): Future[Int] = ??? val x = aLongRunningTask() Но главное отличие в этом случае заключается в том, что, поскольку aLongRunningTask возвращает неопределенное время, значение x может быть доступно или недоступно в данный момент, но оно будет доступно в какой-то момент — в будущем. Другой способ взглянуть на это с точки зрения блокировки. В этом однопоточном примере оператор println не печатается до тех пор, пока не завершится выполнение aShortRunningTask: def aShortRunningTask(): Int = Thread.sleep(500) 42 val x = aShortRunningTask() println(\"Here\") И наоборот, если aShortRunningTask создается как Future, оператор println печатается почти сразу, потому что aShortRunningTask порождается в другом потоке — он не блокируется. В этой главе будет рассказано, как использовать Future, в том числе как запускать несколько Future параллельно и объединять их результаты в выражении for. Также будут показаны примеры методов, которые используются для обработки значения Future после его возврата. О Future, важно знать, что они задуманы как одноразовая конструкция “Обработайте это относительно медленное вычисление в каком-нибудь другом потоке и перезвоните мне с результатом, когда закончите”. В отличие от этого, акторы Akka предназначены для работы в течение длительного времени и отвечают на множество запросов в течение своей жизни. В то время как субъект может жить вечно, Future в конечном итоге содержит результат вычисления, которое выполнялось только один раз. Пример в REPL Future используется для создания временного кармана параллелизма. Например, можно использовать Future, когда нужно вызвать алгоритм, который выполняется неопределенное количество времени — например, вызов удаленного микросервиса, — поэтому его желательно запустить вне основного потока. Чтобы продемонстрировать, как это работает, начнем с примера Future в REPL. Во-первых, вставим необходимые инструкции импорта: import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global import scala.util.{Failure, Success} Теперь можно создать Future. Для этого примера сначала определим долговременный однопоточный алгоритм: def longRunningAlgorithm() = Thread.sleep(10_000) 42 Этот причудливый алгоритм возвращает целочисленное значение 42 после десятисекундной задержки. Теперь вызовем этот алгоритм, поместив его в конструктор Future и присвоив результат переменной: scala&gt; val eventualInt = Future(longRunningAlgorithm()) eventualInt: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;) Вычисления начинают выполняться после вызова longRunningAlgorithm(). Если сразу проверить значение переменной eventualInt, то можно увидеть, что Future еще не завершен: scala&gt; eventualInt val res1: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;) Но если проверить через десять секунд еще раз, то можно увидеть, что оно выполнено успешно: scala&gt; eventualInt val res2: scala.concurrent.Future[Int] = Future(Success(42)) Хотя это относительно простой пример, он демонстрирует основной подход: просто создайте новое Future с помощью своего долговременного алгоритма. Одна вещь, на которую следует обратить внимание - это то, что ожидаемый результат 42 обернут в Success, который обернут в Future. Это ключевая концепция для понимания: значение Future всегда является экземпляром одного из scala.util.Try: Success или Failure. Поэтому, при работе с результатом Future, используются обычные методы обработки Try. Использование map с Future Future имеет метод map, который используется точно так же, как метод map для коллекций. Вот как выглядит результат, при вызове map сразу после создания переменной eventualInt: scala&gt; val a = eventualInt.map(_ * 2) a: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;) Как показано, для Future, созданного с помощью longRunningAlgorithm, первоначальный вывод показывает Future(&lt;not completed&gt;). Но если проверить значение a через десять секунд, то можно увидеть, что оно содержит ожидаемый результат 84: scala&gt; a res1: scala.concurrent.Future[Int] = Future(Success(84)) Еще раз, успешный результат обернут внутри Success и Future. Использование методов обратного вызова с Future В дополнение к функциям высшего порядка, таким как map, с Future также можно использовать методы обратного вызова. Одним из часто используемых методов обратного вызова является onComplete, принимающий частичную функцию, в которой обрабатываются случаи Success и Failure: eventualInt.onComplete { case Success(value) =&gt; println(s\"Got the callback, value = $value\") case Failure(e) =&gt; e.printStackTrace } Если вставить этот код в REPL, то в конечном итоге придет результат: Got the callback, value = 42 Другие методы Future Класс Future имеет некоторые методы, которые можно найти в классах коллекций Scala, в том числе: filter flatMap map Методы обратного вызова: onComplete andThen foreach Другие методы трансформации: fallbackTo recover recoverWith См. страницу “Futures and Promises” для обсуждения дополнительных методов, доступных для Future. Запуск нескольких Future и объединение результатов Чтобы запустить несколько вычислений параллельно и соединить их результаты после завершения всех Future, можно использовать выражение for. Правильный подход такой: Запустить вычисления, которые возвращают Future результаты Объединить их результаты в выражении for Извлечь объединенный результат, используя onComplete или аналогичный метод Пример Рассмотрим следующий пример. Ключевой момент - сначала запускаются вычисления, возвращающие Future, а затем они объединяются в выражении for: import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global import scala.util.{Failure, Success} val startTime = System.currentTimeMillis() def delta() = System.currentTimeMillis() - startTime def sleep(millis: Long) = Thread.sleep(millis) @main def multipleFutures1 = println(s\"creating the futures: ${delta()}\") // (1) запуск вычислений, возвращающих Future val f1 = Future { sleep(800); 1 } // в конце концов возвращается 1 val f2 = Future { sleep(200); 2 } // в конце концов возвращается 2 val f3 = Future { sleep(400); 3 } // в конце концов возвращается 3 // (2) объединение нескольких Future в выражении `for` val result = for r1 &lt;- f1 r2 &lt;- f2 r3 &lt;- f3 yield println(s\"in the 'yield': ${delta()}\") (r1 + r2 + r3) // (3) обработка результата result.onComplete { case Success(x) =&gt; println(s\"in the Success case: ${delta()}\") println(s\"result = $x\") case Failure(e) =&gt; e.printStackTrace } println(s\"before the 'sleep(3000)': ${delta()}\") // важно для небольшой параллельной демонстрации: не глушить jvm sleep(3000) После запуска этого приложения, вывод выглядит следующим образом: creating the futures: 1 before the 'sleep(3000)': 2 in the 'yield': 806 in the Success case: 806 result = 6 Как показывает вывод, Future создаются очень быстро, и всего за две миллисекунды достигается оператор печати непосредственно перед операцией sleep(3000) в конце метода. Весь этот код выполняется в основном потоке JVM. Затем, через 806 мс, три Future завершаются, и выполняется код в блоке yield. Затем код немедленно переходит к успешному завершению в методе onComplete. Вывод 806 мс является ключом к тому, чтобы убедиться, что три вычисления выполняются параллельно. Если бы они выполнялись последовательно, общее время составило бы около 1400 мс — сумма времени ожидания трех вычислений. Но поскольку они выполняются параллельно, общее время чуть больше, чем у самого продолжительного вычисления f1, которое составляет 800 мс. Обратите внимание, что если бы вычисления выполнялись в выражении for, они выполнялись бы последовательно, а не параллельно: // последовательное выполнение (не параллельно!) for r1 &lt;- Future { sleep(800); 1 } r2 &lt;- Future { sleep(200); 2 } r3 &lt;- Future { sleep(400); 3 } yield r1 + r2 + r3 Итак, если необходимо, чтобы вычисления выполнялись параллельно, не забудьте запустить их вне выражения for. Метод, возвращающий Future Было показано, как передавать однопоточный алгоритм в конструктор Future. Ту же технику можно использовать для создания метода, который возвращает Future: // моделируем медленно работающий метод def slowlyDouble(x: Int, delay: Long): Future[Int] = Future { sleep(delay) x * 2 } Как и в предыдущих примерах, достаточно просто присвоить результат вызова метода новой переменной. Тогда, если сразу проверить результат, то можно увидеть, что он не завершен, но по истечении времени задержки в Future результат будет выдан: scala&gt; val f = slowlyDouble(2, 5_000L) val f: concurrent.Future[Int] = Future(&lt;not completed&gt;) scala&gt; f val res0: concurrent.Future[Int] = Future(&lt;not completed&gt;) scala&gt; f val res1: concurrent.Future[Int] = Future(Success(4)) Ключевые моменты о Future Подводя итог, несколько ключевых моментов о Future: Future создается для запуска задач вне основного потока Future предназначены для одноразовых, потенциально длительных параллельных задач, которые в конечном итоге возвращают значение; они создают временный карман параллелизма Future начинает работать в момент построения преимущество Future над потоками заключается в том, что они работают с выражениями for и имеют множество методов обратного вызова, упрощающих процесс работы с параллельными потоками при работе с Future не нужно беспокоиться о низкоуровневых деталях управления потоками результат Future обрабатывается с помощью методов обратного вызова, таких как onComplete и andThen, или методов преобразования, таких как filter, map и т.д. значение внутри Future всегда является экземпляром одного из типов Try: Success или Failure при использовании нескольких Future для получения одного результата, они объединяются в выражении for Кроме того, как было видно по операторам import, Scala Future зависит от ExecutionContext. Дополнительные сведения о Future см. в статье Futures and Promises, в которой обсуждаются futures, promises и execution contexts. В ней также обсуждается, как выражение for транслируется в операцию flatMap. References: Scala3 book"
    } ,    
    {
      "title": "Eta расширение",
      "url": "/scalaworkbook/docs/functions/eta.html",
      "content": "Eta расширение Если посмотреть на Scaladoc для метода map в классах коллекций Scala, то можно увидеть, что метод определен для приема функции: def map[B](f: (A) =&gt; B): List[B] ----------- Действительно, в Scaladoc сказано: “f — это функция, применяемая к каждому элементу”. Но, несмотря на это, каким-то образом в map можно передать метод, и он все еще работает: def times10(i: Int) = i * 10 List(1, 2, 3).map(times10) // res0: List[Int] = List(10, 20, 30) Как это работает? Как можно передать метод в map, который ожидает функцию? Технология, стоящая за этим, известна как Eta Expansion. Она преобразует выражение типа метода в эквивалентное выражение типа функции, и делает это легко и незаметно. Различия между методами и функциями Исторически методы были частью определения класса, хотя в Scala 3 методы могут быть вне классов, такие как определения верхнего уровня и методы расширения. В отличие от методов, функции сами по себе являются полноценными объектами, что делает их объектами первого класса. Их синтаксис также отличается. В этом примере показано, как задать метод и функцию, которые выполняют одну и ту же задачу, определяя, является ли заданное целое число четным: def isEvenMethod(i: Int) = i % 2 == 0 // метод val isEvenFunction = (i: Int) =&gt; i % 2 == 0 // функция Функция действительно является объектом, поэтому ее можно использовать так же, как и любую другую переменную, например, помещая в список: val functions = List(isEvenFunction) И наоборот, технически метод не является объектом, поэтому в Scala 2 метод нельзя было поместить в список, по крайней мере, напрямую, как показано в этом примере: // В этом примере показано сообщение об ошибке в Scala 2 val methods = List(isEvenMethod) ^ error: missing argument list for method isEvenMethod Unapplied methods are only converted to functions when a function type is expected. You can make this conversion explicit by writing `isEvenMethod _` or `isEvenMethod(_)` instead of `isEvenMethod`. Как показано в этом сообщении об ошибке, в Scala 2 существует ручной способ преобразования метода в функцию, но важной частью для Scala 3 является то, что технология Eta Expansion улучшена, поэтому теперь, когда попытаться использовать метод в качестве переменной, он просто работает — не нужно самостоятельно выполнять ручное преобразование: val functions = List(isEvenFunction) val methods = List(isEvenMethod) Важно отметить следующее: Eta Expansion — технология Scala, позволяющая использовать методы так же, как и функции Технология была улучшена в Scala 3, чтобы быть почти полностью бесшовной References: Scala3 book"
    } ,    
    {
      "title": "Моделирование ФП",
      "url": "/scalaworkbook/docs/modeling/fp.html",
      "content": "Моделирование ФП В этой главе представлено введение в моделирование предметной области с использованием функционального программирования (ФП). При моделировании с помощью ФП обычно используются следующие конструкции Scala: Enums Case classes Traits Введение В ФП данные и операции над этими данными — это две разные вещи; их необязательно инкапсулировать вместе, как в ООП. Концепция аналогична числовой алгебре. Когда вы думаете о целых числах, значения которых больше или равны нулю, то у вас есть набор возможных значений, который выглядит следующим образом: 0, 1, 2 ... Int.MaxValue Игнорируя деление целых чисел, возможные операции над этими значениями такие: +, -, * Схема ФП реализуется аналогичным образом: описывается свой набор значений (данные) описываются операции, которые работают с этими значениями (функции) Как будет видно, рассуждения о программах в этом стиле сильно отличаются от объектно-ориентированного программирования. Отделение функциональности от данных позволяет проверять свои данные, не беспокоясь о поведении. В этой главе мы смоделируем данные и операции для “пиццы” в пиццерии. Будет показано, как реализовать часть “данных” модели Scala/ФП, а затем - несколько различных способов организации операций с этими данными. Моделирование данных В Scala достаточно просто описать модель данных: если необходимо смоделировать данные с различными вариантами, то используется конструкция enum если необходимо только сгруппировать сущности (или нужен более детальный контроль), то используются case class-ы Описание вариантов Данные, которые просто состоят из различных вариантов, таких как размер корочки, тип корочки и начинка, кратко моделируются с помощью конструкции enum: enum CrustSize: case Small, Medium, Large enum CrustType: case Thin, Thick, Regular enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions Типы данных, которые описывают различные варианты (например, CrustSize), также иногда называют типами суммы (sum types). Описание основных данных Пиццу можно рассматривать как составной контейнер с различными атрибутами, указанными выше. Мы можем использовать case class, чтобы описать, что пицца состоит из размеров корки, типа корки и, возможно, нескольких начинок: import CrustSize.* import CrustType.* import Topping.* case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) Типы данных, объединяющие несколько компонентов (например, Pizza), также иногда называют типами продуктов (product types). И все. Это модель данных для системы доставки пиццы в стиле ФП. Решение очень лаконично, поскольку оно не требует объединения модели данных с операциями с пиццей. Модель данных легко читается, как объявление дизайна для реляционной базы данных. Также очень легко создавать значения нашей модели данных и проверять их: val myFavPizza = Pizza(Small, Regular, Seq(Cheese, Pepperoni)) // myFavPizza: Pizza = Pizza( // crustSize = Small, // crustType = Regular, // toppings = List(Cheese, Pepperoni) // ) println(myFavPizza.crustType) // Regular Подробнее о модели данных Таким же образом можно было бы смоделировать всю систему заказа пиццы. Вот несколько других case class-ов, которые используются для моделирования такой системы: case class Address( street1: String, street2: Option[String], city: String, state: String, zipCode: String ) case class Customer( name: String, phone: String, address: Address ) case class Order( pizzas: Seq[Pizza], customer: Customer ) “Узкие доменные объекты” В своей книге Functional and Reactive Domain Modeling, Debasish Ghosh утверждает, что там, где специалисты по ООП описывают свои классы как “широкие модели предметной области”, которые инкапсулируют данные и поведение, модели данных ФП можно рассматривать как “узкие объекты предметной области”. Это связано с тем, что, как показано выше, модели данных определяются как case class-ы с атрибутами, но без поведения, что приводит к коротким и лаконичным структурам данных. Моделирование операций Возникает интересный вопрос: поскольку ФП отделяет данные от операций над этими данными, то как эти операции реализуются в Scala? Ответ на самом деле довольно прост: пишутся функции/методы, работающие со значениями смоделированных данных. Например, можно определить функцию, которая вычисляет цену пиццы. def pizzaPrice(p: Pizza): Double = p match case Pizza(crustSize, crustType, toppings) =&gt; val base = 6.00 val crust = crustPrice(crustSize, crustType) val tops = toppings.map(toppingPrice).sum base + crust + tops Можно заметить, что реализация функции просто повторяет форму данных: поскольку Pizza является case class-ом, используется сопоставление с образцом для извлечения компонентов, а затем вызываются вспомогательные функции для вычисления отдельных цен. def toppingPrice(t: Topping): Double = t match case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 Точно так же, поскольку Topping является перечислением, используется сопоставление с образцом, чтобы разделить варианты. Сыр и лук продаются по 50 центов за штуку, остальные — по 75. def crustPrice(s: CrustSize, t: CrustType): Double = (s, t) match case (Small | Medium, _) =&gt; 0.25 // игнорируем значение t case (Large, Thin) =&gt; 0.50 case (Large, Regular) =&gt; 0.75 case (Large, Thick) =&gt; 1.00 Чтобы рассчитать цену корки, мы одновременно сопоставляем образцы как по размеру, так и по типу корки. Важным моментом во всех показанных выше функциях является то, что они являются чистыми функциями (pure functions): они не изменяют данные и не имеют других побочных эффектов (таких, как выдача исключений или запись в файл). Всё, что они делают - это просто получают значения и вычисляют результат. Как организовать функциональность? При реализации функции расчета цены пиццы, описанной выше, не было сказано, где ее определять. В Scala 3 вполне допустимо определить функцию на верхнем уровне файла. Тем не менее язык предоставляет множество отличных инструментов для организации логики в различных пространствах имен и модулях. Существует несколько способов реализации и организации поведения: определить функции в сопутствующих объектах (companion object) использовать модульный стиль программирования использовать подход “функциональных объектов” определить функциональность в методах расширения Эти различные решения показаны в оставшейся части этого раздела. Companion Object Первый подход — определить поведение (функции) в сопутствующем объекте. Как обсуждалось в разделе “Инструменты моделирования предметной области”, сопутствующий объект — это объект с тем же именем, что и у класса, и объявленный в том же файле, что и класс. При таком подходе в дополнение к enum или case class также определяется companion object с таким же именем, который содержит поведение (функции). case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) // companion object для кейс класса Pizza object Pizza: def price(p: Pizza): Double = ... // тоже самое, что и pizzaPrice enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions // companion object для перечисления Topping object Topping: def price(t: Topping): Double = t match // тоже самое, что и toppingPrice case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 При таком подходе можно создать Pizza и вычислить ее цену следующим образом: val pizza1 = Pizza(Small, Thin, Seq(Cheese, Onions)) Pizza.price(pizza1) Группировка функциональности с помощью сопутствующих объектов имеет несколько преимуществ: связывает функциональность с данными и облегчает их поиск программистам (и компилятору). создает пространство имен и, например, позволяет использовать price в качестве имени метода, не полагаясь на перегрузку. реализация Topping.price может получить доступ к значениям перечисления, таким как Cheese, без необходимости их импорта. Однако также есть несколько компромиссов, которые следует учитывать: модель данных тесно связывается с функциональностью. В частности, сопутствующий объект должен быть определен в том же файле, что и case class. неясно, где определять такие функции, как crustPrice, которые с одинаковым успехом можно поместить в сопутствующий объект CrustSize или CrustType. Модули Второй способ организации поведения — использование “модульного” подхода. В книге “Программирование на Scala” модуль определяется как “небольшая часть программы с четко определенным интерфейсом и скрытой реализацией”. Давайте посмотрим, что это значит. Создание интерфейса PizzaService Первое, о чем следует подумать, — это “поведение” Pizza. Делая это, определяем trait PizzaServiceInterface следующим образом: trait PizzaServiceInterface: def price(p: Pizza): Double def addTopping(p: Pizza, t: Topping): Pizza def removeAllToppings(p: Pizza): Pizza def updateCrustSize(p: Pizza, cs: CrustSize): Pizza def updateCrustType(p: Pizza, ct: CrustType): Pizza Как показано, каждый метод принимает Pizza в качестве входного параметра вместе с другими параметрами, а затем возвращает экземпляр Pizza в качестве результата. Когда пишется такой чистый интерфейс, можно думать о нем как о контракте, в котором говорится: “Все неабстрактные классы, расширяющие этот trait, должны предоставлять реализацию этих сервисов”. На этом этапе также можно представить, что вы являетесь потребителем этого API. Когда вы это сделаете, будет полезно набросать некоторый пример “потребительского” кода, чтобы убедиться, что API выглядит так, как хотелось: val p = Pizza(Small, Thin, Seq(Cheese)) val p1 = addTopping(p, Pepperoni) val p2 = addTopping(p1, Onions) val p3 = updateCrustType(p2, Thick) val p4 = updateCrustSize(p3, Large) Если с этим кодом все в порядке, как правило, можно начать набрасывать другой API, например API для заказов, но, поскольку сейчас рассматривается только Pizza, перейдем к созданию конкретной реализации этого интерфейса. Обратите внимание, что обычно это двухэтапный процесс. На первом шаге набрасывается контракт API в качестве интерфейса. На втором шаге создается конкретная реализация этого интерфейса. В некоторых случаях в конечном итоге создается несколько конкретных реализаций базового интерфейса. Создание конкретной реализации Теперь, когда известно, как выглядит PizzaServiceInterface, можно создать конкретную реализацию, написав тело для всех методов, определенных в интерфейсе: object PizzaService extends PizzaServiceInterface: def price(p: Pizza): Double = p match case Pizza(crustSize, crustType, toppings) =&gt; val base = 6.00 val crust = crustPrice(crustSize, crustType) val tops = toppings.map(toppingPrice).sum base + crust + tops def addTopping(p: Pizza, t: Topping): Pizza = p.copy(toppings = p.toppings :+ t) def removeAllToppings(p: Pizza): Pizza = p.copy(toppings = Seq.empty) def updateCrustSize(p: Pizza, cs: CrustSize): Pizza = p.copy(crustSize = cs) def updateCrustType(p: Pizza, ct: CrustType): Pizza = p.copy(crustType = ct) private def toppingPrice(t: Topping): Double = t match case Cheese | Onions =&gt; 0.5 case Pepperoni | BlackOlives | GreenOlives =&gt; 0.75 private def crustPrice(s: CrustSize, t: CrustType): Double = (s, t) match case (Small | Medium, _) =&gt; 0.25 case (Large, Thin) =&gt; 0.50 case (Large, Regular) =&gt; 0.75 case (Large, Thick) =&gt; 1.00 end PizzaService Хотя двухэтапный процесс создания интерфейса с последующей реализацией не всегда необходим, явное продумывание API и его использования — хороший подход. Когда все готово, можно использовать Pizza и PizzaService: import PizzaService.* val p = Pizza(Small, Thin, Seq(Cheese)) // p: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese)) val p1 = addTopping(p, Pepperoni) // p1: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese, Pepperoni)) val p2 = addTopping(p1, Onions) // p2: Pizza = Pizza(crustSize = Small, crustType = Thin, toppings = List(Cheese, Pepperoni, Onions)) val p3 = updateCrustType(p2, Thick) // p3: Pizza = Pizza(crustSize = Small, crustType = Thick, toppings = List(Cheese, Pepperoni, Onions)) val p4 = updateCrustSize(p3, Large) // p4: Pizza = Pizza(crustSize = Large, crustType = Thick, toppings = List(Cheese, Pepperoni, Onions)) println(price(p4)) // 8.75 Функциональные объекты В книге “Программирование на Scala” авторы определяют термин “Функциональные объекты” как “объекты, которые не имеют никакого изменяемого состояния”. Это также относится к типам в scala.collection.immutable. Например, методы в List не изменяют внутреннего состояния, а вместо этого создают в результате копию List. Об этом подходе можно думать, как о “гибридном дизайне ФП/ООП”, потому что: данные моделируются, используя неизменяемые case class-ы. определяется поведение (методы) того же типа, что и данные. поведение реализуется как чистые функции: они не изменяют никакого внутреннего состояния; скорее - возвращают копию. Это действительно гибридный подход: как и в дизайне ООП, методы инкапсулированы в класс с данными, но, как это обычно бывает в дизайне ФП, методы реализованы как чистые функции, которые данные не изменяют. Пример Используя этот подход, можно напрямую реализовать функциональность пиццы в case class: case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ): // операции этой модели данных def price: Double = ... // такая же имплементация, как и выше в PizzaService.price def addTopping(t: Topping): Pizza = this.copy(toppings = this.toppings :+ t) def removeAllToppings: Pizza = this.copy(toppings = Seq.empty) def updateCrustSize(cs: CrustSize): Pizza = this.copy(crustSize = cs) def updateCrustType(ct: CrustType): Pizza = this.copy(crustType = ct) Обратите внимание, что в отличие от предыдущих подходов, поскольку это методы класса Pizza, они не принимают ссылку Pizza в качестве входного параметра. Вместо этого у них есть собственная ссылка на текущий экземпляр пиццы - this. Теперь можно использовать этот новый дизайн следующим образом: Pizza(Small, Thin, Seq(Cheese)) .addTopping(Pepperoni) .updateCrustType(Thick) .price Методы расширения Методы расширения - подход, который находится где-то между первым (определение функций в сопутствующем объекте) и последним (определение функций как методов самого типа). Методы расширения позволяют создавать API, похожий на API функционального объекта, без необходимости определять функции как методы самого типа. Это может иметь несколько преимуществ: модель данных снова очень лаконична и не упоминает никакого поведения. можно задним числом развить функциональность типов дополнительными методами, не изменяя исходного определения. помимо сопутствующих объектов или прямых методов типов, методы расширения могут быть определены извне в другом файле. Вернемся к примеру: case class Pizza( crustSize: CrustSize, crustType: CrustType, toppings: Seq[Topping] ) extension (p: Pizza) def price: Double = pizzaPrice(p) // имплементация выше def addTopping(t: Topping): Pizza = p.copy(toppings = p.toppings :+ t) def removeAllToppings: Pizza = p.copy(toppings = Seq.empty) def updateCrustSize(cs: CrustSize): Pizza = p.copy(crustSize = cs) def updateCrustType(ct: CrustType): Pizza = p.copy(crustType = ct) В приведенном выше коде различные методы для пиццы определяются как методы расширения (extension methods). Код extension (p: Pizza) говорит о том, что мы хотим сделать методы доступными для экземпляров Pizza, и в дальнейшем ссылаемся на экземпляр, который расширяем, как p. Таким образом, получается тот же API, что и раньше: Pizza(Small, Thin, Seq(Cheese)) .addTopping(Pepperoni) .updateCrustType(Thick) .price При этом методы расширения можно определить в любом другом модуле. Как правило, если вы являетесь разработчиком модели данных, вы определяете свои методы расширения в сопутствующем объекте. Таким образом, они уже доступны всем пользователям. В противном случае методы расширения должны быть импортированы явно, чтобы их можно было использовать. Резюме функционального подхода Определение модели данных в Scala/ФП, как правило, простое: моделируются варианты данных с помощью enum-ов и составных данных с помощью case class-ов. Затем, чтобы смоделировать поведение, определяются функции, которые работают со значениями модели данных. Были рассмотрены разные способы организации функций: можно поместить методы в сопутствующие объекты можно использовать модульный стиль программирования, разделяющий интерфейс и реализацию можно использовать подход “функциональных объектов” и хранить методы в определенном типе данных можно использовать методы расширения, чтобы снабдить модель данных функциональностью References: Scala3 book, domain modeling fp Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Функциональное программирование",
      "url": "/scalaworkbook/docs/fp.html",
      "content": "Функциональное программирование Scala позволяет писать код в стиле объектно-ориентированного программирования (ООП), функционального программирования (ФП), а также в гибридном стиле — используя комбинацию обоих подходов. По словам Мартина Одерского, суть Scala - это слияние функционального и объектно-ориентированного программирования в типизированной среде: функции для логики объекты для модульности В этой главе дается краткое введение в несколько основных концепций функционального программирования: что такое функциональное программирование? неизменяемые значения чистые функции функции - это значения функциональная обработка ошибок Функциональное программирование - это огромная тема, поэтому здесь будут даны только вводные понятия. Более подробная информация будет раскрыта в отдельной документации. References: Scala3 book"
    } ,    
    {
      "title": "Функциональная обработка ошибок",
      "url": "/scalaworkbook/docs/fp/functional-error-handling.html",
      "content": "Функциональная обработка ошибок Функциональное программирование похоже на написание ряда алгебраических уравнений, и поскольку алгебра не имеет null значений или исключений, эти функции не используются в ФП. Это поднимает интересный вопрос: что делать в ситуациях, когда в коде ООП обычно используются null значение или исключение? Решение Scala заключается в использовании конструкций, подобных классам Option/Some/None. Примечание: классы Some и None являются подклассами Option вместо того чтобы многократно повторять “Option/Some/None”, следующий текст обычно просто ссылается на “Option” или “классы Option” Первый пример Хотя этот первый пример не имеет дело со значениями null, это хороший способ познакомиться с классами Option. Представим, что нужно написать метод, который упрощает преобразование строк в целочисленные значения. И нужен элегантный способ обработки исключения, которое возникает, когда метод получает строку типа \"Hello\" вместо \"1\". Первое предположение о таком методе может выглядеть следующим образом: def makeInt(s: String): Int = try Integer.parseInt(s.trim) catch case e: Exception =&gt; 0 Если преобразование работает, метод возвращает правильное значение Int, но в случае сбоя метод возвращает 0. Для некоторых целей это может быть хорошо, но не совсем точно. Например, метод мог получить \"0\", но мог также получить \"foo\", \"bar\" или бесконечное количество других строк, которые выдадут исключение. Это реальная проблема: как определить, когда метод действительно получил \"0\", а когда получил что-то еще? При таком подходе нет способа узнать правильный ответ наверняка. Использование Option/Some/None Распространенным решением этой проблемы в Scala является использование классов, известных как Option, Some и None. Классы Some и None являются подклассами Option, поэтому решение работает следующим образом: объявляется, что makeInt возвращает тип Option если makeInt получает строку, которую он может преобразовать в Int, ответ помещается внутрь Some если makeInt получает строку, которую не может преобразовать, то возвращает None Вот доработанная версия makeInt: def makeInt(s: String): Option[Int] = try Some(Integer.parseInt(s.trim)) catch case e: Exception =&gt; None Этот код можно прочитать следующим образом: “Когда данная строка преобразуется в целое число, верните значение Int, заключенное в Some, например Some(1). Когда строка не может быть преобразована в целое число и генерируется исключение, метод возвращает значение None.” Эти примеры показывают, как работает makeInt: val a = makeInt(\"1\") // a: Option[Int] = Some(value = 1) val b = makeInt(\"one\") // b: Option[Int] = None Как показано, строка \"1\" приводится к Some(1), а строка \"one\" - к None. В этом суть альтернативного подхода к обработке ошибок. Данная техника используется для того, чтобы методы могли возвращать значения вместо исключений. В других ситуациях значения Option также используются для замены null значений. Примечание: этот подход используется во всех классах библиотеки Scala, а также в сторонних библиотеках Scala ключевым моментом примера является то, что функциональные методы не генерируют исключения; вместо этого они возвращают такие значения, как Option Потребитель makeInt Теперь представим, что мы являемся потребителем метода makeInt. Известно, что он возвращает подкласс Option[Int], поэтому возникает вопрос: как работать с этими возвращаемыми типами? Есть два распространенных ответа, в зависимости от потребностей: использование match выражений использование for выражений Использование match выражений Одним из возможных решений является использование выражения match: makeInt(x) match case Some(i) =&gt; println(i) case None =&gt; println(\"That didn’t work.\") В этом примере, если x можно преобразовать в Int, вычисляется выражение в правой части первого предложения case; если x не может быть преобразован в Int, оценивается выражение в правой части второго предложения case. Использование for выражений Другим распространенным решением является использование выражения for, то есть комбинации for/yield. Например, представим, что необходимо преобразовать три строки в целочисленные значения, а затем сложить их. Решение задачи с использованием выражения for: val y = for a &lt;- makeInt(stringA) b &lt;- makeInt(stringB) c &lt;- makeInt(stringC) yield a + b + c После выполнения этого выражения y может принять одно из двух значений: если все три строки конвертируются в значения Int, y будет равно Some[Int], т. е. целым числом, обернутым внутри Some если какая-либо из трех строк не может быть преобразована в Int, y равен None Это можно проверить на примере: val stringA = \"1\" val stringB = \"2\" val stringC = \"3\" val y = for a &lt;- makeInt(stringA) b &lt;- makeInt(stringB) c &lt;- makeInt(stringC) yield a + b + c // y: Option[Int] = Some(value = 6) Чтобы увидеть негативный кейс, достаточно изменить любую из строк на что-то, что нельзя преобразовать в целое число. В этом случае y равно None: y: Option[Int] = None Восприятие Option, как контейнера Для лучшего восприятия Option, его можно представить как контейнер: Some представляет собой контейнер с одним элементов None не является контейнером, в нем ничего нет Если предпочтительнее думать об Option как о ящике, то None подобен пустому ящику. Что-то в нём могло быть, но нет. Использование Option для замены null Возвращаясь к значениям null, место, где null значение может незаметно проникнуть в код, — класс, подобный этому: class Address( var street1: String, var street2: String, var city: String, var state: String, var zip: String ) Хотя каждый адрес имеет значение street1, значение street2 не является обязательным. В результате полю street2 можно присвоить значение null: val santa = Address( \"1 Main Street\", null, \"North Pole\", \"Alaska\", \"99705\" ) Исторически сложилось так, что в этой ситуации разработчики использовали пустые строки и значения null, оба из которых “взламывают” решения основной проблемы: street2 - необязательное поле. В Scala и других современных языках правильное решение состоит в том, чтобы заранее объявить, что street2 является необязательным: class Address( var street1: String, var street2: Option[String], var city: String, var state: String, var zip: String ) Теперь можно написать более точный код: val santa = Address( \"1 Main Street\", None, \"North Pole\", \"Alaska\", \"99705\" ) или так: val santa = Address( \"123 Main Street\", Some(\"Apt. 2B\"), \"Talkeetna\", \"Alaska\", \"99676\" ) Option — не единственное решение В этом разделе основное внимание уделялось Option классам, но у Scala есть несколько других альтернатив. Например, три класса, известные как Try/Success/Failure, работают также, но (а) эти классы в основном используются, когда код может генерировать исключения, и (б) желательно использовать класс Failure, потому что он дает доступ к сообщению об исключении. Например, классы Try обычно используются при написании методов, которые взаимодействуют с файлами, базами данных или интернет-службами, поскольку эти функции могут легко создавать исключения. Краткое ревью Краткое ревью: функциональные программисты не используют null значения основной заменой null значениям является использование классов Option функциональные методы не выдают исключений; вместо этого они возвращают такие значения, как Option, Try или Either распространенными способами работы со значениями Option являются выражения match и for Option можно рассматривать как контейнеры с одним элементом (Some) и без элементов (None) Option также можно использовать для дополнительных параметров конструктора или метода References: Scala3 book"
    } ,    
    {
      "title": "Функции - это значения",
      "url": "/scalaworkbook/docs/fp/functions-are-values.html",
      "content": "Функции - это значения Хотя каждый когда-либо созданный язык программирования, вероятно, позволяет писать чистые функции, вторая важная особенность ФП на Scala заключается в том, что функции можно создавать как значения, точно так же, как создаются значения String и Int. Эта особенность содержит много преимуществ, наиболее распространенными из которых являются: можно определять методы, принимающие в качестве параметров функции можно передавать функции в качестве параметров в методы Это было видно во многих местах предыдущих глав, когда демонстрировались такие методы, как map и filter: val nums = (1 to 10).toList // nums: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val doubles = nums.map(_ * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) val lessThanFive = nums.filter(_ &lt; 5) // lessThanFive: List[Int] = List(1, 2, 3, 4) В этих примерах анонимные функции передаются в map и filter. Анонимные функции также известны как лямбды. Помимо передачи анонимных функций в filter и map, в них также можно передать методы: def double(i: Int): Int = i * 2 def underFive(i: Int): Boolean = i &lt; 5 val doubles = nums.filter(underFive).map(double) // doubles: List[Int] = List(2, 4, 6, 8) Эта возможность обращаться с методами и функциями как со значениями — мощное свойство, предоставляемое языками функционального программирования. Технически функция, которая принимает другую функцию в качестве входного параметра, известна как функция высшего порядка. Функции, анонимные функции и методы В примерах выше анонимная функция это: _ * 2 Как было показано в обсуждении функций высшего порядка, _ * 2 - сокращенная версия синтаксиса: (i: Int) =&gt; i * 2 Такие функции называются “анонимными”, потому что им не присваивается определенное имя. Для того чтобы это имя задать, достаточно просто назначить его переменной: val double = (i: Int) =&gt; i * 2 Теперь появилась именованная функция, назначенная переменной double. Можно использовать эту функцию так же, как используется метод: double(2) // res2: Int = 4 В большинстве случаев не имеет значения, является ли double функцией или методом; Scala позволяет обращаться с ними одинаково. За кулисами технология Scala, которая позволяет обращаться с методами так же, как с функциями, известна как Eta Expansion. Эта способность беспрепятственно передавать функции в качестве переменных является отличительной чертой функциональных языков программирования, таких как Scala. И, как было видно на примерах map и filter, возможность передавать функции в другие функции помогает создавать код, который является кратким и при этом читабельным — выразительным. Вот еще несколько примеров: List(\"bob\", \"joe\").map(_.toUpperCase) // res4: List[String] = List(\"BOB\", \"JOE\") List(\"bob\", \"joe\").map(_.capitalize) // res5: List[String] = List(\"Bob\", \"Joe\") List(\"plum\", \"banana\").map(_.length) // res6: List[Int] = List(4, 6) val fruits = List(\"apple\", \"pear\") // fruits: List[String] = List(\"apple\", \"pear\") fruits.map(_.toUpperCase) // res7: List[String] = List(\"APPLE\", \"PEAR\") fruits.flatMap(_.toUpperCase) // res8: List[Char] = List('A', 'P', 'P', 'L', 'E', 'P', 'E', 'A', 'R') val nums = List(5, 1, 3, 11, 7) // nums: List[Int] = List(5, 1, 3, 11, 7) nums.map(_ * 2) // res9: List[Int] = List(10, 2, 6, 22, 14) nums.filter(_ &gt; 3) // res10: List[Int] = List(5, 11, 7) nums.takeWhile(_ &lt; 6) // res11: List[Int] = List(5, 1, 3) nums.sortWith(_ &lt; _) // res12: List[Int] = List(1, 3, 5, 7, 11) nums.sortWith(_ &gt; _) // res13: List[Int] = List(11, 7, 5, 3, 1) nums.takeWhile(_ &lt; 6).sortWith(_ &lt; _) // res14: List[Int] = List(1, 3, 5) References: Scala3 book"
    } ,    
    {
      "title": "Функции",
      "url": "/scalaworkbook/docs/functions.html",
      "content": "Функции В этой главе представлены функции Scala. Рассматриваемые темы включают в себя анонимные функции (лямбды), переменные в функциях и функции высшего порядка (HOF - higher-order functions), в том числе способы создания собственных HOF. Функция высшего порядка (HOF) часто определяется как функция, которая принимает другие функции в качестве входных параметров или возвращает функцию в качестве ее значения. В Scala это возможно, потому что функции являются объектами первого класса. Ключевые моменты, которые здесь рассматриваются: как писать анонимные функции в виде небольших фрагментов кода как передать их в десятки HOF (методов) в классах коллекций, то есть в такие методы, как filter, map и т.д. как с помощью этих небольших фрагментов кода и HOF создать множество функциональных возможностей с помощью всего лишь небольшого кода что функциональные переменные - это просто анонимные функции, которые привязаны к переменной как написать методы, которые принимают функции в качестве входных параметров как вернуть функцию из метода как объявлять сигнатуры типов для функций использование одинакового синтаксиса для определения параметров функций, анонимных функций и функциональных переменных References: Scala3 book"
    } ,    
    {
      "title": "Hello, world!",
      "url": "/scalaworkbook/docs/hello_world.html",
      "content": "Hello, world! Пример Scala “Hello, world!” выглядит следующим образом. Сначала поместите этот код в файл с именем Hello.scala: @main def hello = println(\"Hello, world!\") В этом коде hello - это метод. Он определен с помощью def и объявлен как метод “main” с аннотацией @main. Он выводит строку “Hello, world!” в стандартный вывод (STDOUT) с использованием метода println. Затем скомпилируйте код с помощью scalac: &gt; scalac Hello.scala References: Scala3 book"
    } ,    
    {
      "title": "Функции высшего порядка",
      "url": "/scalaworkbook/docs/functions/hofs.html",
      "content": "Функции высшего порядка Функция высшего порядка (HOF - higher-order function) часто определяется как функция, которая принимает другие функции в качестве входных параметров или возвращает функцию в качестве результата. В Scala HOF возможны, потому что функции являются объектами первого класса. В качестве важного примечания: хотя в этом документе используется общепринятый термин “функция высшего порядка”, в Scala эта фраза применима как к методам, так и к функциям. Благодаря технологии Eta Expansion их, как правило, можно использовать в одних и тех же местах. От потребителя к разработчику В примерах, приведенных ранее в документации, было видно, как пользоваться методами, которые принимают другие функции в качестве входных параметров, например, map и filter. В следующих разделах будет показано, как создавать HOF, в том числе: как писать методы, принимающие функции в качестве входных параметров как возвращать функции из методов В процессе будет видно: синтаксис, который используется для определения входных параметров функции как вызвать функцию, если есть на нее ссылка В качестве полезного побочного эффекта, как только синтаксис станет привычным, его можно начать использовать для определения параметров функций, анонимных функций и функциональных переменных, а также станет легче читать Scaladoc для функций высшего порядка. Понимание Scaladoc метода filter Чтобы понять, как работают функции высшего порядка, рассмотрим пример: определим, какой тип функций принимает filter, взглянув на его Scaladoc. Вот определение filter в классе List[A]: def filter(p: (A) =&gt; Boolean): List[A] Это определение указывает на то, что filter - метод, который принимает параметр функции с именем p. По соглашению, p обозначает предикат, который представляет собой просто функцию, возвращающую Boolean. Таким образом, filter принимает предикат p в качестве входного параметра и возвращает List[A], где A - тип, содержащийся в списке; если filter вызывается для List[Int], то A - это тип Int. На данный момент, если не учитывать назначение метода filter, все, что известно, так это то, что алгоритм каким-то образом использует предикат p для создания и возврата List[A]. Если посмотреть конкретно на параметр функции p: p: (A) =&gt; Boolean, то эта часть описания filter означает, что любая передаваемая функция должна принимать тип A в качестве входного параметра и возвращать Boolean. Итак, если список представляет собой список List[Int], то можно заменить универсальный тип A на Int и прочитать эту подпись следующим образом: p: (Int) =&gt; Boolean. Поскольку isEven имеет такой же тип — преобразует входное значение Int в результирующее Boolean — его можно использовать с filter. Написание методов, которые принимают параметры функции Рассмотрим пример написания методов, которые принимают функции в качестве входных параметров. Для определенности, будем называть код, который пишется, методом, а код, принимаемый в качестве входного параметра, — функцией. Пример Чтобы создать метод, который принимает функцию в качестве параметра, необходимо: в списке параметров метода определить сигнатуру принимаемой функции использовать эту функцию внутри метода Чтобы продемонстрировать это, вот метод, который принимает входной параметр с именем f, где f — функция: def sayHello(f: () =&gt; Unit): Unit = f() Эта часть кода — сигнатура типа (type signature) — утверждает, что f является функцией, и определяет типы функций, которые будет принимать метод sayHello: f: () =&gt; Unit. Как это работает: f — имя входного параметра функции. Аналогично тому, как параметр String обычно называется s или параметр Int - i сигнатура типа f определяет тип функций, которые будет принимать метод часть () подписи f (слева от символа =&gt;) указывает на то, что f не принимает входных параметров часть сигнатуры Unit (справа от символа =&gt;) указывает на то, что функция f не должна возвращать осмысленный результат в теле метода sayHello (справа от символа =) оператор f() вызывает переданную функцию Теперь, когда sayHello определен, создадим функцию, соответствующую сигнатуре f, чтобы ее можно было проверить. Следующая функция не принимает входных параметров и ничего не возвращает, поэтому она соответствует сигнатуре типа f: def helloJoe(): Unit = println(\"Hello, Joe\") Поскольку сигнатуры типов совпадают, можно передать helloJoe в sayHello: sayHello(helloJoe) // Hello, Joe Был определен метод с именем sayHello, который принимает функцию в качестве входного параметра, а затем вызывает эту функцию в теле своего метода. sayHello может принимать разные функции Важно знать, что преимущество этого подхода заключается не в том, что sayHello может принимать одну функцию в качестве входного параметра; преимущество в том, что sayHello может принимать любую функцию, соответствующую сигнатуре f. Например, поскольку следующая функция не принимает входных параметров и ничего не возвращает, она также работает с sayHello: def bonjourJulien(): Unit = println(\"Bonjour, Julien\") sayHello(bonjourJulien) // Bonjour, Julien Рассмотрим ещё несколько примеров того, как определять сигнатуры различных типов для параметров функции. Общий синтаксис для определения входных параметров функции В методе: def sayHello(f: () =&gt; Unit): Unit сигнатурой типа для f является () =&gt; Unit. Это сигнатура означает “функцию, которая не принимает входных параметров и не возвращает ничего значимого (Unit)”. Вот сигнатура функции, которая принимает параметр String и возвращает Int: f: (String) =&gt; Int Какие функции принимают строку и возвращают целое число? Например, такие, как “длина строки” и контрольная сумма. Эта функция принимает два параметра Int и возвращает Int: f: (Int, Int) =&gt; Int Какие функции соответствуют данной сигнатуре? Любая функция, которая принимает два входных параметра Int и возвращает Int, соответствует этой сигнатуре, поэтому все “функции” ниже (точнее, методы) подходят: def add(a: Int, b: Int): Int = a + b def subtract(a: Int, b: Int): Int = a - b def multiply(a: Int, b: Int): Int = a * b Из примеров выше можно сделать вывод, что общий синтаксис сигнатуры функций такой: variableName: (parameterTypes ...) =&gt; returnType Поскольку функциональное программирование похоже на создание и объединение ряда алгебраических уравнений, обычно много думают о типах при разработке функций и приложений. Можно сказать, что «думают типами». Параметр функции вместе с другими параметрами Чтобы HOFs стали действительно полезными, им также нужны некоторые данные для работы. Для класса, подобного List, в его методе map уже есть данные для работы: элементы в List. Но для автономного приложения, у которого нет собственных данных, метод также должен принимать в качестве других входных параметров данные. Рассмотрим пример метода с именем executeNTimes, который имеет два входных параметра: функцию и Int: def executeNTimes(f: () =&gt; Unit, n: Int): Unit = for i &lt;- 1 to n do f() Как видно из кода, executeNTimes выполняет функцию f n раз. Поскольку простой цикл for, подобный этому, не имеет возвращаемого значения, executeNTimes возвращает Unit. Чтобы протестировать executeNTimes, определим метод, соответствующий сигнатуре f: def helloWorld(): Unit = println(\"Hello, world\") Затем передадим этот метод в executeNTimes вместе с Int: executeNTimes(helloWorld, 3) // Hello, world // Hello, world // Hello, world Метод executeNTimes трижды выполняет функцию helloWorld. Столько параметров, сколько необходимо Методы могут усложняться по мере необходимости. Например, этот метод принимает функцию типа (Int, Int) =&gt; Int вместе с двумя входными параметрами: def executeAndPrint(f: (Int, Int) =&gt; Int, i: Int, j: Int): Unit = println(f(i, j)) Поскольку методы sum и multiply соответствуют сигнатуре f, их можно передать в executeAndPrint вместе с двумя значениями Int: def sum(x: Int, y: Int) = x + y def multiply(x: Int, y: Int) = x * y executeAndPrint(sum, 3, 11) // 14 executeAndPrint(multiply, 3, 9) // 27 Согласованность подписи типа функции Самое замечательное в изучении сигнатур типов функций Scala заключается в том, что синтаксис, используемый для определения входных параметров функции, — это тот же синтаксис, что используется для написания литералов функций. Например, если необходимо написать функцию, вычисляющую сумму двух целых чисел, её можно было бы написать так: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b Этот код состоит из сигнатуры типа: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----------------- входных параметров: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ------ и тела функции: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----- Согласованность Scala состоит в том, что тип функции: val f: (Int, Int) =&gt; Int = (a, b) =&gt; a + b ----------------- совпадает с сигнатурой типа, используемого для определения входного параметра функции: def executeAndPrint(f: (Int, Int) =&gt; Int, ... ----------------- По мере освоения этого синтаксиса, становится привычным его использование для определения параметров функций, анонимных функций и функциональных переменных, а также становится легче читать Scaladoc для функций высшего порядка. References: Scala3 book"
    } ,    
    {
      "title": "Неизменяемые значения",
      "url": "/scalaworkbook/docs/fp/immutable-values.html",
      "content": "Неизменяемые значения В чистом функциональном программировании используются только неизменяемые значения. В Scala это означает: все переменные создаются как поля val используются только неизменяемые классы коллекций, такие как List, Vector и неизменяемые классы Map и Set Использование только неизменяемых переменных поднимает интересный вопрос: если все статично, как вообще что-то меняется? Когда дело доходит до использования коллекций, один из ответов заключается в том, что существующая коллекция не меняется; вместо этого функция применяется к коллекции, чтобы создать новую. Именно здесь вступают в действие функции высшего порядка, такие как map и filter. Например, представим, что есть список имен в нижнем регистре — List[String], и необходимо найти все имена, начинающиеся с буквы \"j\", чтобы затем сделать первые буквы заглавными. В ФП код будет выглядеть так: val a = List(\"jane\", \"jon\", \"mary\", \"joe\") // a: List[String] = List(\"jane\", \"jon\", \"mary\", \"joe\") val b = a.filter(_.startsWith(\"j\")) .map(_.capitalize) // b: List[String] = List(\"Jane\", \"Jon\", \"Joe\") Как показано, исходный список a не меняется. Вместо этого к a применяется функция фильтрации и преобразования, чтобы создать новую коллекцию, и результат присваивается неизменяемой переменной b. Точно так же в ФП не используются классы с изменяемыми параметрами конструктора var. В ФП создание такого класса не привествуется: class Person(var firstName: String, var lastName: String) Вместо этого обычно создаются case class-ы, чьи параметры конструктора по умолчанию неизменяемые (val): case class Person(firstName: String, lastName: String) Теперь можно создать экземпляр Person как поле val: val reginald = Person(\"Reginald\", \"Dwight\") // reginald: Person = Person(firstName = \"Reginald\", lastName = \"Dwight\") Затем, при необходимости внести изменения в данные, используется метод copy, который поставляется с case class-ом, чтобы “обновлять данные через создание копии”, например: val elton = reginald.copy( firstName = \"Elton\", lastName = \"John\" ) // elton: Person = Person(firstName = \"Elton\", lastName = \"John\") Существуют множество других приёмов работы с неизменяемыми коллекциями и переменными. В зависимости от задач вместо case class-ов можно создавать enum-ы, trait-ы или классы. Для более подробной информации См. главу “Моделирование данных”. References: Scala3 book"
    } ,    
    {
      "title": "Обзор Scala",
      "url": "/scalaworkbook/docs/",
      "content": "Обзор Scala Цель этой документации - дать неофициальное описание языка Scala на русском языке. В ней относительно легко затрагиваются все темы Scala. Для получения дополнительной информации об описываемой теме внизу страницы даны ссылки на справочную документацию, в которой более подробно рассматриваются многие функции языка Scala. Scala - это красивый, выразительный язык программирования с чистым, современным синтаксисом, который обеспечивает безопасную систему статических типов. Он поддерживает как функциональное программирование, так и объектно-ориентированное программирование. Но основной акцент будет сделан именно на функциональном программировании. Особенности Scala 3 References: Scala home page Scala3 book"
    } ,    
    {
      "title": "Основная",
      "url": "/scalaworkbook/",
      "content": "Описание В этом справочнике изложены основные принципы функциональной разработки на Scala, в том числе с помощью популярных фреймворков. Код написан на версии Scala - 3.1.2. Документация Обзор Scala"
    } ,    
    {
      "title": "main методы",
      "url": "/scalaworkbook/docs/methods/main-methods.html",
      "content": "main методы Scala предлагает следующий способ определения программ, которые можно вызывать из командной строки: добавление аннотации @main к методу превращает его в точку входа исполняемой программы: @main def hello() = println(\"Hello, world\") Достаточно сохранить эту строку кода в файле с именем, например, Hello.scala (имя файла необязательно должно совпадать с именем метода) и скомпилировать его с помощью scalac: $ scalac Hello.scala Затем запустить с помощью scala: $ scala hello Hello, world Аннотированный метод @main может быть написан либо на верхнем уровне (как показано), либо внутри статически доступного объекта. В любом случае имя программы - это имя метода без каких-либо префиксов объектов. Аргументы командной строки Метод @main может обрабатывать аргументы командной строки с разными типами. Например, данный метод @main, который принимает параметры Int, String и дополнительные строковые параметры: @main def happyBirthday(age: Int, name: String, others: String*) = val suffix = (age % 100) match case 11 | 12 | 13 =&gt; \"th\" case _ =&gt; (age % 10) match case 1 =&gt; \"st\" case 2 =&gt; \"nd\" case 3 =&gt; \"rd\" case _ =&gt; \"th\" val sb = StringBuilder(s\"Happy $age$suffix birthday, $name\") for other &lt;- others do sb.append(\" and \").append(other) sb.toString После компиляции кода создается основная программа с именем happyBirthday, которая вызывается следующим образом: $ scala happyBirthday 23 Lisa Peter Happy 23rd Birthday, Lisa and Peter! Как показано, метод @main может иметь произвольное количество параметров. Для каждого типа параметра должен быть экземпляр scala.util.FromString, который преобразует аргумент из String в требуемый тип параметра. Также, как показано, список параметров основного метода может заканчиваться повторяющимся параметром типа String*, который принимает все оставшиеся аргументы, указанные в командной строке. Программа, реализованная с помощью метода @main, проверяет, что в командной строке достаточно аргументов для заполнения всех параметров, и что строки аргументов могут быть преобразованы в требуемые типы. Если проверка завершается неудачей, программа завершается с сообщением об ошибке: $ scala happyBirthday 22 Illegal command line after first argument: more arguments expected $ scala happyBirthday sixty Fred Illegal command line: java.lang.NumberFormatException: For input string: \"sixty\" Детали Компилятор Scala генерирует программу из @main метода f следующим образом: он создает класс с именем f в пакете, где был найден метод @main. класс имеет статический метод main с обычной сигнатурой Java main метода: принимает Array[String] в качестве аргумента и возвращает Unit. сгенерированный main метод вызывает метод f с аргументами, преобразованными с помощью методов в объекте scala.util.CommandLineParser. Например, приведенный выше метод happyBirthday генерирует дополнительный код, эквивалентный следующему классу: final class happyBirthday { import scala.util.{CommandLineParser as CLP} &lt;static&gt; def main(args: Array[String]): Unit = try happyBirthday( CLP.parseArgument[Int](args, 0), CLP.parseArgument[String](args, 1), CLP.parseRemainingArguments[String](args, 2)) catch { case error: CLP.ParseError =&gt; CLP.showError(error) } } Примечание: В этом сгенерированном коде модификатор &lt;static&gt; выражает, что main метод генерируется как статический метод класса happyBirthday. Эта функция недоступна для пользовательских программ в Scala. Вместо неё обычные “статические” члены генерируются в Scala с использованием object. @main методы — это рекомендуемый способ создания программ, вызываемых из командной строки в Scala 3. Они заменяют предыдущий подход, который заключался в создании объекта, расширяющего класс App. References: Scala3 book Scala3 book, main Methods"
    } ,    
    {
      "title": "Особенности методов",
      "url": "/scalaworkbook/docs/methods/method-features.html",
      "content": "Особенности методов В этом разделе представлены различные аспекты определения и вызова методов. Определение методов Методы Scala имеют много особенностей, в том числе следующие: Generic параметры Значения параметров по умолчанию Несколько групп параметров Контекстные параметры Параметры по имени (by name parameters) … Синтаксис простого метода выглядит следующим образом: def methodName(param1: Type1, param2: Type2): ReturnType = // здесь тело метода end methodName // опционально, можно не указывать В этом синтаксисе: ключевое слово def используется для определения метода для наименования методов согласно стандартам Scala используется camel case convention у параметров метода необходимо всегда указывать тип возвращаемый тип метода указывать необязательно методы могут состоять как только из одной строки, так и из нескольких строк метку окончания метода end methodName указывать необязательно, её рекомендуется указывать только для длинных методов Вот два примера однострочного метода с именем add, который принимает два входных параметра Int. Первая версия явно показывает возвращаемый тип метода - Int, а вторая - нет: def add(a: Int, b: Int): Int = a + b def add(a: Int, b: Int) = a + b У публичных методов рекомендуется всегда указывать тип возвращаемого значения. Объявление возвращаемого типа может упростить его понимание при просмотре кода другого человека или своего кода спустя некоторое время. Вызов методов Вызов методов прост: val x = add(1, 2) Коллекции Scala имеют десятки встроенных методов. Эти примеры показывают, как их вызывать: val x = List(1, 2, 3) // x: List[Int] = List(1, 2, 3) x.size // res1: Int = 3 x.contains(1) // res2: Boolean = true x.map(_ * 10) // res3: List[Int] = List(10, 20, 30) Внимание: size не принимает аргументов и возвращает количество элементов в списке метод contains принимает один аргумент — значение для поиска map принимает один аргумент - функцию; в данном случае в него передается анонимная функция Многострочные методы Если метод длиннее одной строки, начинайте тело метода со второй строки с отступом вправо: def addThenDouble(a: Int, b: Int): Int = val sum = a + b sum * 2 addThenDouble(1, 1) // res5: Int = 4 В этом методе: sum — неизменяемая локальная переменная; к ней нельзя получить доступ вне метода последняя строка удваивает значение sum - именно это значение возвращается из метода Обратите внимание, что нет необходимости в операторе return в конце метода. Поскольку почти все в Scala является выражением — то это означает, что каждая строка кода возвращает (или вычисляет) значение — нет необходимости использовать return. Это видно на примере того же метода, но в более сжатой форме: def addThenDouble(a: Int, b: Int): Int = (a + b) * 2 В теле метода можно использовать все возможности Scala: if/else выражения match выражения циклы while циклы for и for выражения присвоение переменных вызовы других методов определения других методов В качестве ещё одного примера многострочного метода, getStackTraceAsString преобразует свой входной параметр Throwable в правильно отформатированную строку: def getStackTraceAsString(t: Throwable): String = val sw = StringWriter() t.printStackTrace(PrintWriter(sw)) sw.toString В этом методе: в первой строке переменная sw принимает значение нового экземпляра StringWriter вторая строка сохраняет содержимое трассировки стека в StringWriter третья строка возвращает строковое представление трассировки стека Параметры по умолчанию В параметрах метода можно указывать значения по умолчанию. В этом примере значения по умолчанию заданы как для timeout, так и для protocol: def makeConnection(timeout: Int = 5_000, protocol: String = \"http\") = println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\") Поскольку параметры имеют значения по умолчанию, метод можно вызвать следующими способами: makeConnection() // timeout = 5000, protocol = http makeConnection(2_000) // timeout = 2000, protocol = http makeConnection(3_000, \"https\") // timeout = 3000, protocol = https Ключевые моменты: в первом примере метод вызывается без аргументов, поэтому он использует значения параметров по умолчанию: 5_000 и http во втором примере для значения timeout указано 2_000 - оно используется вместе со значением по умолчанию для protocol в третьем примере указаны значения для обоих параметров, поэтому используются именно они Обратите внимание, что при использовании значений параметров по умолчанию создается впечатление, что используются три разных переопределенных метода. Именованные параметры При вызове метода при желании можно использовать имена параметров. Например, makeConnection также можно вызывать следующими способами: makeConnection(timeout=10_000) // timeout = 10000, protocol = http makeConnection(protocol=\"https\") // timeout = 5000, protocol = https makeConnection(timeout=10_000, protocol=\"https\") // timeout = 10000, protocol = https makeConnection(protocol=\"https\", timeout=10_000) // timeout = 10000, protocol = https Именованные параметры особенно полезны, когда несколько параметров метода имеют один и тот же тип. Без помощи IDE очень сложно понять, какие параметры установлены в значение true или false, и поэтому код может быть трудночитаемым: engage(true, true, true, false) Гораздо более понятным выглядит использование именованных переменных: engage( speedIsSet = true, directionIsSet = true, picardSaidMakeItSo = true, turnedOffParkingBrake = false ) Рекомендации о методах, которые не принимают параметров Когда метод не принимает параметров, говорят, что он имеет arity уровень 0 (arity-0). Аналогично, если метод принимает один параметр - это метод с arity-1. Когда создаются методы arity-0: если метод выполняет побочные эффекты, такие как вызов println, метод объявляется с пустыми скобками. если метод не выполняет побочных эффектов, например, получение размера коллекции, что аналогично доступу к полю в коллекции, круглые скобки опускаются. Например, этот метод выполняет побочный эффект, поэтому он объявлен с пустыми скобками: def speak() = println(\"hi\") При вызове метода нужно обязательно указывать круглые скобки, если он был объявлен с ними: speak // error: \"method speak must be called with () argument\" speak() // prints \"hi\" Хотя это всего лишь соглашение, его соблюдение значительно улучшает читаемость кода: с первого взгляда становится понятно, что метод с arity-0 имеет побочные эффекты. Использование if в качестве тела метода Поскольку выражения if/else возвращают значение, их можно использовать в качестве тела метода. Вот метод с именем isTruthy, реализующий Perl-определения true и false: def isTruthy(a: Any) = if a == 0 || a == \"\" || a == false then false else true Примеры показывают, как работает метод: isTruthy(0) // res13: Boolean = false isTruthy(\"\") // res14: Boolean = false isTruthy(\"hi\") // res15: Boolean = true isTruthy(1.0) // res16: Boolean = true Использование match в качестве тела метода Довольно часто в качестве тела метода используются match-выражения. Вот еще одна версия isTruthy, написанная с match выражением: def isTruthy(a: Matchable) = a match case 0 | \"\" | false =&gt; false case _ =&gt; true Этот метод работает точно так же, как и предыдущий, в котором использовалось выражение if/else. Вместо Any в качестве типа параметра используется Matchable, чтобы принять любое значение, поддерживающее сопоставление с образцом (pattern matching). Контроль видимости методов в классах В классах, объектах, trait-ах и enum-ах методы Scala по умолчанию общедоступны, поэтому созданный здесь экземпляр Dog может получить доступ к методу speak: class Dog: def speak() = println(\"Woof\") val d = new Dog // d: Dog = repl.MdocSession$App4$Dog@611ff350 d.speak() // Woof Также методы можно помечать как private. Это делает их закрытыми в текущем классе, поэтому их нельзя вызвать или переопределить в подклассах: class Animal: private def breathe() = println(\"I’m breathing\") class Cat extends Animal: // this method won’t compile override def breathe() = println(\"Yo, I’m totally breathing\") Если необходимо сделать метод закрытым в текущем классе, но разрешить подклассам вызывать или переопределять его, метод помечается как protected, как показано в примере с методом speak: class Animal: private def breathe() = println(\"I’m breathing\") def walk() = breathe() println(\"I’m walking\") protected def speak() = println(\"Hello?\") class Cat extends Animal: override def speak() = println(\"Meow\") val cat = new Cat cat.walk() cat.speak() cat.breathe() // won’t compile because it’s private Настройка protected означает: к методу (или полю) могут обращаться другие экземпляры того же класса метод (или поле) не виден в текущем пакете он доступен для подклассов Методы в объектах Ранее было показано, что trait-ы и классы могут иметь методы. Ключевое слово object используется для создания одноэлементного класса, и object также может содержать методы. Это хороший способ сгруппировать набор “служебных” методов. Например, этот объект содержит набор методов, которые работают со строками: object StringUtils: def truncate(s: String, length: Int): String = s.take(length) def lettersAndNumbersOnly_?(s: String): Boolean = s.matches(\"[a-zA-Z0-9]+\") def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\") end StringUtils Расширяемые методы Основная цель расширяемых методов (extension methods) - позволить добавлять новые функциональные возможности в закрытые классы. Представим, что у нас есть класс Circle, но мы не можем изменить его исходный код. Например, он может быть определен следующим образом в сторонней библиотеке: case class Circle(x: Double, y: Double, radius: Double) Если необходимо добавить методы в этот класс, можно их определить как методы расширения, например: extension (c: Circle) def circumference: Double = c.radius * math.Pi * 2 def diameter: Double = c.radius * 2 def area: Double = math.Pi * c.radius * c.radius Ключевое слово extension объявляет о намерении определить один или несколько методов расширения для параметра, заключенного в круглые скобки. Как показано в примере выше, параметры типа Circle затем могут быть использованы в теле методов расширения. Теперь, если есть экземпляр Circle с именем aCircle, можно вызвать эти методы следующим образом: val aCircle = Circle(0.0, 0.0, 1.0) // aCircle: Circle = Circle(x = 0.0, y = 0.0, radius = 1.0) aCircle.circumference // res18: Double = 6.283185307179586 aCircle.diameter // res19: Double = 2.0 aCircle.area // res20: Double = 3.141592653589793 Дополнительно В дальнейшем будет раскрыто еще больше информации о методах, в том числе: вызов методов суперкласса определение и использование параметров по имени (by-name parameters) метод, который принимает функцию inline методы обработка исключений использование изменяемых параметров метода методы, которые имеют несколько групп параметров (частично применяемые функции) методы с generic параметрами References: Scala3 book Scala3 book, Method Features"
    } ,    
    {
      "title": "Методы в коллекциях",
      "url": "/scalaworkbook/docs/collections/methods.html",
      "content": "Методы в коллекциях Важным преимуществом коллекций Scala является то, что они поставляются с десятками методов “из коробки”, которые доступны для неизменяемых и изменяемых типов коллекций. Больше нет необходимости писать пользовательские циклы for каждый раз, когда нужно работать с коллекцией. При переходе от одного проекта к другому, можно обнаружить, что используются одни и те же методы. В коллекциях доступны десятки методов, поэтому здесь показаны не все из них. Показаны только некоторые из наиболее часто используемых методов, в том числе: map filter foreach head tail take, takeWhile drop, dropWhile reduce Следующие методы работают со всеми типами последовательностей, включая List, Vector, ArrayBuffer и т. д.. Примеры рассмотрены на List-е, если не указано иное. Важно напомнить, что ни один из методов в List не изменяет список. Все они работают в функциональном стиле, то есть возвращают новую коллекцию с измененными результатами. Примеры распространенных методов Для общего представления в примерах ниже показаны некоторые из наиболее часто используемых методов коллекций. Вот несколько методов, которые не используют лямбда-выражения: val a = List(10, 20, 30, 40, 10) // a: List[Int] = List(10, 20, 30, 40, 10) a.distinct // res0: List[Int] = List(10, 20, 30, 40) a.drop(2) // res1: List[Int] = List(30, 40, 10) a.dropRight(2) // res2: List[Int] = List(10, 20, 30) a.head // res3: Int = 10 a.headOption // res4: Option[Int] = Some(value = 10) a.init // res5: List[Int] = List(10, 20, 30, 40) a.intersect(List(19,20,21)) // res6: List[Int] = List(20) a.last // res7: Int = 10 a.lastOption // res8: Option[Int] = Some(value = 10) a.slice(2,4) // res9: List[Int] = List(30, 40) a.tail // res10: List[Int] = List(20, 30, 40, 10) a.take(3) // res11: List[Int] = List(10, 20, 30) a.takeRight(2) // res12: List[Int] = List(40, 10) Функции высшего порядка и лямбда-выражения Далее будут показаны некоторые часто используемые функции высшего порядка (HOF), которые принимают лямбды (анонимные функции). Для начала приведем несколько вариантов лямбда-синтаксиса, начиная с самой длинной формы, поэтапно переходящей к наиболее сжатой: a.filter((i: Int) =&gt; i &lt; 25) // res13: List[Int] = List(10, 20, 10) a.filter((i) =&gt; i &lt; 25) // res14: List[Int] = List(10, 20, 10) a.filter(i =&gt; i &lt; 25) // res15: List[Int] = List(10, 20, 10) a.filter(_ &lt; 25) // res16: List[Int] = List(10, 20, 10) В этих примерах: Первый пример показывает самую длинную форму. Такое многословие требуется редко, только в самых сложных случаях. Компилятор знает, что a содержит Int, поэтому нет необходимости повторять это в функции. Если в функции только один параметр, например i, то скобки не нужны. В случае одного параметра, если он появляется в анонимной функции только раз, его можно заменить на _. В главе Анонимные функции представлена более подробная информация и примеры правил, связанных с сокращением лямбда-выражений. Примеры других HOF, использующих краткий лямбда-синтаксис: a.dropWhile(_ &lt; 25) // res17: List[Int] = List(30, 40, 10) a.filter(_ &gt; 35) // res18: List[Int] = List(40) a.filterNot(_ &lt; 25) // res19: List[Int] = List(30, 40) a.find(_ &gt; 20) // res20: Option[Int] = Some(value = 30) a.takeWhile(_ &lt; 30) // res21: List[Int] = List(10, 20) Важно отметить, что HOF также принимают в качестве параметров методы и функции, а не только лямбда-выражения. Вот несколько примеров, в которых используется метод с именем double. Снова показаны несколько вариантов лямбда-выражений: def double(i: Int) = i * 2 a.map(i =&gt; double(i)) // res22: List[Int] = List(20, 40, 60, 80, 20) a.map(double(_)) // res23: List[Int] = List(20, 40, 60, 80, 20) a.map(double) // res24: List[Int] = List(20, 40, 60, 80, 20) В последнем примере, когда анонимная функция состоит из одного вызова функции, принимающей один аргумент, нет необходимости указывать имя аргумента, поэтому даже _ не требуется. Наконец, HOF можно комбинировать: a.filter(_ &lt; 40) .takeWhile(_ &lt; 30) .map(_ * 10) // res25: List[Int] = List(100, 200) P.S. Пример призван показать только то, как принято последовательно вызывать функции на неизменяемых коллекциях. Его недостаток в том, что обход коллекции происходит целых три раза. Пример данных В следующих разделах используются следующие списки: val oneToTen = (1 to 10).toList // oneToTen: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val names = List(\"adam\", \"brandy\", \"chris\", \"david\") // names: List[String] = List(\"adam\", \"brandy\", \"chris\", \"david\") map Метод map проходит через каждый элемент в списке, применяя переданную функцию к элементу, по одному за раз; затем возвращается новый список с измененными элементами. Вот пример применения метода map к списку oneToTen: val doubles = oneToTen.map(_ * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) Также можно писать анонимные функции, используя более длинную форму, например: val doubles = oneToTen.map(i =&gt; i * 2) // doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) Однако в этом документе будет всегда использоваться первая, более короткая форма. Вот еще несколько примеров применения метода map к oneToTen и names: val capNames = names.map(_.capitalize) // capNames: List[String] = List(\"Adam\", \"Brandy\", \"Chris\", \"David\") val nameLengthsMap = names.map(s =&gt; (s, s.length)).toMap // nameLengthsMap: Map[String, Int] = Map(\"adam\" -&gt; 4, \"brandy\" -&gt; 6, \"chris\" -&gt; 5, \"david\" -&gt; 5) val isLessThanFive = oneToTen.map(_ &lt; 5) // isLessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false) Как показано в последних двух примерах, совершенно законно (и распространено) использование map для возврата коллекции, которая имеет тип, отличный от исходного типа. filter Метод filter создает новый список, содержащий только те элементы, которые удовлетворяют предоставленному предикату. Предикат или условие — это функция, которая возвращает Boolean (true или false). Вот несколько примеров: val lessThanFive = oneToTen.filter(_ &lt; 5) // lessThanFive: List[Int] = List(1, 2, 3, 4) val evens = oneToTen.filter(_ % 2 == 0) // evens: List[Int] = List(2, 4, 6, 8, 10) val shortNames = names.filter(_.length &lt;= 4) // shortNames: List[String] = List(\"adam\") Отличительной особенностью функциональных методов коллекций является то, что их можно объединять вместе для решения задач. Например, в этом примере показано, как связать filter и map: oneToTen.filter(_ &lt; 4).map(_ * 10) // res26: List[Int] = List(10, 20, 30) Если filter используется перед map, flatMap или foreach, то для лучшей производительности он заменяется на withFilter, например, oneToTen.withFilter(_ &lt; 4).map(_ * 10) foreach Метод foreach используется для перебора всех элементов коллекции. Стоит обратить внимание, что foreach используется для побочных эффектов, таких как печать информации. Вот пример с names: names.foreach(println) // adam // brandy // chris // david head Метод head взят из Lisp и других более ранних языков функционального программирования. Он используется для доступа к первому элементу (головному (head) элементу) списка: oneToTen.head // res28: Int = 1 names.head // res29: String = \"adam\" String можно рассматривать как последовательность символов, т.е. строка также является коллекцией и имеет многие методы коллекций. Вот как head работает со строками: \"foo\".head // res30: Char = 'f' \"bar\".head // res31: Char = 'b' На пустой коллекции head выдает исключение: val emptyList = List[Int]() // emptyList: List[Int] = List() emptyList.head // java.util.NoSuchElementException: head of empty list // at scala.collection.immutable.Nil$.head(List.scala:662) // at scala.collection.immutable.Nil$.head(List.scala:661) // at repl.MdocSession$App.$init$$$anonfun$17(methods.md:252) Чтобы не натыкаться на исключение вместо head желательно использовать headOption, особенно при разработке в функциональном стиле: emptyList.headOption // res32: Option[Int] = None headOption не генерирует исключение, а возвращает тип Option со значением None. Более подробно о функциональном стиле программирования будет рассказано в соответствующей главе. tail Метод tail также взят из Lisp и используется для вывода всех элементов в списке после head. oneToTen.head // res33: Int = 1 oneToTen.tail // res34: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10) names.head // res35: String = \"adam\" names.tail // res36: List[String] = List(\"brandy\", \"chris\", \"david\") Так же, как и head, tail можно использовать со строками: \"foo\".tail // res37: String = \"oo\" \"bar\".tail // res38: String = \"ar\" tail выбрасывает исключение java.lang.UnsupportedOperationException, если список пуст, поэтому, как и в случае с head и headOption, существует также метод tailOption, который предпочтительнее в функциональном программировании. Список матчится, поэтому можно использовать такие выражения: val x :: xs = names // x: String = \"adam\" // xs: List[String] = List(\"brandy\", \"chris\", \"david\") x - это head списка, а xs - tail. Подобный pattern matching полезен во многих случаях, например, при написании метода суммирования с использованием рекурсии: def sum(list: List[Int]): Int = list match case Nil =&gt; 0 case x :: xs =&gt; x + sum(xs) take, takeRight, takeWhile Методы take, takeRight и takeWhile предоставляют удобный способ “брать” (take) элементы из списка для создания нового. Примеры take и takeRight: oneToTen.take(1) // res39: List[Int] = List(1) oneToTen.take(2) // res40: List[Int] = List(1, 2) oneToTen.takeRight(1) // res41: List[Int] = List(10) oneToTen.takeRight(2) // res42: List[Int] = List(9, 10) Обратите внимание, как эти методы работают с «пограничными» случаями, когда запрашивается больше элементов, чем есть в последовательности, или запрашивается ноль элементов: oneToTen.take(Int.MaxValue) // res43: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.takeRight(Int.MaxValue) // res44: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.take(0) // res45: List[Int] = List() oneToTen.takeRight(0) // res46: List[Int] = List() А это takeWhile, который работает с функцией-предикатом: oneToTen.takeWhile(_ &lt; 5) // res47: List[Int] = List(1, 2, 3, 4) names.takeWhile(_.length &lt; 5) // res48: List[String] = List(\"adam\") drop, dropRight, dropWhile drop, dropRight и dropWhile удаляют элементы из списка и, по сути, противоположны своим аналогам “take”. Вот некоторые примеры: oneToTen.drop(1) // res49: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.drop(5) // res50: List[Int] = List(6, 7, 8, 9, 10) oneToTen.dropRight(8) // res51: List[Int] = List(1, 2) oneToTen.dropRight(7) // res52: List[Int] = List(1, 2, 3) Пограничные случаи: oneToTen.drop(Int.MaxValue) // res53: List[Int] = List() oneToTen.dropRight(Int.MaxValue) // res54: List[Int] = List() oneToTen.drop(0) // res55: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) oneToTen.dropRight(0) // res56: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) А это dropWhile, который работает с функцией-предикатом: oneToTen.dropWhile(_ &lt; 5) // res57: List[Int] = List(5, 6, 7, 8, 9, 10) names.dropWhile(_ != \"chris\") // res58: List[String] = List(\"chris\", \"david\") reduce Метод reduce позволяет свертывать коллекцию до одного агрегируемого значения. Он принимает функцию (или анонимную функцию) и последовательно применяет эту функцию к элементам в списке. Лучший способ объяснить reduce — создать небольшой вспомогательный метод. Например, метод add, который складывает вместе два целых числа, а также предоставляет хороший вывод отладочной информации: def add(x: Int, y: Int): Int = val theSum = x + y println(s\"received $x and $y, their sum is $theSum\") theSum Рассмотрим список: val a = List(1,2,3,4) вот что происходит, когда в reduce передается метод add: a.reduce(add) // received 1 and 2, their sum is 3 // received 3 and 3, their sum is 6 // received 6 and 4, their sum is 10 // res59: Int = 10 Как видно из результата, функция reduce использует add для сокращения списка a до единственного значения, в данном случае — суммы всех чисел в списке. reduce можно использовать с анонимными функциями: a.reduce(_ + _) // res60: Int = 10 Аналогично можно использовать другие функции, например, перемножение всех чисел: a.reduce(_ * _) // res61: Int = 24 Дальнейшее изучение коллекций В коллекциях Scala есть десятки дополнительных методов, которые избавят от необходимости писать еще один цикл for. Более подробную информацию о коллекциях Scala см. в разделе Изменяемые и неизменяемые коллекции и Архитектура коллекций Scala. А также в API. В качестве последнего примечания, при использовании Java-кода в проекте Scala, коллекции Java можно преобразовать в коллекции Scala. После этого, их можно использовать в выражениях for, а также воспользоваться преимуществами методов функциональных коллекций Scala. Более подробную информацию можно найти в разделе Взаимодействие с Java. References: Scala3 book Scala3 book, Collections Methods Изменяемые и неизменяемые коллекции Архитектура коллекций Scala collections API"
    } ,    
    {
      "title": "Методы",
      "url": "/scalaworkbook/docs/methods.html",
      "content": "Методы Scala classes, case classes, case objects, traits, enums, и objects могут содержать методы. Кроме того, они могут быть определены вне любой из перечисленных конструкций. Методы являются определениями “верхнего уровня”, поскольку не вложены в другое определение. Проще говоря, методы теперь могут быть определены где угодно. Многие особенности методов продемонстрированы в следующем разделе. Отдельно выделен раздел для main методов. References: Scala3 book"
    } ,    
    {
      "title": "Моделирование данных",
      "url": "/scalaworkbook/docs/modeling.html",
      "content": "Моделирование данных В этой главе показано моделирование данных с помощью Scala 3: в разделе “Инструменты” представлены доступные инструменты, включая class-ы, trait-ы, enum-ы и многое другое в разделе “Моделирование ООП” рассматриваются атрибуты и поведение моделирования в стиле объектно-ориентированного программирования (ООП) в разделе “Моделирование ФП” рассматривается моделирование предметной области в стиле функционального программирования (ФП) References: Scala3 book"
    } ,    
    {
      "title": "Моделирование ООП",
      "url": "/scalaworkbook/docs/modeling/oop.html",
      "content": "Моделирование ООП Введение Scala предоставляет все необходимые инструменты для объектно-ориентированного проектирования: Traits позволяют указывать (абстрактные) интерфейсы, а также конкретные реализации. Mixin Composition предоставляет инструменты для создания компонентов из более мелких деталей. Классы могут реализовывать интерфейсы, заданные traits. Экземпляры классов могут иметь свое собственное приватное состояние. Subtyping позволяет использовать экземпляр одного класса там, где ожидается экземпляр его суперкласса. Модификаторы доступа позволяют управлять, к каким членам класса можно получить доступ с помощью какой части кода. Traits Возможно, в отличие от других языков программирования с поддержкой ООП таких, как Java, основным инструментом декомпозиции в Scala являются не классы, а traits. Они могут служить для описания абстрактных интерфейсов, таких как: trait Showable: def show: String , а также могут содержать конкретные реализации: trait Showable: def show: String def showHtml = \"&lt;p&gt;\" + show + \"&lt;/p&gt;\" На примере видно, что метод showHtml определяется в терминах абстрактного метода show. Odersky и Zenger представляют сервис-ориентированную компонентную модель и рассматривают: абстрактные члены как требуемые службы: их все еще необходимо реализовать в подклассе. конкретные члены как предоставляемые услуги: они предоставляются подклассу. Это видно на примере со Showable: определяя класс Document, который расширяет Showable, все еще нужно определить show, но showHtml уже предоставляется: class Document(text: String) extends Showable: def show = text Абстрактные методы Абстрактными в trait могут оставаться не только методы. trait может содержать: абстрактные методы (def m(): T) абстрактные переменные (val x: T) абстрактные типы (type T), потенциально с ограничениями (type T &lt;: S) абстрактные given (given t: T) - подробнее об given в следующих главах Каждая из вышеперечисленных функций может быть использована для определения той или иной формы требований к реализатору trait. Mixin Composition Кроме того, что trait-ы могут содержать абстрактные и конкретные определения, Scala также предоставляет мощный способ создания нескольких trait: структура, которую часто называют смешанной композицией. Предположим, что следующие два (потенциально независимо определенные) trait-а: trait GreetingService: def translate(text: String): String def sayHello = translate(\"Hello\") trait TranslationService: def translate(text: String): String = \"...\" Чтобы скомпоновать два сервиса, можно просто создать новый trait, расширяющий их: trait ComposedService extends GreetingService, TranslationService Абстрактные элементы в одном trait-е (например, translate в GreetingService) автоматически сопоставляются с конкретными элементами в другом trait-е. Это работает не только с методами, как в этом примере, но и со всеми другими абстрактными членами, упомянутыми выше (то есть типами, переменными и т.д.). Классы trait-ы отлично подходят для модуляции компонентов и описания интерфейсов (обязательных и предоставляемых). Но в какой-то момент возникнет необходимость создавать их экземпляры. При разработке программного обеспечения в Scala часто бывает полезно рассмотреть возможность использования классов только на начальных этапах модели наследования: Traits - T1, T2, T3 Composed traits - S extends T1, T2, S extends T2, T3 Classes - C extends S, T3 Instances - C() Это еще более актуально в Scala 3, где trait-ы теперь также могут принимать параметры конструктора, что еще больше устраняет необходимость в классах. Определение класса Подобно trait-ам, классы могут расширять несколько trait-ов (но только один суперкласс): class MyService(name: String) extends ComposedService, Showable: def show = s\"$name says $sayHello\" Subtyping Экземпляр MyService создается следующим образом: val s1: MyService = MyService(\"Service 1\") С помощью подтипов экземпляр s1 можно использовать везде, где ожидается любое из расширенных свойств: val s2: GreetingService = s1 val s3: TranslationService = s1 val s4: Showable = s1 // ... и т.п. ... Планирование расширения Как упоминалось ранее, можно расширить еще один класс: class Person(name: String) class SoftwareDeveloper(name: String, favoriteLang: String) extends Person(name) Однако, поскольку trait-ы разработаны как основное средство декомпозиции, класс, определенный в одном файле, не может быть расширен в другом файле. Чтобы разрешить это, базовый класс должен быть помечен как открытый: open class Person(name: String) Маркировка классов с помощью open - это новая функция Scala 3. Необходимость явно помечать классы как открытые позволяет избежать многих распространенных ошибок в ООП. В частности, это требует, чтобы разработчики библиотек явно планировали расширение и, например, документировали классы, помеченные как открытые. Экземпляры и приватное изменяемое состояние Как и в других языках с поддержкой ООП, trait-ы и классы в Scala могут определять изменяемые поля: class Counter: private var currentCount = 0 def tick(): Unit = currentCount += 1 def count: Int = currentCount Каждый экземпляр класса Counter имеет собственное приватное состояние, которое можно наблюдать только через метод count, как показано в следующем примере: val c1 = Counter() c1.count // res1: Int = 0 c1.tick() c1.tick() c1.count // res4: Int = 2 Модификаторы доступа По умолчанию все определения элементов в Scala являются общедоступными. Чтобы скрыть детали реализации, можно определить элементы (методы, поля, типы и т.д.) как private или protected. Таким образом можно контролировать, как к ним обращаются или как их переопределяют. Закрытые (private) члены видны только самому классу/trait-у и его сопутствующему объекту. Защищенные (protected) члены также видны подклассам класса. Дополнительный пример: сервис-ориентированный дизайн Далее будут проиллюстрированы некоторые расширенные возможности Scala и показано, как их можно использовать для структурирования более крупных программных компонентов. Примеры взяты из статьи Мартина Одерски и Маттиаса Зенгера Масштабируемые компонентные абстракции. Пример в первую очередь предназначен для демонстрации того, как использовать несколько функций типа для создания более крупных компонентов. Цель состоит в том, чтобы определить программный компонент с семейством типов, которые могут быть уточнены позже при реализации компонента. Конкретно, следующий код определяет компонент SubjectObserver как trait с двумя членами абстрактного типа, S (для субъектов) и O (для наблюдателей): trait SubjectObserver: type S &lt;: Subject type O &lt;: Observer trait Subject { self: S =&gt; private var observers: List[O] = List() def subscribe(obs: O): Unit = observers = obs :: observers def publish() = for obs &lt;- observers do obs.notify(this) } trait Observer { def notify(sub: S): Unit } Есть несколько вещей, которые нуждаются в объяснении. Члены абстрактного типа Тип объявления S &lt;: Subject говорит, что внутри trait SubjectObserver можно ссылаться на некоторый неизвестный (то есть абстрактный) тип, который называется S. Однако этот тип не является полностью неизвестным: мы знаем, по крайней мере, что это какой-то подтип Subject. Все trait-ы и классы, расширяющие SubjectObserver, могут свободно выбирать любой тип для S, если выбранный тип является подтипом Subject. Часть &lt;: Subject декларации также упоминается как верхняя граница на S. Вложенные trait-ы В рамках trait-а SubjectObserver определяются два других trait-а. trait Observer, который определяет только один абстрактный метод notify с одним аргументом типа S. Как будет видно, важно, чтобы аргумент имел тип S, а не тип Subject. Второй trait, Subject, определяет одно приватное поле observers для хранения всех наблюдателей, подписавшихся на этот конкретный объект. Подписка на объект просто сохраняет объект в списке. Опять же, тип параметра obs - это O, а не Observer. Аннотации собственного типа Наконец, что означает self: S =&gt; в trait-е Subject? Это называется аннотацией собственного типа. И требует, чтобы подтипы Subject также были подтипами S. Это необходимо, чтобы иметь возможность вызывать obs.notify с this в качестве аргумента, поскольку для этого требуется значение типа S. Если бы S был конкретным типом, аннотацию собственного типа можно было бы заменить на trait Subject, расширяющий S. Реализация компонента Теперь можно реализовать вышеуказанный компонент и определить члены абстрактного типа как конкретные типы: object SensorReader extends SubjectObserver: type S = Sensor type O = Display class Sensor(val label: String) extends Subject: private var currentValue = 0.0 def value = currentValue def changeValue(v: Double) = currentValue = v publish() class Display extends Observer: def notify(sub: Sensor) = println(s\"${sub.label} has value ${sub.value}\") В частности, мы определяем singleton object SensorReader, который расширяет SubjectObserver. В реализации SensorReader говорится, что type S теперь определяется как type Sensor, а type O определяется как type Display. И Sensor, и Display определяются как вложенные классы в SensorReader, реализующие trait-ы Subject и Observer соответственно. Помимо того, что этот код является примером сервис-ориентированного дизайна, он также освещает многие аспекты объектно-ориентированного программирования: Класс Sensor вводит свое собственное частное состояние (currentValue) и инкапсулирует изменение состояния за методом changeValue. Реализация changeValue использует метод publish, определенный в родительском trait-е. Класс Display расширяет trait Observer и реализует отсутствующий метод notify. Важно отметить, что реализация notify может безопасно получить доступ только к label и value sub, поскольку мы изначально объявили параметр типа S. Использование компонента Наконец, следующий код иллюстрирует, как использовать компонент SensorReader: import SensorReader.* // настройка сети val s1 = Sensor(\"sensor1\") val s2 = Sensor(\"sensor2\") val d1 = Display() val d2 = Display() s1.subscribe(d1) s1.subscribe(d2) s2.subscribe(d1) // распространение обновлений по сети s1.changeValue(2) // sensor1 has value 2.0 // sensor1 has value 2.0 s2.changeValue(3) // sensor2 has value 3.0 Имея под рукой все утилиты объектно-ориентированного программирования, в следующем разделе будет продемонстрировано, как разрабатывать программы в функциональном стиле. References: Scala3 book, domain modeling oop Scala3 book, taste modeling Scala3 book, taste objects Odersky and Zenger. Scalable component abstractions"
    } ,    
    {
      "title": "Распределение по пакетам и импорт",
      "url": "/scalaworkbook/docs/packaging.html",
      "content": "Распределение по пакетам и импорт Scala использует packages для создания пространств имен, которые позволяют модульно разбивать программы. Scala поддерживает стиль именования пакетов, используемый в Java, а также нотацию пространства имен “фигурные скобки”, используемую такими языками, как C++ и C#. Подход Scala к импорту похож на Java, но более гибкий. С помощью Scala можно: импортировать пакеты, классы, объекты, trait-ы и методы размещать операторы импорта в любом месте скрывать и переименовывать участников при импорте Эти особенности демонстрируются в следующих примерах. Создание пакета Пакеты создаются путем объявления одного или нескольких имен пакетов в начале файла Scala. Например, если ваше доменное имя acme.com и вы работаете с пакетом model приложения с именем myapp, объявление пакета выглядит следующим образом: package com.acme.myapp.model class Person ... По соглашению все имена пакетов должны быть строчными, а формальным соглашением об именах является &lt;top-level-domain&gt;.&lt;domain-name&gt;.&lt;project-name&gt;.&lt;module-name&gt;. Хотя это и не обязательно, имена пакетов обычно совпадают с именами иерархии каталогов. Поэтому, если следовать этому соглашению, класс Person в этом проекте будет найден в файле MyApp/src/main/scala/com/acme/myapp/model/Person.scala. Использование нескольких пакетов в одном файле Показанный выше синтаксис применяется ко всему исходному файлу: все определения в файле Person.scala принадлежат пакету com.acme.myapp.model в соответствии с package в начале файла. В качестве альтернативы можно написать package, которые применяются только к содержащимся в них определениям: package users: package administrators: // полное имя пакета - users.administrators class AdminUser // полное имя файла - users.administrators.AdminUser package normalusers: // полное имя пакета - users.normalusers class NormalUser // полное имя файла - users.normalusers.NormalUser Обратите внимание, что за именами пакетов следует двоеточие, а определения внутри пакета имеют отступ. Преимущество этого подхода заключается в том, что он допускает вложение пакетов и обеспечивает более очевидный контроль над областью действия и инкапсуляцией, особенно в пределах одного файла. Операторы импорта Операторы импорта используются для доступа к сущностям в других пакетах. Операторы импорта делятся на две основные категории: импорт классов, trait-ов, объектов, функций и методов импорт given предложений Первая категория операторов импорта аналогична тому, что использует Java, с немного другим синтаксисом, обеспечивающим большую гибкость. Пример: import users.* // импортируется все из пакета `users` import users.User // импортируется только класс `User` import users.{User, UserPreferences} // импортируются только два члена пакета import users.{UserPreferences as UPrefs} // переименование импортированного члена Эти примеры предназначены для того, чтобы дать представление о том, как работает первая категория операторов import. Более подробно они объясняются в следующих подразделах. Операторы импорта также используются для импорта given экземпляров в область видимости. Они обсуждаются в конце этой главы. import не требуется для доступа к членам одного и того же пакета. Импорт одного или нескольких членов В Scala импортировать один элемент из пакета можно следующим образом: import scala.concurrent.Future несколько: import scala.concurrent.Future import scala.concurrent.Promise import scala.concurrent.blocking При импорте нескольких элементов можно импортировать их более лаконично: import scala.concurrent.{Future, Promise, blocking} Если необходимо импортировать все из пакета scala.concurrent, используется такой синтаксис: import scala.concurrent.* Переименование элементов при импорте Иногда необходимо переименовать объекты при их импорте, чтобы избежать конфликтов имен. Например, если нужно использовать Scala класс List вместе с java.util.List, то можно переименовать java.util.List при импорте: import java.util.{List as JavaList} Теперь имя JavaList можно использовать для ссылки на класс java.util.List и использовать List для ссылки на Scala класс List. Также можно переименовывать несколько элементов одновременно, используя следующий синтаксис: import java.util.{Date as JDate, HashMap as JHashMap, *} В этой строке кода говорится следующее: “Переименуйте классы Date и HashMap, как показано, и импортируйте все остальное из пакета java.util, не переименовывая”. Скрытие членов при импорте При импорте часть объектов можно скрывать. Следующий оператор импорта скрывает класс java.util.Random, в то время как все остальное в пакете java.util импортируется: import java.util.{Random as _, *} Если попытаться получить доступ к классу Random, то выдается ошибка, но есть доступ ко всем остальным членам пакета java.util: val r = new Random // не скомпилируется new ArrayList // доступ есть Скрытие нескольких элементов Чтобы скрыть в import несколько элементов, их можно перечислить перед использованием *: import java.util.{List as _, Map as _, Set as _, *} Перечисленные классы скрыты, но можно использовать все остальное в java.util: val arr = new ArrayList[String] // arr: ArrayList[String] = [] Поскольку эти Java классы скрыты, можно использовать классы Scala List, Set и Map без конфликта имен: val a = List(1, 2, 3) // a: List[Int] = List(1, 2, 3) val b = Set(1, 2, 3) // b: Set[Int] = Set(1, 2, 3) val c = Map(1 -&gt; 1, 2 -&gt; 2) // c: Map[Int, Int] = Map(1 -&gt; 1, 2 -&gt; 2) Импорт можно использовать в любом месте В Scala операторы импорта могут быть объявлены где угодно. Их можно использовать в верхней части файла исходного кода: package foo import scala.util.Random class ClassA: def printRandom: val r = new Random // класс Random здесь доступен // ещё код... Также операторы импорта можно использовать ближе к тому месту, где они необходимы: package foo class ClassA: import scala.util.Random // внутри ClassA def printRandom { val r = new Random // ещё код... class ClassB: // класс Random здесь невидим val r = new Random // этот код не скомпилится “Статический” импорт Если необходимо импортировать элементы способом, аналогичным подходу «статического импорта» в Java, то есть для того, чтобы напрямую обращаться к членам класса, не добавляя к ним префикс с именем класса, используется следующий подход. Синтаксис для импорта всех статических членов Java класса Math: import java.lang.Math.* Теперь можно получить доступ к статическим методам класса Math, таким как sin и cos, без необходимости предварять их именем класса: import java.lang.Math.* val a = sin(0) // a: Double = 0.0 val b = cos(PI) // b: Double = -1.0 Пакеты, импортированные по умолчанию Два пакета неявно импортируются во все файлы исходного кода: java.lang.* scala.* Члены object Predef также импортируются по умолчанию. Например, такие классы, как List, Vector, Map и т. д. можно использовать явно, не импортируя их - они доступны, потому что определены в object Predef Обработка конфликтов имен Если необходимо импортировать что-то из корня проекта и возникает конфликт имен, достаточно просто добавить к имени пакета префикс _root_: package accounts import _root_.accounts.* Импорт given Как будет показано в главе “Контекстные абстракции”, для импорта экземпляров given используется специальная форма оператора import. Базовая форма показана в этом примере: object A: class TC given tc as TC def f(using TC) = ??? object B: import A.* // import all non-given members import A.given // import the given instance В этом коде предложение import A.* объекта B импортирует все элементы A, кроме given экземпляра tc. И наоборот, второй импорт, import A.given, импортирует только given экземпляр. Два предложения импорта также могут быть объединены в одно: object B: import A.{given, *} Селектор с подстановочным знаком * помещает в область видимости все определения, кроме given, тогда как селектор выше помещает в область действия все данные, включая те, которые являются результатом расширений. Эти правила имеют два основных преимущества: более понятно, откуда берутся данные given. В частности, невозможно скрыть импортированные given в длинном списке других импортируемых подстановочных знаков. есть возможность импортировать все given, не импортируя ничего другого. Это особенно важно, поскольку given могут быть анонимными, поэтому обычное использование именованного импорта нецелесообразно. Импорт по типу Поскольку given-ы могут быть анонимными, не всегда практично импортировать их по имени, и вместо этого обычно используется импорт подстановочных знаков. Импорт по типу предоставляет собой более конкретную альтернативу импорту с подстановочными знаками, делая понятным то, что импортируется. Этот код импортирует из A любой given тип, соответствующий TC: import A.{given TC} Если импортируется только один given, то фигурные скобки можно опустить: import A.given TC Импорт данных нескольких типов T1,...,Tn выражается несколькими given селекторами: import A.{given T1, ..., given Tn} Импорт всех given экземпляров параметризованного типа достигается аргументами с подстановочными знаками. Например, есть такой объект: object Instances: given intOrd as Ordering[Int] given listOrd[T: Ordering] as Ordering[List[T]] given ec as ExecutionContext = ... given im as Monoid[Int] Оператор import ниже импортирует экземпляры intOrd, listOrd и ec, но пропускает экземпляр im, поскольку он не соответствует ни одному из указанных шаблонов: import Instances.{given Ordering[?], given ExecutionContext} Импорт по типу можно смешивать с импортом по имени. Если оба присутствуют в предложении import, импорт по типу идет последним. Например, это предложение импорта импортирует im, intOrd и listOrd, но не включает ec: import Instances.{im, given Ordering[?]} Пример В качестве конкретного примера представим, что у нас есть объект MonthConversions, который содержит два определения given: object MonthConversions: trait MonthConverter[A]: def convert(a: A): String given intMonthConverter: MonthConverter[Int] with def convert(i: Int): String = i match case 1 =&gt; \"January\" case 2 =&gt; \"February\" case _ =&gt; \"Other\" given stringMonthConverter: MonthConverter[String] with def convert(s: String): String = s match case \"jan\" =&gt; \"January\" case \"feb\" =&gt; \"February\" case _ =&gt; \"Other\" Чтобы импортировать эти given-ы в текущую область, используем два оператора import: import MonthConversions.* import MonthConversions.given MonthConverter[?] Теперь создаем метод, использующий эти экземпляры: def genericMonthConverter[A](a: A)(using monthConverter: MonthConverter[A]): String = monthConverter.convert(a) Вызов метода: genericMonthConverter(1) // res1: String = \"January\" genericMonthConverter(\"jan\") // res2: String = \"January\" Как уже упоминалось ранее, одно из ключевых преимуществ синтаксиса “import given” состоит в том, чтобы прояснить, откуда берутся данные в области действия, и в import операторах выше ясно, что данные поступают из объекта MonthConversions. References: Scala3 book"
    } ,      
    {
      "title": "Чистые функции",
      "url": "/scalaworkbook/docs/fp/pure-functions.html",
      "content": "Чистые функции Еще одна концепция, которую Scala предлагает для помощи в написании функционального кода, — это возможность писать чистые функции. Чистая функция (pure function) может быть определена следующим образом: функция f является чистой, если при одних и тех же входных данных x она всегда возвращает один и тот же результат f(x) результат функции зависит только от входных данных и её реализации чистые функции только вычисляют результат, ничего не меняя за пределами этих функций Из этого следует: чистая функция не изменяет свои входные параметры она не мутирует какое-либо скрытое состояние у неё нет “черных ходов”: он не читает данные из внешнего мира (включая консоль, веб-сервисы, базы данных, файлы и т. д.) и не записывает данные вовне В результате этого определения каждый раз, когда вызывается чистая функция с одним и тем же входным значением (значениями), всегда будет выдаваться один и тот же результат. Например, можно вызывать функцию double бесконечное число раз с входным значением 2, и всегда получать результат 4. Примеры чистых функций Учитывая это определение, методы в пакете scala.math._ являются чистыми функциями: abs ceil max Эти методы String также являются чистыми функциями: isEmpty length substring Большинство методов в классах коллекций Scala также работают как чистые функции, включая drop, filter, map и многие другие. В Scala функции и методы почти полностью взаимозаменяемы, поэтому, хотя здесь используется общепринятый отраслевой термин “чистая функция”, этот термин можно использовать как для описания функций, так и методов. Как методы могут использоваться подобно функциям описано в главе Eta расширение. Примеры “нечистых” функций И наоборот, следующие функции “нечисты” (impure), потому что они нарушают определение pure function: println — методы, взаимодействующие с консолью, файлами, базами данных, веб-сервисами и т. д., “нечисты” currentTimeMillis — все методы, связанные с датой и временем, “нечисты”, потому что их вывод зависит от чего-то другого, кроме входных параметров sys.error — методы генерации исключений “нечисты”, потому что они не “просто возвращают результат” “Нечистые” функции часто делают одну или несколько из следующих вещей: читают из скрытого состояния, т.е. обращаются к параметрам и данным, не переданным в функцию явным образом в качестве входных параметров запись в скрытое состояние изменяют заданные им параметры или изменяют скрытые переменные, например, поля в содержащем их классе выполняют какой-либо ввод-вывод с внешним миром В общем, следует остерегаться функций с возвращаемым типом Unit. Поскольку эти функции ничего не возвращают, логически единственная причина, по которой они когда-либо вызываются, - это достижение какого-то побочного эффекта. Как следствие, часто использование этих функций является “нечистым”. Но нечистые функции все же необходимы… Конечно, приложение не очень полезно, если оно не может читать или писать во внешний мир, поэтому рекомендуется следующее: Напишите ядро вашего приложения, используя только “чистые” функции, а затем напишите “нечистую” “оболочку” вокруг этого ядра для взаимодействия с внешним миром. Как кто-то однажды сказал, это все равно, что положить слой нечистой глазури на чистый торт. Важно отметить, что есть способы сделать “нечистое” взаимодействие с внешним миром более “чистым”. Например, можно услышать об использовании IO монады для обработки ввода-вывода. Эти темы выходят за рамки данного документа, поэтому для простоты можно думать, что ФП приложения имеют ядро из “чистых” функций, которые объединены с другими функциями для взаимодействия с внешним миром. Написание “чистых” функций Примечание: в этом разделе для обозначения методов Scala часто используется общепринятый в отрасли термин “чистая функция”. Для написания чистых функций на Scala, достаточно писать их, используя синтаксис методов Scala (хотя также можно использовать и синтаксис функций Scala). Например, вот чистая функция, которая удваивает заданное ей входное значение: def double(i: Int): Int = i * 2 Вот чистая функция, которая вычисляет сумму списка целых чисел с использованием рекурсии: def sum(xs: List[Int]): Int = xs match case Nil =&gt; 0 case head :: tail =&gt; head + sum(tail) Вышеописанные функции соответствуют определению “чистых”. Ключевые моменты Первым ключевым моментом этого раздела является определение чистой функции: Чистая функция — это функция, которая зависит только от своих объявленных входных данных и своей реализации для получения результата. Она только вычисляет свой результат, не завися от внешнего мира и не изменяя его. Второй ключевой момент заключается в том, что каждое реальное приложение взаимодействует с внешним миром. Таким образом, упрощенный способ представления о функциональных программах состоит в том, что они состоят из ядра чистых функций, которые обернуты другими функциями, взаимодействующими с внешним миром. References: Scala3 book"
    } ,    
    {
      "title": "Read-Evaluate-Print-Loop",
      "url": "/scalaworkbook/docs/repl.html",
      "content": "Read-Evaluate-Print-Loop Scala REPL (“Read-Evaluate-Print-Loop”) - это интерпретатор командной строки, который используется в качестве “игровой площадки” для тестирования Scala кода. Для того чтобы запустить сеанс REPL, надо выполнить команду scala или scala3 в зависимости от операционной системы, где будет выведено приглашение “Welcome”, подобное этому: $ scala Welcome to Scala 3.1.2 (OpenJDK 64-Bit Server VM, Java 11.0.9). Type in expressions for evaluation. Or try :help. scala&gt; _ REPL — это интерпретатор командной строки, поэтому он ждет, пока вы что-нибудь наберете. Теперь можно вводить выражения Scala, чтобы увидеть, как они работают: scala&gt; 1 + 1 val res0: Int = 2 scala&gt; 2 + 2 val res1: Int = 4 Как показано в выводе, если не присваивать переменную результату выражения, REPL автоматически создает переменные с именами res0, res1 и т. д. Эти имена переменных можно использовать в последующих выражениях: scala&gt; val x = res0 * 10 val x: Int = 20 Обратите внимание, что в REPL output также показываются результаты выражений. В REPL можно проводить всевозможные эксперименты. В этом примере показано, как создать, а затем вызвать метод sum: scala&gt; def sum(a: Int, b: Int): Int = a + b def sum(a: Int, b: Int): Int scala&gt; sum(2, 2) val res2: Int = 4 Также можно использовать игровую среду на основе браузера scastie.scala-lang.org. Если вы предпочитаете писать код в текстовом редакторе, а не в консоли, то можно использовать worksheet. References: Scala3 book"
    } ,    
    {
      "title": "Написание метода возвращающего функцию",
      "url": "/scalaworkbook/docs/functions/returns-function.html",
      "content": "Написание метода возвращающего функцию Благодаря согласованности Scala написание метода, возвращающего функцию, похоже на то, что было описано в предыдущих разделах. Еще раз начнем с постановки проблемы: Необходимо создать метод greet, возвращающий функцию. Эта функция должна принимать строковый параметр и печатать его с помощью println. Начнем с простого шага: greet не принимает никаких входных параметров, а просто создает функцию и возвращает её. Учитывая это утверждение, можно начать создавать greet. Известно, что это будет метод: def greet() Также известно, что этот метод должен возвращать функцию, которая: принимает параметр String и печатает эту строку с помощью println. Следовательно, эта функция имеет тип String =&gt; Unit: def greet(): String =&gt; Unit = ??? ---------------- Теперь нужно создать тело метода. Возвращаемая функция соответствует следующему описанию: (name: String) =&gt; println(s\"Hello, $name\") Добавляем эту функцию в тело метода: def greet(): String =&gt; Unit = (name: String) =&gt; println(s\"Hello, $name\") Поскольку метод возвращает функцию, мы получаем ее, вызывая greet(). val greetFunction = greet() // greetFunction: Function1[String, Unit] = repl.MdocSession$App$$Lambda$7937/0x0000000102348840@3beb98eb Теперь можно вызвать greetFunction: greetFunction(\"Joe\") // Hello, Joe Доработка метода Метод greet() был бы более полезным, если бы была возможность задавать приветствие. Например, передать его в качестве параметра методу greet() и использовать внутри println: def greet(theGreeting: String): String =&gt; Unit = (name: String) =&gt; println(s\"$theGreeting, $name\") Теперь, при вызове этого метода, процесс становится более гибким, потому что приветствие можно изменить. Вот как это выглядит, когда создается функция из этого метода: val sayHello = greet(\"Hello\") // sayHello: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$7938/0x000000010234a040@649ca843 Выходные данные подписи типа показывают, что sayHello — это функция, которая принимает входной параметр String и возвращает Unit. Так что теперь, при передаче sayHello строки, печатается приветствие: sayHello(\"Joe\") // Hello, Joe Приветствие можно менять для создания новых функций: val sayCiao = greet(\"Ciao\") // sayCiao: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$7938/0x000000010234a040@7c6cd42e val sayHola = greet(\"Hola\") // sayHola: Function1[String, Unit] = repl.MdocSession$App1$$Lambda$7938/0x000000010234a040@3d82b44 sayCiao(\"Isabella\") // Ciao, Isabella sayHola(\"Carlos\") // Hola, Carlos Более реалистичный пример Этот метод может быть еще более полезным, когда возвращает одну из многих возможных функций, например, фабрику пользовательских функций. Например, представим, что необходимо написать метод, который возвращает функции, приветствующие людей на разных языках. Ограничим это функциями, которые приветствуют на английском или французском языках, в зависимости от параметра, переданного в метод. Созданный метод должен: принимать “желаемый язык” в качестве входных данных и возвращать функцию в качестве результата. Кроме того, поскольку эта функция печатает заданную строку, известно, что она имеет тип String =&gt; Unit. С помощью этой информации сигнатура метода должна выглядеть так: def createGreetingFunction(desiredLanguage: String): String =&gt; Unit = ??? Далее, поскольку возвращаемые функции, берут строку и печатают ее, можно прикинуть две анонимные функции для английского и французского языков: (name: String) =&gt; println(s\"Hello, $name\") (name: String) =&gt; println(s\"Bonjour, $name\") Для большей читабельности дадим этим анонимным функциям имена и назначим двум переменным: val englishGreeting = (name: String) =&gt; println(s\"Hello, $name\") val frenchGreeting = (name: String) =&gt; println(s\"Bonjour, $name\") Теперь все, что осталось, это вернуть englishGreeting, если desiredLanguage — английский, и вернуть frenchGreeting, если desiredLanguage — французский. Один из способов сделать это - pattern matching: def createGreetingFunction(desiredLanguage: String): String =&gt; Unit = val englishGreeting = (name: String) =&gt; println(s\"Hello, $name\") val frenchGreeting = (name: String) =&gt; println(s\"Bonjour, $name\") desiredLanguage match case \"english\" =&gt; englishGreeting case \"french\" =&gt; frenchGreeting Обратите внимание, что возврат значения функции из метода ничем не отличается от возврата строкового или целочисленного значения. Вот как createGreetingFunction создает функцию приветствия на французском языке: val greetInFrench = createGreetingFunction(\"french\") greetInFrench(\"Jonathan\") // Bonjour, Jonathan И вот как - на английском: val greetInEnglish = createGreetingFunction(\"english\") greetInEnglish(\"Joe\") // Hello, Joe References: Scala3 book"
    } ,      
    {
      "title": "Источники",
      "url": "/scalaworkbook/sources.html",
      "content": "Список источников Книги: Scala 3, official documentation Michael Pilquist, Rúnar Bjarnason, and Paul Chiusano - Functional Programming in Scala, Second Edition Статьи … Курсы …"
    } ,    
    {
      "title": "Структуры управления",
      "url": "/scalaworkbook/docs/structures.html",
      "content": "{{page.title}} В Scala есть все ожидаемые структуры управления, в том числе: if/then/else циклы for циклы while try/catch/finally Здесь также есть две другие мощные конструкции, присутствующие не во всех языках программирования: for выражения (также известные как for comprehensions) match выражения if/else Однострочное if выражение выглядит так: val x = 1 if x == 1 then println(x) // 1 Когда необходимо выполнить несколько строк кода после if, используется синтаксис: if x == 1 then println(\"x is 1, as you can see:\") println(x) // x is 1, as you can see: // 1 if/else синтаксис выглядит так: if x == 1 then println(\"x is 1, as you can see:\") println(x) else println(\"x was not 1\") // x is 1, as you can see: // 1 if/else if/else выглядит так же, как и в других языках: def detect(x: Int) = if x &lt; 0 then println(\"negative\") else if x == 0 then println(\"zero\") else println(\"positive\") detect(-1) // negative detect(0) // zero detect(1) // positive При желании можно дополнительно включить оператор end if в конце каждого выражения: if x == 1 then println(\"x is 1, as you can see:\") println(x) end if if/else выражение всегда возвращает результат Сравнения if/else образуют выражения - это означает, что они возвращают значение, которое можно присвоить переменной. Поэтому нет необходимости в специальном тернарном операторе. Пример: val minValue = if a &lt; b then a else b Можно использовать if/else выражение в качестве тела метода: def compare(a: Int, b: Int): Int = if a &lt; b then -1 else if a == b then 0 else 1 Как будет видно дальше, все структуры управления Scala можно использовать в качестве выражений. Программирование, ориентированное на выражения (expression-oriented programming или EOP) - стиль разработки, когда каждое написанное выражение возвращает значение. И наоборот, строки кода, которые не возвращают значения, называются операторами или утверждениями и используются для получения побочных эффектов. По мере погружения в Scala можно обнаружить, что пишется больше выражений и меньше утверждений. for loops В самом простом случае цикл for в Scala можно использовать для перебора элементов в коллекции. Например, имея последовательность целых чисел, можно перебрать ее элементы и вывести значения следующим образом: val ints = List(1, 2, 3, 4, 5) for i &lt;- ints do println(i) // 1 // 2 // 3 // 4 // 5 Код i &lt;- ints называется генератором. Если необходим многострочный блок кода после генератора for, используется следующий синтаксис: for i &lt;- ints do val x = i * 2 println(s\"i = $i, x = $x\") // i = 1, x = 2 // i = 2, x = 4 // i = 3, x = 6 // i = 4, x = 8 // i = 5, x = 10 Несколько генераторов В цикле for можно использовать несколько генераторов, например: for i &lt;- 1 to 2 j &lt;- 'a' to 'b' k &lt;- 1 to 10 by 5 do println(s\"i = $i, j = $j, k = $k\") // i = 1, j = a, k = 1 // i = 1, j = a, k = 6 // i = 1, j = b, k = 1 // i = 1, j = b, k = 6 // i = 2, j = a, k = 1 // i = 2, j = a, k = 6 // i = 2, j = b, k = 1 // i = 2, j = b, k = 6 Guards Циклы for также могут содержать условия, называемые guards: for i &lt;- 1 to 5 if i % 2 == 0 do println(i) // 2 // 4 Можно добавлять столько условий, сколько необходимо: for i &lt;- 1 to 10 if i &gt; 3 if i &lt; 6 if i % 2 == 0 do println(i) // 4 Использование for с Map-ами Циклы for можно использовать с Map-ами. Например, если есть карта ключ/значение: val states = Map( \"AK\" -&gt; \"Alaska\", \"AL\" -&gt; \"Alabama\", \"AR\" -&gt; \"Arizona\" ) Можно обойти все пары ключ/значение так: for (abbrev, fullName) &lt;- states do println(s\"$abbrev: $fullName\") // AK: Alaska // AL: Alabama // AR: Arizona Когда цикл for перебирает Map, каждая пара ключ/значение привязывается к переменным abbrev и fullName. По мере выполнения цикла переменная abbrev принимает значение текущего ключа, а переменная fullName - соответствующему ключу значению. for expressions В предыдущих примерах все циклы for использовались для побочных эффектов, в частности, для вывода результата в STDOUT с помощью println. Важно знать, что for также можно использовать для выражений, возвращающих значения. Для этого for создается с ключевым словом yield вместо do и возвращаемым выражением, например: val list = for i &lt;- 10 to 12 yield i * 2 // list: IndexedSeq[Int] = Vector(20, 22, 24) После присваивания list содержит Vector с отображаемыми значениями. Вот как работает это выражение: Выражение for начинает перебирать значения в диапазоне (10, 11, 12). Сначала оно работает со значением 10, умножает его на 2, затем выдает результат - 20. Далее берет 11 — второе значение в диапазоне. Умножает его на 2, а затем выдает значение 22. Можно представить эти полученные значения как накопление во временном хранилище. Наконец, цикл берет число 12 из диапазона, умножает его на 2, получая число 24. Цикл завершается в этой точке и выдает конечный результат - (20, 22, 24). В данном случае показанное выражение for эквивалентно вызову метода map: val list = (10 to 12).map(i =&gt; i * 2) // list: IndexedSeq[Int] = Vector(20, 22, 24) Выражения for можно использовать всегда, когда нужно обойти все элементы в коллекции и применить алгоритм к этим элементам для создания нового списка. Вот пример, который показывает, как использовать блок кода после yield: val names = List(\"_olivia\", \"_walter\", \"_peter\") // names: List[String] = List(\"_olivia\", \"_walter\", \"_peter\") val capNames = for name &lt;- names yield val nameWithoutUnderscore = name.drop(1) val capName = nameWithoutUnderscore.capitalize capName // capNames: List[String] = List(\"Olivia\", \"Walter\", \"Peter\") Поскольку выражение for возвращает результат, его можно использовать в качестве тела метода. Пример: def between3and10(xs: List[Int]): List[Int] = for x &lt;- xs if x &gt;= 3 if x &lt;= 10 yield x between3and10(List(1, 3, 7, 11)) // res15: List[Int] = List(3, 7) while loops Цикл while имеет следующий синтаксис: var x = 1 // x: Int = 1 while x &lt; 3 do println(x) x += 1 // 1 // 2 В Scala не приветствуется использование изменяемых переменных var, поэтому следует избегать while. Аналогичный результат можно достигнуть используя вспомогательный метод: def loop(x: Int): Unit = if x &lt; 3 then println(x) loop(x + 1) loop(1) match expressions Сопоставление с образцом (pattern matching) является основой функциональных языков программирования, и Scala включает в себя pattern matching, обладающий множеством возможностей. В самом простом случае можно использовать выражение match, подобное оператору Java switch, сопоставляя на основе целочисленного значения. Как и предыдущие структуры, pattern matching - это действительно выражение, поскольку оно вычисляет результат: import scala.annotation.switch val i = 6 // i: Int = 6 val day = (i: @switch) match case 0 =&gt; \"Sunday\" case 1 =&gt; \"Monday\" case 2 =&gt; \"Tuesday\" case 3 =&gt; \"Wednesday\" case 4 =&gt; \"Thursday\" case 5 =&gt; \"Friday\" case 6 =&gt; \"Saturday\" case _ =&gt; \"invalid day\" // day: String = \"Saturday\" В примере выше переменная i сопоставляется с числом и если равна от 0 до 6, то в day возвращается день недели. Иной случай обозначается символом _ и если i не равен от 0 до 6, то возвращается значение invalid day. При написании простых выражений соответствия, подобных этому, рекомендуется использовать аннотацию @switch для переменной i. Эта аннотация содержит предупреждение во время компиляции, если switch не может быть скомпилирован в tableswitch или lookupswitch, которые лучше подходят с точки зрения производительности. Значение по умолчанию Когда нужно получить доступ к универсальному значению по умолчанию в pattern matching, достаточно указать имя переменной в левой части оператора case, а затем использовать это имя в правой части оператора: i match case 0 =&gt; println(\"1\") case 1 =&gt; println(\"2\") case what =&gt; println(s\"Получено значение: $what\" ) // Получено значение: 6 Переменной можно дать любое допустимое имя. Можно также использовать _ в качестве имени, чтобы игнорировать значение. Обработка нескольких возможных значений в одной строке В этом примере показано, как использовать несколько возможных совпадений с образцом в каждом операторе case: val evenOrOdd = i match case 1 | 3 | 5 | 7 | 9 =&gt; println(\"odd\") case 2 | 4 | 6 | 8 | 10 =&gt; println(\"even\") case _ =&gt; println(\"some other number\") // even Использование if в pattern matching В pattern matching можно использовать условия: i match case 1 =&gt; println(\"one, a lonely number\") case x if x == 2 || x == 3 =&gt; println(\"two’s company, three’s a crowd\") case x if x &gt; 3 =&gt; println(\"4+, that’s a party\") case _ =&gt; println(\"i’m guessing your number is zero or less\") // 4+, that’s a party Ещё пример: i match case a if 0 to 9 contains a =&gt; println(s\"0-9 range: $a\") case b if 10 to 19 contains b =&gt; println(s\"10-19 range: $b\") case c if 20 to 29 contains c =&gt; println(s\"20-29 range: $c\") case _ =&gt; println(\"Hmmm...\") // 0-9 range: 6 case classes и выражение match Также можно извлекать поля из case class-ов — и классов, которые имеют правильно написанные методы apply/unapply — и использовать их в pattern matching. Вот пример использования простого case class Person case class Person(name: String) def speak(p: Person) = p match case Person(name) if name == \"Fred\" =&gt; println(s\"$name says, Yubba dubba doo\") case Person(name) if name == \"Bam Bam\" =&gt; println(s\"$name says, Bam bam!\") case _ =&gt; println(\"Watch the Flintstones!\") speak(Person(\"Fred\")) // Fred says, Yubba dubba doo speak(Person(\"Bam Bam\")) // Bam Bam says, Bam bam! speak(Person(\"Wilma\")) // Watch the Flintstones! Использование выражения match в теле метода Поскольку выражения match возвращают значение, их можно использовать в теле метода. Этот метод принимает значение Matchable в качестве входного параметра и возвращает логическое значение на основе результата выражения соответствия: def isTruthy(a: Matchable) = a match case 0 | \"\" | false =&gt; false case _ =&gt; true Входной параметр a определяется как тип Matchable, который является родителем всех типов Scala. Для Matchable может выполняться сопоставление с образцом. Метод реализуется путем сопоставления входных данных, обеспечивая два случая: первый проверяет, является ли заданное значение целым числом 0, пустой строкой или false, и в этом случае возвращает false. Для иных случаев возвращается значение true. Эти примеры показывают, как работает метод: isTruthy(0) // res23: Boolean = false isTruthy(false) // res24: Boolean = false isTruthy(\"\") // res25: Boolean = false isTruthy(1) // res26: Boolean = true isTruthy(\" \") // res27: Boolean = true isTruthy(2F) // res28: Boolean = true Использование pattern matching в качестве тела метода очень распространено. Использование различных шаблонов в pattern matching Для выражения match можно использовать множество различных шаблонов. Например: Сравнение с константой (case 3 =&gt;) Сравнение с последовательностями (case List(els : _*) =&gt;) Сравнение с кортежами (case (x, y) =&gt;) Сравнение с конструктором класса (case Person(first, last) =&gt;) Сравнение по типу (case p: Person =&gt;) Все эти виды шаблонов показаны в следующем примере: def pattern(x: Matchable): String = x match // Сравнение с константой case 0 =&gt; \"ноль\" case true =&gt; \"true\" case \"hello\" =&gt; \"строка 'hello'\" case Nil =&gt; \"пустой List\" // Сравнение с последовательностями case List(0, _, _) =&gt; \"список из 3 элементов с 0 в качестве первого элемента\" case List(1, _*) =&gt; \"Непустой список, начинающийся с 1, и имеющий любой размер &gt; 0\" case Vector(1, _*) =&gt; \"Vector, начинающийся с 1, и имеющий любой размер &gt; 0\" // Сравнение с кортежами case (a, b) =&gt; s\"получено $a и $b\" case (a, b, c) =&gt; s\"получено $a, $b и $c\" // Сравнение с конструктором класса case Person(first, \"Alexander\") =&gt; s\"Alexander, first name = $first\" case Dog(\"Zeus\") =&gt; \"Собака с именем Zeus\" // Сравнение по типу case s: String =&gt; s\"получена строка: $s\" case i: Int =&gt; s\"получено число: $i\" case f: Float =&gt; s\"получено число с плавающей точкой: $f\" case a: Array[Int] =&gt; s\"массив чисел: ${a.mkString(\",\")}\" case as: Array[String] =&gt; s\"массив строк: ${as.mkString(\",\")}\" case d: Dog =&gt; s\"Экземпляр класса Dog: ${d.name}\" case list: List[?] =&gt; s\"получен List: $list\" case m: Map[?, ?] =&gt; m.toString // Сравнение по умолчанию case _ =&gt; \"Unknown\" try/catch/finally Как и в Java, в Scala есть конструкция try/catch/finally, позволяющая перехватывать исключения и управлять ими. Для обеспечения согласованности Scala использует тот же синтаксис, что и выражения match, и поддерживает pattern matching для различных возможных исключений. В следующем примере openAndReadAFile - это метод, который выполняет то, что следует из его названия: он открывает файл и считывает текст в нем, присваивая результат изменяемой переменной text: var text = \"\" try text = openAndReadAFile(filename) catch case fnf: FileNotFoundException =&gt; fnf.printStackTrace() case ioe: IOException =&gt; ioe.printStackTrace() finally println(\"Здесь необходимо закрыть ресурсы.\") Предполагая, что метод openAndReadAFile использует Java java.io.* классы для чтения файла и не перехватывает его исключения, попытка открыть и прочитать файл может привести как к FileNotFoundException, так и к IOException, и эти два исключения перехватываются в блоке catch этого примера. References: Scala3 book, taste Control Structures Scala3 book, Control Structures"
    } ,    
    {
      "title": "Сборка и тестирование проектов Scala с помощью Sbt",
      "url": "/scalaworkbook/docs/tools/tools-sbt.html",
      "content": "{{page.title}} В этом разделе будут показаны два инструмента, которые обычно используются в проектах Scala: инструмент сборки sbt ScalaTest - среда тестирования исходного кода Начнем с использования sbt для создания Scala-проектов, а затем рассмотрим, как использовать sbt и ScalaTest вместе для тестирования. Создание проектов Scala с помощью sbt Можно использовать несколько различных инструментов для создания проектов Scala, включая Ant, Maven, Gradle, Mill и другие. Но инструмент под названием sbt был первым инструментом сборки, специально созданным для Scala. Чтобы установить sbt, см. страницу загрузки. Создание проекта “Hello, world” Вы можете создать sbt проект “Hello, world” всего за несколько шагов. Сначала создайте каталог для работы и перейдите в него: $ mkdir hello $ cd hello В каталоге hello создайте подкаталог project: $ mkdir project Создайте файл с именем build.properties в каталоге project со следующим содержимым: sbt.version=1.6.2 Затем создайте файл с именем build.sbt в корневом каталоге проекта (hello), содержащий следующую строку: scalaVersion := \"3.1.2\" Теперь создайте файл с именем Hello.scala в корневом каталоге проекта с таким содержимым: @main def helloWorld = println(\"Hello, world\") Это все, что нужно сделать. Должна получиться следующая структура проекта: $ tree . ├── build.sbt ├── Hello.scala └── project └── build.properties Теперь запустите проект с помощью команды sbt: $ sbt run Вы должны увидеть вывод, который выглядит следующим образом, включая “Hello, world” из программы: $ sbt run [info] welcome to sbt 1.6.1 (AdoptOpenJDK Java 11.x) [info] loading project definition from project ... [info] loading settings for project from build.sbt ... [info] compiling 1 Scala source to target/scala-3.1.2/classes ... [info] running helloWorld Hello, world [success] Total time: 2 s Программа запуска — средство командной строки sbt - загружает версию sbt, установленную в файле project/build.properties, которая загружает версию компилятора Scala, установленную в файле build.sbt, компилирует код в файле Hello.scala и запускает результирующий байт-код. Если посмотреть на корневой каталог, то можно увидеть, что появилась папка с именем target. Это рабочие каталоги, которые использует sbt. Создание и запуск небольшого проекта Scala с помощью sbt занимает всего несколько простых шагов. Использование sbt в более крупных проектах Для небольшого проекта это все, что требует sbt для запуска. Для более крупных проектов с большим количеством файлов исходного кода, зависимостей или плагинов, потребуется создать организованную структуру каталогов. Остальная часть этого раздела демонстрирует структуру, которую использует sbt. Структура каталогов sbt Как и Maven, sbt использует стандартную структуру каталогов проекта. Преимуществом стандартизации является то, что, как только структура станет привычной, станет легко работать с другими проектами Scala/sbt. Первое, что нужно знать - это то, что под корневым каталогом проекта sbt ожидает структуру каталогов, которая выглядит следующим образом: . ├── build.sbt ├── project/ │ └── build.properties ├── src/ │ ├── main/ │ │ ├── java/ │ │ ├── resources/ │ │ └── scala/ │ └── test/ │ ├── java/ │ ├── resources/ │ └── scala/ └── target/ Также в корневой каталог можно добавить каталог lib, если необходимо в свой проект добавить неуправляемые зависимости — файлы JAR. Если достаточно создать проект, который имеет только файлы исходного кода Scala и тесты, но не будет использовать Java файлы и не нуждается в каких-либо “ресурсах” (встроенные изображения, файлы конфигурации и т.д.), то в каталоге src можно оставить только: . └── src/ ├── main/ │ └── scala/ └── test/ └── scala/ “Hello, world” со структурой каталогов sbt Создать такую структуру каталогов просто. Существуют инструменты, которые сделают это за вас, но если вы используете систему Unix/Linux, можно использовать следующие команды для создания структуры каталогов проекта sbt: $ mkdir HelloWorld $ cd HelloWorld $ mkdir -p src/{main,test}/scala $ mkdir project target После запуска этих команд, по запросу find . вы должны увидеть такой результат: $ find . . ./project ./src ./src/main ./src/main/scala ./src/test ./src/test/scala ./target Существуют и другие способы создания файлов и каталогов для проекта sbt. Один из способов - использовать команду sbt new, которая задокументирована на scala-sbt.org. Создание первого файла build.sbt На данный момент нужны еще две вещи для запуска проекта “Hello, world”: файл build.sbt файл Hello.scala Для такого небольшого проекта файлу build.sbt нужна только запись scalaVersion, но мы добавим три строки: name := \"HelloWorld\" version := \"0.1\" scalaVersion := \"3.1.2\" Поскольку проекты sbt используют стандартную структуру каталогов, sbt может найти все, что ему нужно. Теперь осталось просто добавить небольшую программу “Hello, world”. Программа “Hello, world” В больших проектах все файлы исходного кода будут находиться в каталогах src/main/scala и src/test/scala, но для небольшого примера, подобного этому, можно поместить файл исходного кода в корневой каталог. Поэтому создайте файл с именем HelloWorld.scala в корневом каталоге со следующим содержимым: @main def helloWorld = println(\"Hello, world\") Этот код определяет “main” метод, который печатает \"Hello, world\" при запуске. Теперь используйте команду sbt run для компиляции и запуска проекта: $ sbt run [info] welcome to sbt [info] loading settings for project ... [info] loading project definition [info] loading settings for project root from build.sbt ... [info] Compiling 1 Scala source ... [info] running helloWorld Hello, world [success] Total time: 4 s При первом запуске sbt загружает все, что ему нужно (это может занять несколько секунд), но после первого раза запуск становится намного быстрее. Кроме того, после выполнения первого шага можно обнаружить, что гораздо быстрее запускать sbt в интерактивном режиме. Для этого вначале отдельно запустите команду sbt: $ sbt [info] welcome to sbt [info] loading settings for project ... [info] loading project definition ... [info] loading settings for project root from build.sbt ... [info] sbt server started at local:///${HOME}/.sbt/1.0/server/7d26bae822c36a31071c/sock sbt:hello-world&gt; _ Затем внутри этой оболочки выполните команду run: sbt:hello-world&gt; run [info] running helloWorld Hello, world [success] Total time: 0 s Так намного быстрее. Если вы наберете help в командной строке sbt, то увидите список других команд, доступных для запуска. Введите exit (или нажмите CTRL-D), чтобы выйти из оболочки sbt. Использование шаблонов проектов Ручное создание структуры проекта может быть утомительным. К счастью, sbt может создать структуру на основе шаблона. Чтобы создать проект Scala 3 из шаблона, выполните следующую команду в оболочке: $ sbt new scala/scala3.g8 Sbt загрузит шаблон, задаст несколько вопросов и создаст файлы проекта в подкаталоге: $ tree scala-3-project-template scala-3-project-template ├── build.sbt ├── project │ └── build.properties ├── README.md └── src ├── main │ └── scala │ └── Main.scala └── test └── scala └── Test1.scala Если вы хотите создать проект Scala 3, который кросс-компилируется со Scala 2, используйте шаблон scala/scala3-cross.g8: $ sbt new scala/scala3-cross.g8 Узнайте больше о sbt new и шаблонах проектов в документации sbt. Другие инструменты сборки для Scala Хотя sbt широко используется, есть и другие инструменты, которые можно использовать для создания проектов Scala: Ant Gradle Maven Mill Coursier Coursier - это “преобразователь зависимостей”, похожий по функциям на Maven и Ivy. Он написан на Scala с нуля, “охватывает принципы функционального программирования” и для быстроты параллельно загружает артефакты. sbt использует Coursier для обработки большинства разрешений зависимостей, а в качестве инструмента командной строки его можно использовать для простой установки таких инструментов, как sbt, Java и Scala, как показано на странице “Начало работы”. Этот пример показывает, что команда cs launch может использоваться для запуска приложений из зависимостей: $ cs launch org.scalameta::scalafmt-cli:2.4.2 -- --help scalafmt 2.4.2 Usage: scalafmt [options] [&lt;file&gt;...] -h, --help prints this usage text -v, --version print version more ... Подробнее см. на странице запуска Coursier. Использование sbt со ScalaTest ScalaTest — одна из основных библиотек тестирования для проектов Scala. В этом разделе рассмотрим шаги, необходимые для создания проекта Scala/sbt, использующего ScalaTest. 1) Создание структуры каталогов проекта Как и в предыдущем уроке, создаем структуру каталогов sbt для проекта с именем HelloScalaTest с помощью следующих команд: $ mkdir HelloScalaTest $ cd HelloScalaTest $ mkdir -p src/{main,test}/scala $ mkdir project 2) Создание файлов build.properties и build.sbt Затем создаем файл build.properties в подкаталоге project/ проекта с такой строкой: sbt.version=1.6.2 Создаем файл build.sbt в корневом каталоге проекта со следующим содержимым: name := \"HelloScalaTest\" version := \"0.1\" scalaVersion := \"3.1.2\" libraryDependencies ++= Seq( \"org.scalatest\" %% \"scalatest\" % \"3.2.9\" % Test ) Первые три строки этого файла практически такие же, как и в первом примере. Строки libraryDependencies сообщают sbt о включении зависимостей (файлов JAR), которые необходимы для добавления ScalaTest. Документация по ScalaTest всегда была хорошей, и вы всегда можете найти актуальную информацию о том, как должны выглядеть эти строки, на странице “Установка ScalaTest”. 3) Создание файла исходного кода Scala Затем создаем программу Scala, которую можно использовать для демонстрации ScalaTest. Сначала создайте каталог в src/main/scala с именем math: $ mkdir src/main/scala/math ---- Внутри этого каталога создайте файл MathUtils.scala со следующим содержимым: package math object MathUtils: def double(i: Int) = i * 2 Этот метод обеспечивает простой способ демонстрации ScalaTest. 4) Создание первых тестов ScalaTest ScalaTest очень гибок и предлагает несколько различных способов написания тестов. Простой способ начать работу — написать тесты с помощью AnyFunSuite. Для начала создайте каталог с именем math в каталоге src/test/scala: $ mkdir src/test/scala/math ---- Затем создайте в этом каталоге файл с именем MathUtilsTests.scala со следующим содержимым: package math import org.scalatest.funsuite.AnyFunSuite class MathUtilsTests extends AnyFunSuite: // test 1 test(\"'double' should handle 0\") { val result = MathUtils.double(0) assert(result == 0) } // test 2 test(\"'double' should handle 1\") { val result = MathUtils.double(1) assert(result == 2) } test(\"test with Int.MaxValue\") (pending) end MathUtilsTests Этот код демонстрирует AnyFunSuite подход. Несколько важных моментов: тестовый класс должен расширять AnyFunSuite тесты создаются, задавая каждому test уникальное имя в конце каждого теста необходимо вызвать assert, чтобы проверить, выполнено ли условие когда вы знаете, что хотите написать тест, но не хотите писать его прямо сейчас, создайте тест как “pending” (ожидающий) с показанным синтаксисом Подобное использование ScalaTest похоже на JUnit. Теперь можно запустить эти тесты с помощью команды sbt test. Пропуская первые несколько строк вывода, результат выглядит следующим образом: sbt:HelloScalaTest&gt; test [info] Compiling 1 Scala source ... [info] MathUtilsTests: [info] - 'double' should handle 0 [info] - 'double' should handle 1 [info] - test with Int.MaxValue (pending) [info] Total number of tests run: 2 [info] Suites: completed 1, aborted 0 [info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 1 [info] All tests passed. [success] Total time: 1 s Поддержка многих видов тестов В этом примере демонстрируется стиль тестирования, аналогичный стилю xUnit Test-Driven Development (TDD), с некоторыми преимуществами Behavior-Driven Development (BDD). Как уже упоминалось, ScalaTest является гибким, и вы также можете писать тесты, используя другие стили, такие как стиль, похожий на RSpec Ruby. Вы также можете использовать моканные объекты, тестирование на основе свойств и использовать ScalaTest для тестирования кода Scala.js. Дополнительные сведения о различных доступных стилях тестирования см. в Руководстве пользователя на веб-сайте ScalaTest. Куда дальше? Дополнительные сведения о sbt и ScalaTest см. в следующих ресурсах: Sbt ScalaTest References: Scala3 book"
    } ,    
    {
      "title": "Worksheet",
      "url": "/scalaworkbook/docs/tools/tools-worksheets.html",
      "content": "{{page.title}} Worksheet - это файл Scala, который вычисляется при сохранении, и результат каждого выражения отображается в столбце справа от программы. Рабочие листы похожи на сеанс REPL и имеют поддержку редактора 1-го класса: завершение, гиперссылки, интерактивные ошибки при вводе и т.д. Рабочие листы используют расширение .worksheet.sc. Далее покажем, как использовать рабочие листы в IntelliJ и в VS Code (с расширением Metals). 1) Откройте проект Scala или создайте его: чтобы создать проект в IntelliJ, выберите “File” -&gt; “New” -&gt; “Project…”, выберите “Scala” в левой колонке и нажмите “Далее”, чтобы задать название проекта и каталог. чтобы создать проект в VS Code, выполните команду “Metals: New Scala project”, выберите начальный scala/scala3.g8, задайте местоположение проекта, откройте его в новом окне VS Code и импортируйте сборку. 2) Создайте файл с именем hello.worksheet.sc в каталоге src/main/scala/. в IntelliJ щелкните правой кнопкой мыши на каталоге src/main/scala/ и выберите “New”, а затем “File”. в VS Code щелкните правой кнопкой мыши на каталоге src/main/scala/ и выберите “New File”. 3) Вставьте следующее содержимое в редактор: println(\"Hello, world!\") val x = 1 x + x 4) Запустите worksheet: в IntelliJ щелкните зеленую стрелку в верхней части редактора, чтобы запустить worksheet в VS Code сохраните файл Вы должны увидеть результат выполнения каждой строки на правой панели (IntelliJ) или в виде комментариев (VS Code). IntelliJ: VS Code: Обратите внимание, что worksheet будет использовать версию Scala, определенную проектом (обычно задается ключом scalaVersion в файле build.sbt). Также обратите внимание, что worksheet не имеют точек входа в программу. Вместо этого операторы и выражения верхнего уровня оцениваются сверху вниз. References: Scala3 book"
    } ,    
    {
      "title": "Инструменты",
      "url": "/scalaworkbook/docs/modeling/tools.html",
      "content": "{{page.title}} В Scala 3 есть множество различных конструкций для моделирования: Классы (Classes) Объекты (Objects) Сопутствующие объекты (Companion objects) Трейты (Traits) Абстрактные классы (Abstract classes) Перечисления (Enums) Case classes Case objects В этом разделе кратко представлена каждая из этих языковых конструкций. Classes Как и в других языках, класс в Scala — это шаблон для создания экземпляров объекта. Вот несколько примеров классов: class Person(var name: String, var vocation: String) class Book(var title: String, var author: String, var year: Int) class Movie(var name: String, var director: String, var year: Int) Эти примеры показывают, как в Scala объявляются классы. В примере выше все параметры классов определены как поля var, что означает, что они изменяемы. Если необходимо, чтобы они были неизменяемыми, можно определить их как val или использовать case class. Новый экземпляр класса создается следующим образом (без ключевого слова new, благодаря универсальным apply методам): val p = Person(\"Robert Allen Zimmerman\", \"Harmonica Player\") Если есть экземпляр класса, такого как p, то можно получить доступ к его полям, которые в этом примере являются параметрами конструктора: p.name // res0: String = \"Robert Allen Zimmerman\" p.vocation // res1: String = \"Harmonica Player\" Как уже упоминалось, все эти параметры были созданы как поля var, поэтому их можно изменять: p.name = \"Bob Dylan\" p.vocation = \"Musician\" Поля и методы Классы также могут иметь методы и дополнительные поля, не являющиеся частью конструкторов. Они определены в теле класса. Тело инициализируется как часть конструктора по умолчанию: class Person(var firstName: String, var lastName: String): println(\"initialization begins\") val fullName = s\"$firstName $lastName\" def printFullName: Unit = println(fullName) printFullName println(\"initialization ends\") Пример демонстрирует, как происходит инициализация класса: val john = Person(\"John\", \"Doe\") // initialization begins // John Doe // initialization ends // john: Person = repl.MdocSession$App4$Person@5525b81e john.printFullName // John Doe Классы также могут расширять trait-ы и абстрактные классы, которые будут рассмотрены в специальных разделах ниже. Параметры по умолчанию Параметры конструктора класса также могут иметь значения по умолчанию: class Socket(val timeout: Int = 5_000, val linger: Int = 5_000): override def toString = s\"timeout: $timeout, linger: $linger\" Отличительной особенностью этой функции является то, что она позволяет пользователям кода создавать классы различными способами, как если бы у класса были альтернативные конструкторы: Socket() // res6: Socket = timeout: 5000, linger: 5000 Socket(2_500) // res7: Socket = timeout: 2500, linger: 5000 Socket(10_000, 10_000) // res8: Socket = timeout: 10000, linger: 10000 Socket(timeout = 10_000) // res9: Socket = timeout: 10000, linger: 5000 Socket(linger = 10_000) // res10: Socket = timeout: 5000, linger: 10000 При создании нового экземпляра класса также можно использовать именованные параметры. Это приветствуется и особенно полезно, когда параметры имеют одинаковый тип: Socket(10_000, 10_001) // res11: Socket = timeout: 10000, linger: 10001 Socket(timeout = 10_000, linger = 10_001) // res12: Socket = timeout: 10000, linger: 10001 Socket(linger = 10_000, timeout = 10_001) // res13: Socket = timeout: 10001, linger: 10000 Вспомогательные конструкторы В классе можно определить несколько конструкторов. Например, предположим, что нужно определить три конструктора класса Student: с именем и государственным ID (1) с именем, государственным ID и датой подачи заявления (2) с именем, государственным ID и студенческим ID (3) Пример описания класса с тремя этими конструкторами: import java.time.* class Student(var name: String, var govtId: String): // [1] основной конструктор private var _applicationDate: Option[LocalDate] = None private var _studentId: Int = 0 def this(name: String, govtId: String, applicationDate: LocalDate) = // [2] конструктор с датой подачи заявления this(name, govtId) _applicationDate = Some(applicationDate) def this(name: String, govtId: String, studentId: Int) = // [3] конструктор со студенческим id this(name, govtId) _studentId = studentId Эти конструкторы могут быть вызваны следующим образом: Student(\"Mary\", \"123\") Student(\"Mary\", \"123\", LocalDate.now) Student(\"Mary\", \"123\", 456) Для возможности создания классов несколькими способами можно использовать как параметры по умолчанию, так и несколько конструкторов, как в примере выше. Objects В Scala ключевое слово object создает одноэлементный объект (singleton). Другими словами, объект определяет класс, который имеет ровно один экземпляр. Он инициализируется лениво, когда ссылаются на его элементы, аналогично lazy val. Объекты в Scala позволяют группировать методы и поля в одном пространстве имен, аналогично тому, как используются статические члены класса в Java, Javascript (ES6) или @staticmethod в Python. Объекты имеют несколько применений: Они используются для создания коллекций служебных методов. companion object - это объект, имеющий то же имя, что и класс, с которым он совместно использует файл. В этой ситуации класс называется companion class. Они используются для имплементации traits для создания модулей. Объявление объекта аналогично объявлению класса. Вот пример объекта StringUtils, который содержит набор методов для работы со строками: object StringUtils: def truncate(s: String, length: Int): String = s.take(length) def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\") def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty Поскольку StringUtils является одноэлементным, его методы могут вызываться непосредственно в объекте: StringUtils.truncate(\"Chuck Bartowski\", 5) // res17: String = \"Chuck\" Импорт в Scala очень гибкий и позволяет импортировать все члены объекта: import StringUtils.* truncate(\"Chuck Bartowski\", 5) // res18: String = \"Chuck\" containsWhitespace(\"Sarah Walker\") // res19: Boolean = true isNullOrEmpty(\"John Casey\") // res20: Boolean = false Можно импортировать только часть методов: import StringUtils.{truncate, containsWhitespace} truncate(\"Charles Carmichael\", 7) containsWhitespace(\"Captain Awesome\") isNullOrEmpty(\"Morgan Grimes\") // Not found: isNullOrEmpty (error) Объекты также могут иметь поля, к которым можно обратиться, как к статистическим методам: object MathConstants: val PI = 3.14159 val E = 2.71828 println(MathConstants.PI) // 3.14159 Companion objects Объект, который имеет то же имя, что и класс, и объявлен в том же файле, что и класс, называется “сопутствующим объектом” (companion object). Аналогично, соответствующий класс называется сопутствующим классом объекта (companion class). Сопутствующий класс или объект может получить доступ к закрытым членам своего “соседа”. Сопутствующие объекты используются для методов и значений, которые не являются специфичными для экземпляров сопутствующего класса. В следующем примере класс Circle содержит метод с именем area, который специфичен для каждого экземпляра. А его сопутствующий объект содержит метод с именем calculateArea, который (а) не специфичен для экземпляра и (б) доступен для каждого экземпляра: import scala.math.* case class Circle(radius: Double): import Circle.* def area: Double = calculateArea(radius) object Circle: private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0) val circle = Circle(5.0) circle.area // res22: Double = 78.53981633974483 В этом примере метод area, доступный для каждого экземпляра Circle, использует метод calculateArea, определенный в сопутствующем объекте. Кроме того, поскольку calculateArea является закрытым, к нему нельзя получить доступ с помощью другого кода, но, как показано, его могут видеть экземпляры класса Circle. Другие виды использования сопутствующих объектов Сопутствующие объекты могут использоваться для нескольких целей: их можно использовать для группировки “статических” методов в пространстве имен, как в примере выше эти методы могут быть public или private если бы calculateArea был public, к нему можно было бы получить доступ из любого места как Circle.calculateArea они могут содержать методы apply, которые — благодаря некоторому синтаксическому сахару — работают как фабричные методы для создания новых экземпляров они могут содержать методы unapply, которые используются для деконструкции объектов, например, с помощью pattern matching Вот краткий обзор того, как методы apply можно использовать в качестве фабричных методов для создания новых объектов: class Person: var name = \"\" var age = 0 override def toString = s\"$name is $age years old\" object Person: def apply(name: String): Person = // a one-arg factory method val p = new Person p.name = name p def apply(name: String, age: Int): Person = // a two-arg factory method val p = new Person p.name = name p.age = age p end Person val joe = Person(\"Joe\") // joe: Person = Joe is 0 years old val fred = Person(\"Fred\", 29) // fred: Person = Fred is 29 years old Traits Если провести аналогию с Java, то Scala trait похож на интерфейс в Java 8+. trait-ы могут содержать: абстрактные методы и поля конкретные методы и поля могут иметь параметры конструктора, как и классы В базовом использовании trait может использоваться как интерфейс, определяющий только абстрактные члены, которые будут реализованы другими классами: trait Employee: def id: Int def firstName: String def lastName: String traits также могут содержать определенные методы: trait HasLegs: def numLegs: Int def walk(): Unit def stop() = println(\"Stopped walking\") trait HasTail: def tailColor: String def wagTail() = println(\"Tail is wagging\") def stopTail() = println(\"Tail is stopped\") Классы и объекты могут расширять несколько traits, что позволяет с их помощью создавать небольшие модули. class IrishSetter(name: String) extends HasLegs, HasTail: val numLegs = 4 val tailColor = \"Red\" def walk() = println(\"I’m walking\") override def toString = s\"$name is a Dog\" В классе IrishSetter реализованы все абстрактные параметры и методы, поэтому можно создать его экземпляр: val d = IrishSetter(\"Big Red\") // d: IrishSetter = Big Red is a Dog Класс также может переопределять методы trait-ов при необходимости. Абстрактные классы Когда необходимо написать класс, но известно, что в нем будут абстрактные члены, можно создать либо trait, либо абстрактный класс. В большинстве случаев желательно использовать trait, но исторически сложилось так, что было две ситуации, когда предпочтительнее использование абстрактного класса: необходимо создать базовый класс, который принимает аргументы конструктора код будет вызван из Java-кода Базовый класс, который принимает аргументы конструктора До Scala 3, когда базовому классу нужно было принимать аргументы конструктора, он объявлялся как абстрактный класс: abstract class Pet(name: String): def greeting: String def age: Int override def toString = s\"My name is $name, I say $greeting, and I’m $age\" class Dog(name: String, age: Int) extends Pet(name): val greeting = \"Woof\" val d = Dog(\"Fido\", 1) Однако в Scala 3 trait-ы могут иметь параметры, так что теперь в той же ситуации можно использовать trait-ы: trait Pet(name: String): def greeting: String def age: Int override def toString = s\"My name is $name, I say $greeting, and I’m $age\" class Dog(name: String, var age: Int) extends Pet(name): val greeting = \"Woof\" val d = Dog(\"Fido\", 1) trait-ы более гибки в составлении, потому что можно смешивать (наследовать) несколько trait-ов, но только один класс. В большинстве случаев trait-ы следует предпочитать классам и абстрактным классам. Правило выбора состоит в том, чтобы использовать классы всякий раз, когда необходимо создавать экземпляры определенного типа, и trait-ы, когда желательно разложить и повторно использовать поведение. Enums Перечисление (an enumeration) может быть использовано для определения типа, состоящего из конечного набора именованных значений (в разделе, посвященном моделированию ФП, будут показаны дополнительные возможности enums). Базовые перечисления используются для определения наборов констант, таких как месяцы в году, дни в неделе, направления, такие как север/юг/восток/запад, и многое другое. В качестве примера, рассмотрим перечисления, определяющие наборы атрибутов, связанных с пиццами: enum CrustSize: case Small, Medium, Large enum CrustType: case Thin, Thick, Regular enum Topping: case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions Для использования в коде enum необходимо импортировать: import CrustSize.* val currentCrustSize = Small Значения enum-ов можно сравнивать и использовать в матчинге: if (currentCrustSize == Small) println(\"If you buy a large pizza, you'll get a prize!\") // If you buy a large pizza, you'll get a prize! currentCrustSize match case Small =&gt; println(\"small\") case Medium =&gt; println(\"medium\") case Large =&gt; println(\"large\") // small Дополнительные возможности enums Перечисления могут иметь параметры конструктора: enum Color(val rgb: Int): case Red extends Color(0xFF0000) case Green extends Color(0x00FF00) case Blue extends Color(0x0000FF) а также содержать параметры и методы: enum Planet(mass: Double, radius: Double): private final val G = 6.67300E-11 def surfaceGravity = G * mass / (radius * radius) def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity case Mercury extends Planet(3.303e+23, 2.4397e6) case Earth extends Planet(5.976e+24, 6.37814e6) // more planets here ... Совместимость с Java enums Если необходимо использовать определенные в Scala перечисления в качестве перечислений Java, можно сделать это, расширив класс java.lang.Enum (который импортируется по умолчанию) следующим образом: enum Color extends Enum[Color] { case Red, Green, Blue } Параметр типа берется из определения Java enum и должен совпадать с типом перечисления. Нет необходимости предоставлять аргументы конструктора (как определено в документах Java API) для java.lang.Enum при его расширении — компилятор генерирует их автоматически. После определения Color его можно использовать так же, как если бы использовался Java enum: Color.Red.compareTo(Color.Green) Case classes Scala case class позволяет моделировать концепции с неизменяемыми структурами данных. case class обладает всеми функциональными возможностями класса, а также имеет встроенные дополнительные функции, которые делают их полезными для функционального программирования. case class имеет следующие эффекты и преимущества: Параметры конструктора case class по умолчанию являются общедоступными полями val, поэтому поля являются неизменяемыми, а методы доступа генерируются для каждого параметра. Генерируется метод unapply, который позволяет использовать case class в match выражениях. В классе создается метод copy, который позволяет создавать копии объекта без изменения исходного объекта. генерируются методы equals и hashCode для проверки структурного равенства, что позволяет использовать экземпляры case class в Map. генерируется метод toString, который полезен для отладки. Этот код демонстрирует несколько функций case class: case class Person(name: String, vocation: String) val person = Person(\"Reginald Kenneth Dwight\", \"Singer\") // person: Person = Person( // name = \"Reginald Kenneth Dwight\", // vocation = \"Singer\" // ) person.name // res27: String = \"Reginald Kenneth Dwight\" Необходимо помнить, что поля в case class-е неизменяемые: person.name = \"Joe\" // error: Reassignment to val name Остальные возможности продемонстрированы в коде: println(person) // Person(Reginald Kenneth Dwight,Singer) person match case Person(n, r) =&gt; println(\"name is \" + n) // name is Reginald Kenneth Dwight val elton = Person(\"Elton John\", \"Singer\") // elton: Person = Person(name = \"Elton John\", vocation = \"Singer\") person == elton // res30: Boolean = false case class BaseballTeam(name: String, lastWorldSeriesWin: Int) val cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908) // cubs1908: BaseballTeam = BaseballTeam( // name = \"Chicago Cubs\", // lastWorldSeriesWin = 1908 // ) val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016) // cubs2016: BaseballTeam = BaseballTeam( // name = \"Chicago Cubs\", // lastWorldSeriesWin = 2016 // ) Поддержка функционального программирования Как уже упоминалось ранее, case class-ы поддерживают функциональное программирование (ФП): ФП избегает изменения структур данных. Поэтому поля конструктора по умолчанию имеют значение val. Поскольку экземпляры case class не могут быть изменены, ими можно легко делиться, не опасаясь мутаций или условий гонки. вместо изменения экземпляра можно использовать метод copy в качестве шаблона для создания нового (потенциально измененного) экземпляра. Этот процесс можно назвать “обновлением по мере копирования”. наличие автоматически сгенерированного метода unapply позволяет использовать case class в сопоставлении шаблонов. Case objects Case object-ы относятся к объектам так же, как case class-ы относятся к классам: они предоставляют ряд автоматически генерируемых методов, чтобы сделать их более мощными. Case object-ы особенно полезны тогда, когда необходим одноэлементный объект, который нуждается в небольшой дополнительной функциональности, например, для использования с сопоставлением шаблонов в выражениях match. Case object-ы полезны, когда необходимо передавать неизменяемые сообщения. Например, представим проект музыкального проигрывателя, и создадим набор команд или сообщений: sealed trait Message case class PlaySong(name: String) extends Message case class IncreaseVolume(amount: Int) extends Message case class DecreaseVolume(amount: Int) extends Message case object StopPlaying extends Message Затем в других частях кода можно написать методы, которые используют сопоставление с образцом для обработки входящего сообщения (при условии, что методы playSong, changeVolume и stopPlayingSong определены где-то еще): def handleMessages(message: Message): Unit = message match case PlaySong(name) =&gt; playSong(name) case IncreaseVolume(amount) =&gt; changeVolume(amount) case DecreaseVolume(amount) =&gt; changeVolume(-amount) case StopPlaying =&gt; stopPlayingSong() References: Scala3 book, domain modeling tools Scala3 book, taste modeling Scala3 book, taste objects"
    } ,    
    {
      "title": "Утилиты",
      "url": "/scalaworkbook/docs/tools.html",
      "content": "{{page.title}} В этой главе представлены два способа написания и запуска программ Scala: путем создания проектов Scala, возможно содержащих несколько файлов, и определения точки входа в программу взаимодействуя с worksheet, который представляет собой программу, определенную в одном файле и выполняемую построчно References: Scala3 book"
    } ,    
    {
      "title": "Верхнеуровневые определения",
      "url": "/scalaworkbook/docs/toplevel-definitions.html",
      "content": "{{page.title}} В Scala 3 все виды определений могут быть записаны на “верхнем уровне” файлов исходного кода. Например, можно создать файл с именем MyCoolApp.scala и поместить в него данное содержимое: import scala.collection.mutable.ArrayBuffer enum Topping: case Cheese, Pepperoni, Mushrooms import Topping.* class Pizza: val toppings = ArrayBuffer[Topping]() val p = Pizza() extension (s: String) def capitalizeAllWords = s.split(\" \").map(_.capitalize).mkString(\" \") val hwUpper = \"hello, world\".capitalizeAllWords type Money = BigDecimal // по желанию дополнительные определения... @main def myApp = p.toppings += Cheese println(\"show me the code\".capitalizeAllWords) Как показано, нет необходимости помещать эти определения внутри пакета, класса или другой конструкции. Этот подход заменяет package objects из Scala 2. Но, будучи намного проще в использовании, они работают аналогично: когда вы помещаете определение в пакет с именем foo, вы можете получить доступ к этому определению во всех других пакетах в foo, например, в пакете foo.bar в этом примере: package foo { def double(i: Int) = i * 2 } package foo { package bar { @main def fooBarMain = println(s\"${double(1)}\") } } Фигурные скобки используются в этом примере, чтобы подчеркнуть вложенность пакета (они не обязательны для использования). Преимуществом такого подхода является то, что можно размещать определения в пакете с именем com.acme.myapp, а затем можно ссылаться на эти определения в com.acme.myapp.model, com.acme.myapp.controller и т.д. References: Scala3 book"
    } ,    
    {
      "title": "Класс типов",
      "url": "/scalaworkbook/docs/abstractions/type-classes.html",
      "content": "{{page.title}} Класс типов (type class) — это абстрактный параметризованный тип, который позволяет добавлять новое поведение к любому закрытому типу данных без использования подтипов. Если вы пришли с Java, то можно думать о классах типов как о чем-то вроде java.util.Comparator[T]. В статье “Type Classes as Objects and Implicits” (2010 г.) обсуждаются основные идеи, лежащие в основе классов типов в Scala. Несмотря на то, что в статье используется более старая версия Scala, идеи актуальны и по сей день. Этот стиль программирования полезен во многих случаях, например: выражение того, как тип, которым вы не владеете, например, из стандартной или сторонней библиотеки, соответствует такому поведению добавление поведения к нескольким типам без введения отношений подтипов между этими типами (например, когда один расширяет другой) В Scala 3 классы типов — это просто trait-ы с одним или несколькими параметрами типа, например: trait Show[A]: def show(a: A): String Экземпляры Show для определенного типа A свидетельствуют о том, что мы можем показать (т.е. создать текстовое представление) экземпляр типа A. Например, рассмотрим следующий экземпляр Show для Int: class ShowInt extends Show[Int]: def show(a: Int) = s\"The number is ${a}!\" Можно написать методы, которые работают с произвольными типами A, ограниченными Show, следующим образом: def toHtml[A](a: A)(showA: Show[A]): String = \"&lt;p&gt;\" + showA.show(a) + \"&lt;/p&gt;\" То есть toHtml можно вызывать с произвольным A, если также предоставить экземпляр Show[A]. Например, метод можно вызвать так: toHtml(42)(ShowInt()) // res0: String = \"&lt;p&gt;The number is 42!&lt;/p&gt;\" Автоматическая передача экземпляров класса типов Поскольку классы типов являются очень важным способом структурирования программного обеспечения, Scala 3 предлагает дополнительные функции, которые делают работу с ними очень удобной. Эти дополнительные функции, относящиеся к категории контекстуальных абстракций, рассматриваются в одной из последующих глав этой книги. References: Scala3 book"
    } ,    
    {
      "title": "Система типов",
      "url": "/scalaworkbook/docs/type-system.html",
      "content": "{{page.title}} Scala — уникальный язык, поскольку он статически типизирован, но часто кажется гибким и динамичным. Например, благодаря выводу типов можно писать код без явного указания типов переменных: val a = 1 val b = 2.0 val c = \"Hi!\" Это делает код динамически типизированным. А благодаря новым функциям в Scala 3, таким как объединение типов, также можно писать код, подобный следующему, который кратко выражает, какие значения ожидаются в качестве аргументов и какие типы возвращаются: def isTruthy(a: Boolean | Int | String): Boolean = ??? def dogCatOrWhatever(): Dog | Plant | Car | Sun = ??? Как видно из примера, при использовании объединения типы необязательно должны иметь общую иерархию, и их по-прежнему можно принимать в качестве аргументов или возвращать из метода. При разработке приложений такие функции, как вывод типов, используются каждый день, а generics - каждую неделю. При чтении Scaladoc для классов и методов, также необходимо иметь некоторое представление о ковариантности. Использование типов может быть относительно простым, а также обеспечивает большую выразительность, гибкость и контроль для разработчиков библиотек. Преимущества типов Языки программирования со статической типизацией предлагают ряд преимуществ, в том числе: помощь IDE в обеспечении надежной поддержки устранение многих классов потенциальных ошибок во время компиляции помощь в рефакторинге предоставление надежной документации, которая не может быть нерелевантной, поскольку проверена на тип References: Scala3 book"
    } ,    
    {
      "title": "Алгебраические типы данных",
      "url": "/scalaworkbook/docs/type-system/types-adts.html",
      "content": "{{page.title}} Алгебраические типы данных (ADT) могут быть созданы с помощью конструкции enum, поэтому кратко рассмотрим перечисления, прежде чем рассматривать ADT. Перечисления Перечисление используется для определения типа, состоящего из набора именованных значений: enum Color: case Red, Green, Blue который можно рассматривать как сокращение для: enum Color(val rgb: Int): case Red extends Color(0xFF0000) case Green extends Color(0x00FF00) case Blue extends Color(0x0000FF) Таким образом, каждый из различных вариантов имеет параметр rgb, которому присваивается соответствующее значение: println(Color.Green.rgb) // 65280 Кастомные перечисления Перечисления также могут иметь кастомные определения: enum Planet(mass: Double, radius: Double): private final val G = 6.67300E-11 def surfaceGravity = G * mass / (radius * radius) def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity case Mercury extends Planet(3.303e+23, 2.4397e6) case Venus extends Planet(4.869e+24, 6.0518e6) case Earth extends Planet(5.976e+24, 6.37814e6) // остальные планеты ... Подобно классам и case классам, для перечисления также можно определить сопутствующий объект: object Planet: def main(args: Array[String]) = val earthWeight = args(0).toDouble val mass = earthWeight / Earth.surfaceGravity for (p &lt;- values) println(s\"Your weight on $p is ${p.surfaceWeight(mass)}\") Алгебраические типы данных (ADT) Концепция enum является достаточно общей, чтобы также поддерживать алгебраические типы данных (ADT) и их обобщенную версию (GADT). Вот пример, показывающий, как тип Option может быть представлен в виде ADT: enum Option[+T]: case Some(x: T) case None В этом примере создается Option enum с параметром ковариантного типа T, состоящим из двух вариантов: Some и None. Some параметризуются параметром значения x; это сокращение для написания case класса, который расширяет Option. Поскольку None не параметризован, он обрабатывается как обычное значение enum. Предложения extends, которые были опущены в предыдущем примере, также могут быть указаны явно: enum Option[+T]: case Some(x: T) extends Option[T] case None extends Option[Nothing] Как и в случае с обычными значениями enum, case enum определяются в сопутствующем объекте перечисления, поэтому они называются Option.Some и Option.None (если только определения не “вытягиваются” при импорте): Option.Some(\"hello\") // res1: Option[String] = Some(x = \"hello\") Option.None // res2: Option[Nothing] = None Как и в других случаях использования перечисления, АТД могут определять дополнительные методы. Например, вот снова Option с методом isDefined и конструктором Option(...) в сопутствующем объекте: enum Option[+T]: case Some(x: T) case None def isDefined: Boolean = this match case None =&gt; false case Some(_) =&gt; true object Option: def apply[T &gt;: Null](x: T): Option[T] = if (x == null) None else Some(x) Перечисления и ADT используют одну и ту же синтаксическую конструкцию, поэтому их можно рассматривать просто как два конца спектра, и вполне возможно создавать гибриды. Например, приведенный ниже код дает реализацию Color либо с тремя значениями перечисления, либо с параметризованным case, который принимает значение RGB: enum Color(val rgb: Int): case Red extends Color(0xFF0000) case Green extends Color(0x00FF00) case Blue extends Color(0x0000FF) case Mix(mix: Int) extends Color(mix) Рекурсивные перечисления До сих пор все перечисления состояли только из различных вариантов значений или case class-ов. Перечисления также могут быть рекурсивными, как показано в приведенном ниже примере кодирования натуральных чисел: enum Nat: case Zero case Succ(n: Nat) Например, значение Succ(Succ(Zero)) представляет число 2 в унарной кодировке. Очень похожим образом могут быть определены списки: enum List[+A]: case Nil case Cons(head: A, tail: List[A]) Обобщенные алгебраические типы данных (GADT) Приведенная выше нотация для перечислений очень лаконична и служит идеальной отправной точкой для моделирования типов данных. Также возможно выразить гораздо более мощные типы: обобщенные алгебраические типы данных (GADTs). Вот пример GADT, где параметр типа (T) определяет содержимое, хранящееся в поле: enum Box[T](contents: T): case IntBox(n: Int) extends Box[Int](n) case BoolBox(b: Boolean) extends Box[Boolean](b) Сопоставление с шаблоном в конкретном конструкторе (IntBox или BoolBox) восстанавливает информацию о типе: def extract[T](b: Box[T]): T = b match case IntBox(n) =&gt; n + 1 case BoolBox(b) =&gt; !b Безопасно возвращать Int только в первом случае, так как из сопоставления с шаблоном известно, что b был IntBox. Дешугаризация перечислений Концептуально перечисления можно рассматривать как определение закрытого класса вместе с сопутствующим ему объектом. Давайте посмотрим на дешугаризацию перечисления Color: sealed abstract class Color(val rgb: Int) extends scala.reflect.Enum object Color: case object Red extends Color(0xFF0000) { def ordinal = 0 } case object Green extends Color(0x00FF00) { def ordinal = 1 } case object Blue extends Color(0x0000FF) { def ordinal = 2 } case class Mix(mix: Int) extends Color(mix) { def ordinal = 3 } def fromOrdinal(ordinal: Int): Color = ordinal match case 0 =&gt; Red case 1 =&gt; Green case 2 =&gt; Blue case _ =&gt; throw new NoSuchElementException(ordinal.toString) Вышеописанная дешугаризация упрощена, и некоторые детали были опущены намеренно. Хотя перечисления можно кодировать вручную с помощью других конструкций, использование enum является более кратким, а также включает несколько дополнительных утилит (таких как метод fromOrdinal). References: Scala3 book"
    } ,    
    {
      "title": "Зависимые типы функций",
      "url": "/scalaworkbook/docs/type-system/types-dependent-function.html",
      "content": "{{page.title}} Зависимый тип функции (dependent function type) описывает типы функций, где тип результата может зависеть от значений параметров функции. Концепция зависимых типов и типов зависимых функций является более продвинутой, и обычно с ней сталкиваются только при разработке собственных библиотек или использовании расширенных библиотек. Зависимые типы методов Рассмотрим следующий пример гетерогенной базы данных, в которой могут храниться значения разных типов. Ключ содержит информацию о типе соответствующего значения: trait Key { type Value } trait DB { def get(k: Key): Option[k.Value] // зависимый метод } Получив ключ, метод get предоставляет доступ к карте и потенциально возвращает сохраненное значение типа k.Value. Мы можем прочитать этот path-dependent type как: “в зависимости от конкретного типа аргумента k возвращается соответствующее значение”. Например, у нас могут быть следующие ключи: object Name extends Key { type Value = String } object Age extends Key { type Value = Int } Вызовы метода get теперь будут возвращать такие типы: val db: DB = ... val res1: Option[String] = db.get(Name) val res2: Option[Int] = db.get(Age) Вызов метода db.get(Name) возвращает значение типа Option[String], а вызов db.get(Age) возвращает значение типа Option[Int]. Тип возвращаемого значения зависит от конкретного типа аргумента, переданного для get — отсюда и название dependent type. Зависимые типы функций Как видно выше, в Scala 2 уже была поддержка зависимых типов методов. Однако создание значений типа DB довольно громоздко: // создание пользователя DB def user(db: DB): Unit = db.get(Name) ... db.get(Age) // создание экземпляра DB и передача его `user` user(new DB { def get(k: Key): Option[k.Value] = ... // implementation of DB }) Необходимо вручную создать анонимный внутренний класс DB, реализующий метод get. Для кода, основанного на создании множества различных экземпляров DB, это очень утомительно. DB trait имеет только один абстрактный метод get. Было бы неплохо использовать в этом месте лямбда-синтаксис… user { k =&gt; ... // implementation of DB } На самом деле, в Scala 3 теперь это возможно! Можно определить DB как зависимый тип функции: type DB = (k: Key) =&gt; Option[k.Value] // ^^^^^^^^^^^^^^^^^^^^^^^^^^^ // зависимый тип функции Учитывая это определение DB, можно использовать приведенный выше вызов user. Подробнее о зависимых типах функций можно прочитать в справочной документации. Практический пример: числовые выражения Предположим, что необходимо определить модуль, который абстрагируется от внутреннего представления чисел. Это может быть полезно, например, для реализации библиотек для автоматического дифференцирования. Начнем с определения модуля для чисел: trait Nums: // тип Num оставлен абстрактным type Num // некоторые операции над числами def lit(d: Double): Num def add(l: Num, r: Num): Num def mul(l: Num, r: Num): Num Здесь опускается конкретная реализация Nums, но в качестве упражнения можно реализовать Nums, назначив тип Num = Double и реализуя соответствующие методы. Программа, использующая числовую абстракцию, теперь имеет следующий тип: type Prog = (n: Nums) =&gt; n.Num =&gt; n.Num val ex: Prog = nums =&gt; x =&gt; nums.add(nums.lit(0.8), x) Тип функции, которая вычисляет производную, наподобие ex: def derivative(input: Prog): Double Учитывая удобство зависимых типов функций, вызов этой функции в разных программах прост: derivative { nums =&gt; x =&gt; x } derivative { nums =&gt; x =&gt; nums.add(nums.lit(0.8), x) } // ... Напомним, что та же программа в приведенной выше кодировке будет выглядеть так: derivative(new Prog { def apply(nums: Nums)(x: nums.Num): nums.Num = x }) derivative(new Prog { def apply(nums: Nums)(x: nums.Num): nums.Num = nums.add(nums.lit(0.8), x) }) // ... Комбинация с контекстными функциями Комбинация методов расширения, контекстных функций и зависимых функций обеспечивает мощный инструмент для разработчиков библиотек. Например, мы можем уточнить нашу библиотеку, как указано выше, следующим образом: trait NumsDSL extends Nums: extension (x: Num) def +(y: Num) = add(x, y) def *(y: Num) = mul(x, y) def const(d: Double)(using n: Nums): n.Num = n.lit(d) type Prog = (n: NumsDSL) ?=&gt; n.Num =&gt; n.Num // ^^^ // prog теперь - контекстная функция, которая неявно предполагает NumsDSL в контексте вызова def derivative(input: Prog): Double = ... // теперь нам не нужно упоминать Nums в приведенных ниже примерах derivative { x =&gt; const(1.0) + x } derivative { x =&gt; x * x + const(2.0) } // ... References: Scala3 book"
    } ,    
    {
      "title": "Generics типы",
      "url": "/scalaworkbook/docs/type-system/types-generics.html",
      "content": "{{page.title}} Универсальные (generic) классы (или trait-ы) принимают тип в качестве параметра в квадратных скобках [...]. Для обозначения параметров типа согласно конвенции Scala используется одна заглавная буква (например, A). Затем этот тип можно использовать внутри класса по мере необходимости для параметров экземпляра метода или для возвращаемых типов: // здесь мы объявляем параметр типа A // v class Stack[A]: private var elements: List[A] = Nil // ^ // здесь мы ссылаемся на этот тип // v def push(x: A): Unit = { elements = elements.prepended(x) } def peek: A = elements.head def pop(): A = val currentTop = peek elements = elements.tail currentTop Эта реализация класса Stack принимает любой тип в качестве параметра. Прелесть дженериков состоит в том, что теперь можно создавать Stack[Int], Stack[String] и т. д., что позволяет повторно использовать реализацию Stack для произвольных типов элементов. Пример создания и использования Stack[Int]: val stack = Stack[Int] stack.push(1) stack.push(2) println(stack.pop()) // 2 println(stack.pop()) // 1 Подробности о том, как выразить ковариантность с помощью универсальных типов, см. в разделе “Ковариантность”. References: Scala3 book"
    } ,    
    {
      "title": "Определение типов",
      "url": "/scalaworkbook/docs/type-system/types-inferred.html",
      "content": "{{page.title}} Как и в других статически типизированных языках программирования, в Scala тип можно объявить при создании новой переменной: val x: Int = 1 val y: Double = 1 В этих примерах типы явно объявлены как Int и Double соответственно. Однако в Scala обычно не нужно объявлять тип при объявлении переменной: val a = 1 // a: Int = 1 val b = List(1, 2, 3) // b: List[Int] = List(1, 2, 3) val m = Map(1 -&gt; \"one\", 2 -&gt; \"two\") // m: Map[Int, String] = Map(1 -&gt; \"one\", 2 -&gt; \"two\") Scala сама выводит типы, как показано выше. Действительно, большинство переменных определяются без указания типа, и способность Scala автоматически определять его — это одна из особенностей, которая делает Scala похожим на язык с динамической типизацией. References: Scala3 book"
    } ,    
    {
      "title": "Пересечение типов",
      "url": "/scalaworkbook/docs/type-system/types-intersection.html",
      "content": "{{page.title}} Используемый для типов оператор &amp; создает так называемый тип пересечения (intersection type). Тип A &amp; B представляет собой значения, которые одновременно относятся как к типу A, так и к типу B. Например, в следующем примере используется тип пересечения Resettable &amp; Growable[String]: trait Resettable: def reset(): Unit trait Growable[A]: def add(a: A): Unit def f(x: Resettable &amp; Growable[String]): Unit = x.reset() x.add(\"first\") В методе f в этом примере параметр x должен быть как Resettable, так и Growable[String]. Все члены типа пересечения A и B являются типом A и типом B. Следовательно, как показано, Resettable &amp; Growable[String] имеет методы reset и add. Пересечение типов может быть полезно для структурного описания требований. В примере выше для f мы прямо заявляем, что нас устраивает любое значение для x, если оно является подтипом как Resettable, так и Growable. Нет необходимости создавать номинальный вспомогательный trait, подобный следующему: trait Both[A] extends Resettable, Growable[A] def f(x: Both[String]): Unit Существует важное различие между двумя вариантами определения f: в то время как оба позволяют вызывать f с экземплярами Both, только первый позволяет передавать экземпляры, которые являются подтипами Resettable и Growable[String], но не Both[String]. Обратите внимание, что &amp; коммутативно: A &amp; B имеет тот же тип, что и B &amp; A. References: Scala3 book"
    } ,    
    {
      "title": "Непрозрачные типы",
      "url": "/scalaworkbook/docs/type-system/types-opaque.html",
      "content": "{{page.title}} Непрозрачные (opaque) псевдонимы типов Scala 3 обеспечивают абстракции типов без каких-либо накладных расходов. Накладные расходы на абстракцию Предположим, что необходимо определить модуль, предлагающий арифметические операции над числами, которые представлены их логарифмами. Это может быть полезно для повышения точности, когда числовые значения очень большие или близкие к нулю. Поскольку важно отличать “обычные” двойные значения от чисел, хранящихся в виде их логарифмов, введем класс Logarithm: class Logarithm(protected val underlying: Double): def toDouble: Double = math.exp(underlying) def + (that: Logarithm): Logarithm = // здесь используется метод apply сопутствующего объекта Logarithm(this.toDouble + that.toDouble) def * (that: Logarithm): Logarithm = new Logarithm(this.underlying + that.underlying) object Logarithm: def apply(d: Double): Logarithm = new Logarithm(math.log(d)) Метод apply сопутствующего объекта позволяет создавать значения типа Logarithm, которые можно использовать следующим образом: val l2 = Logarithm(2.0) val l3 = Logarithm(3.0) println((l2 * l3).toDouble) // 6.0 println((l2 + l3).toDouble) // 4.999999999999999 В то время как класс Logarithm предлагает хорошую абстракцию для значений Double, которые хранятся в этой конкретной логарифмической форме, это накладывает серьезные накладные расходы на производительность: для каждой отдельной математической операции нужно извлекать значение underlying, а затем снова обернуть его в новый экземпляр Logarithm. Модульные абстракции Рассмотрим другой подход к реализации той же библиотеки. На этот раз вместо того, чтобы определять Logarithm как класс, определяем его с помощью псевдонима типа. Во-первых, зададим абстрактный интерфейс модуля: trait Logarithms: type Logarithm // operations on Logarithm def add(x: Logarithm, y: Logarithm): Logarithm def mul(x: Logarithm, y: Logarithm): Logarithm // functions to convert between Double and Logarithm def make(d: Double): Logarithm def extract(x: Logarithm): Double // extension methods to use `add` and `mul` as \"methods\" on Logarithm extension (x: Logarithm) def toDouble: Double = extract(x) def + (y: Logarithm): Logarithm = add(x, y) def * (y: Logarithm): Logarithm = mul(x, y) Теперь давайте реализуем этот абстрактный интерфейс, задав тип Logarithm равным Double: object LogarithmsImpl extends Logarithms: type Logarithm = Double // operations on Logarithm def add(x: Logarithm, y: Logarithm): Logarithm = make(x.toDouble + y.toDouble) def mul(x: Logarithm, y: Logarithm): Logarithm = x + y // functions to convert between Double and Logarithm def make(d: Double): Logarithm = math.log(d) def extract(x: Logarithm): Double = math.exp(x) В рамках реализации LogarithmsImpl уравнение Logarithm = Double позволяет реализовать различные методы. Дырявые абстракции Однако эта абстракция немного “дырява”. Мы должны убедиться, что всегда программируем только с абстрактным интерфейсом Logarithms и никогда не используем LogarithmsImpl напрямую. Прямое использование LogarithmsImpl сделало бы равенство Logarithm = Double видимым для пользователя, который может случайно использовать Double там, где ожидается логарифмическое удвоение. Например: import LogarithmsImpl.* val l: Logarithm = make(1.0) val d: Double = l // type checks AND leaks the equality! Необходимость разделения модуля на абстрактный интерфейс и реализацию может быть полезной, но также требует больших усилий, чтобы просто скрыть детали реализации Logarithm. Программирование с использованием абстрактного модуля Logarithms может быть очень утомительным и часто требует использования дополнительных функций, таких как типы, зависящие от пути, как в следующем примере: def someComputation(L: Logarithms)(init: L.Logarithm): L.Logarithm = ... Накладные расходы упаковки/распаковки Абстракции типов, такие как type Logarithm, стираются в соответствии с их привязкой (Any - в нашем случае). То есть, хотя нам не нужно вручную переносить и разворачивать значение Double, все равно будут некоторые накладные расходы, связанные с упаковкой примитивного типа Double. Непрозрачные типы Вместо того, чтобы вручную разбивать компонент Logarithms на абстрактную часть и на конкретную реализацию, можно просто использовать opaque типы для достижения аналогичного эффекта: object Logarithms: // !!! opaque type Logarithm = Double object Logarithm: def apply(d: Double): Logarithm = math.log(d) extension (x: Logarithm) def toDouble: Double = math.exp(x) def + (y: Logarithm): Logarithm = Logarithm(math.exp(x) + math.exp(y)) def * (y: Logarithm): Logarithm = x + y Тот факт, что Logarithm совпадает с Double, известен только в области, где он определен, которая в приведенном выше примере соответствует объекту Logarithms. Равенство Logarithm = Double может использоваться для реализации методов (например, * и toDouble). Однако за пределами модуля тип Logarithm полностью инкапсулирован или “непрозрачен” (opaque). Для пользователей невозможно обнаружить его реализацию: import Logarithms.* val l2 = Logarithm(2.0) val l3 = Logarithm(3.0) println((l2 * l3).toDouble) // prints 6.0 println((l2 + l3).toDouble) // prints 4.999... val d: Double = l2 // ERROR: Found Logarithm required Double Несмотря на то, что мы абстрагировались от Logarithm, абстракция предоставляется бесплатно: поскольку существует только одна реализация, во время выполнения не будет накладных расходов на упаковку для примитивных типов, таких как Double. Резюме Непрозрачные типы предлагают надежную абстракцию над деталями реализации, не накладывая расходов на производительность. Как показано выше, непрозрачные типы удобны в использовании и очень хорошо интегрируются с функцией методов расширения. References: Scala3 book"
    } ,    
    {
      "title": "Другие типы",
      "url": "/scalaworkbook/docs/type-system/types-others.html",
      "content": "{{page.title}} В Scala есть несколько других расширенных типов, в том числе: type lambdas match types existential types higher-kinded types singleton types refinement types kind polymorphism References: Scala3 book"
    } ,    
    {
      "title": "Структурные типы",
      "url": "/scalaworkbook/docs/type-system/types-structural.html",
      "content": "{{page.title}} Некоторые варианты использования, такие как моделирование доступа к базе данных, более удобны в динамически типизированных языках, чем в статически типизированных языках. С динамически типизированными языками естественно моделировать строку как запись или объект и выбирать записи с помощью простых точечных обозначений, например row.columnName. Достижение того же результата в статически типизированном языке требует определения класса для каждой возможной строки, возникающей в результате манипуляций с базой данных, включая строки, возникающие в результате join и проектирования, и настройки схемы для сопоставления между строкой и представляющим ее классом. Это требует большого количества шаблонов, что заставляет разработчиков менять преимущества статической типизации на более простые схемы, в которых имена столбцов представляются в виде строк и передаются другим операторам, например row.select(\"columnName\"). Этот подход лишен преимуществ статической типизации и все еще не так естественен, как динамически типизируемая версия. Структурные типы (structural types) помогают в ситуациях, когда желательно поддерживать простую точечную нотацию в динамических контекстах, не теряя преимуществ статической типизации. Они также позволяют разработчикам настраивать, как должны определяться поля и методы. Пример Вот пример структурного типа Person: class Record(elems: (String, Any)*) extends Selectable: private val fields = elems.toMap def selectDynamic(name: String): Any = fields(name) type Person = Record { val name: String val age: Int } Тип Person добавляет уточнение (refinement) к своему родительскому типу Record, которое определяет поля name и age. Говорится, что уточнение носит структурный (structural) характер, поскольку name и age не определены в родительском типе. Но тем не менее они существуют как члены класса Person. Например, следующая программа напечатала бы “Emma is 42 years old.”: val person = Record( \"name\" -&gt; \"Emma\", \"age\" -&gt; 42 ).asInstanceOf[Person] println(s\"${person.name} is ${person.age} years old.\") Родительский тип Record в этом примере представляет собой универсальный класс, который может в своем аргументе elems принимать произвольные записи. Этот аргумент - последовательность пар ключей типа String и значений типа Any. Когда создается Person как Record, необходимо с помощью приведения типов задать, что запись определяет правильные поля правильных типов. Сама Record слишком слабо типизирована, поэтому компилятор не может знать об этом без помощи пользователя. На практике связь между структурным типом и его базовым общим представлением, скорее всего, будет выполняться на уровне базы данных и, следовательно, не будет беспокоить конечного пользователя. Record расширяет маркер trait scala.Selectable и определяет метод selectDynamic, который сопоставляет имя поля с его значением. Выбор элемента структурного типа выполняется путем вызова соответствующего метода. person.name и person.age преобразуются компилятором Scala в: person.selectDynamic(\"name\").asInstanceOf[String] person.selectDynamic(\"age\").asInstanceOf[Int] Второй пример Чтобы закрепить сказанное, вот еще один структурный тип с именем Book, представляющий книгу, доступную в базе данных: type Book = Record { val title: String val author: String val year: Int val rating: Double } Как и в случае с Person, экземпляр Book создается следующим образом: val book = Record( \"title\" -&gt; \"The Catcher in the Rye\", \"author\" -&gt; \"J. D. Salinger\", \"year\" -&gt; 1951, \"rating\" -&gt; 4.5 ).asInstanceOf[Book] Класс Selectable Помимо selectDynamic класс Selectable иногда также определяет метод applyDynamic, который можно использовать для замены вызовов функций на вызов структурных элементов. Таким образом, если a является экземпляром Selectable, структурный вызов типа a.f(b, c) преобразуется в: a.applyDynamic(\"f\")(b, c) References: Scala3 book"
    } ,    
    {
      "title": "Объединение типов",
      "url": "/scalaworkbook/docs/type-system/types-union.html",
      "content": "{{page.title}} Используемый для типов | оператор создает так называемый тип объединения (union type). Тип А | B представляет значения, которые относятся либо к типу A, либо к типу B. В следующем примере метод help принимает параметр с именем id типа объединения Username | Password, который может быть либо Username, либо Password: case class Username(name: String) case class Password(hash: Hash) def help(id: Username | Password) = val user = id match case Username(name) =&gt; lookupName(name) case Password(hash) =&gt; lookupPassword(hash) // ... help реализуется используя pattern matching. Этот код является гибким и типобезопасным решением. Если попытаться передать тип, отличный от Username или Password, компилятор пометит это как ошибку: help(\"hi\") // error: Found: (\"hi\" : String) // Required: Username | Password Ошибка также будет получена, если попытаться добавить case в выражение match, которое не соответствует типам Username или Password: case 1.0 =&gt; ??? // ERROR: this line won’t compile Альтернатива объединенным типам Как показано, объединенные типы могут использоваться для представления вариантов нескольких разных типов, не требуя, чтобы эти типы были частью специально созданной иерархии классов. Предварительное планирование иерархии классов Другие языки требуют предварительного планирования иерархии классов, как показано в следующем примере: trait UsernameOrPassword case class Username(name: String) extends UsernameOrPassword case class Password(hash: Hash) extends UsernameOrPassword def help(id: UsernameOrPassword) = ... Предварительное планирование не очень хорошо масштабируется, поскольку, например, требования пользователей API могут быть непредсказуемыми. Кроме того, загромождение иерархии типов маркерами типа UsernameOrPassword затрудняет чтение кода. Теговые объединения Другой альтернативой является задание отдельного типа перечисления, например: enum UsernameOrPassword: case IsUsername(u: Username) case IsPassword(p: Password) Перечисление UsernameOrPassword представляет собой помеченное объединение Username и Password. Однако этот способ моделирования объединения требует явной упаковки и распаковки, и, например, Username не является подтипом UsernameOrPassword. Вывод типов объединения Компилятор присваивает типу объединения выражение, только если такой тип явно задан. Например, рассмотрим такие значения: val name = Username(\"Eve\") // name: Username = Username(name = \"Eve\") val password = Password(123) // password: Password = Password(hash = 123) В этом примере показано, как можно использовать тип объединения при привязке переменной к результату выражения if/else: val a = if (true) name else password // a: Object = Username(name = \"Eve\") val b: Password | Username = if (true) name else password // b: Password | Username = Username(name = \"Eve\") Типом a является Object, который является супертипом Username и Password, но не наименьшим супертипом, Password | Username. Если необходим наименьший супертип, его нужно указать явно, как это делается для b. Типы объединения являются двойственными типам пересечения. И как &amp; с типами пересечения, | также коммутативен: A | B того же типа, что и B | А. References: Scala3 book"
    } ,    
    {
      "title": "Ковариантность типов",
      "url": "/scalaworkbook/docs/type-system/types-variance.html",
      "content": "{{page.title}} Вариантность параметра типа управляет подтипом параметризованных типов (таких, как классы или trait-ы). Чтобы разобраться в вариантности, рассмотрим следующий пример типов: trait Item { def productNumber: String } trait Buyable extends Item { def price: Int } trait Book extends Buyable { def isbn: String } Предположим также следующие параметризованные типы: // пример инвариантного типа trait Pipeline[T]: def process(t: T): T // пример ковариантного типа trait Producer[+T]: def make: T // пример контрвариантного типа trait Consumer[-T]: def take(t: T): Unit В целом существует три режима вариантности (variance): инвариант (invariant) — значение по умолчанию, написанное как Pipeline[T] ковариантный (covariant) — помечен знаком +, например Producer[+T] контравариантный (contravariant) — помечен знаком -, как в Consumer[-T] Подробнее рассмотрим, что означает и как используется эта аннотация. Инвариантные типы По умолчанию такие типы, как Pipeline, инвариантны в своем аргументе типа (в данном случае T). Это означает, что такие типы, как Pipeline[Item], Pipeline[Buyable] и Pipeline[Book], не являются подтипами друг друга. Предположим, что следующий метод использует два значения (b1, b2) типа Pipeline[Buyable] и передает свой аргумент b методу process при его вызове на b1 и b2: def oneOf( p1: Pipeline[Buyable], p2: Pipeline[Buyable], b: Buyable ): Buyable = val b1 = p1.process(b) val b2 = p2.process(b) if b1.price &lt; b2.price then b1 else b2 Напомним, что отношения подтипов между типами следующие: Book &lt;: Buyable &lt;: Item. Мы не можем передать Pipeline[Book] методу oneOf, потому что в реализации oneOf мы вызываем p1 и p2 со значением типа Buyable. Pipeline[Book] ожидает Book, что потенциально может вызвать runtime error. Мы не можем передать Pipeline[Item], потому что вызов process обещает вернуть Item; однако мы должны вернуть Buyable. Почему Инвариант? На самом деле тип Pipeline должен быть инвариантным, так как он использует свой параметр типа T и в качестве аргумента, и в качестве типа возвращаемого значения. По той же причине некоторые типы в библиотеке коллекций Scala, такие как Array или Set, также являются инвариантными. Ковариантные типы В отличие от Pipeline, который является инвариантным, тип Producer помечается как ковариантный (covariant) путем добавления к параметру типа префикса +. Это допустимо, так как параметр типа используется только в качестве типа возвращаемого значения. Пометка типа как ковариантного означает, что мы можем передать (или вернуть) Producer[Book] там, где ожидается Producer[Buyable]. И на самом деле, это разумно. Тип Producer[Buyable].make только обещает вернуть Buyable. Но для пользователей make, так же допустимо принять Book, который является подтипом Buyable. Это иллюстрируется следующим примером, где функция makeTwo ожидает Producer[Buyable]: def makeTwo(p: Producer[Buyable]): Int = p.make.price + p.make.price Допустимо передать в makeTwo производителя книг: val bookProducer: Producer[Book] = ??? makeTwo(bookProducer) Вызов price в рамках makeTwo по-прежнему действителен и для Book. Ковариантные типы для неизменяемых контейнеров Ковариантность чаще всего встречается при работе с неизменяемыми контейнерами, такими как List, Seq, Vector и т.д. Например, List и Vector определяются приблизительно так: class List[+A] ... class Vector[+A] ... Таким образом, можно использовать List[Book] там, где ожидается List[Buyable]. Это также интуитивно имеет смысл: если ожидается коллекция вещей, которые можно купить, то вполне допустимо получить коллекцию книг. В примере выше у книг есть дополнительный метод isbn, но дополнительные возможности можно игнорировать. Контравариантные типы В отличие от типа Producer, который помечен как ковариантный, тип Consumer помечен как контравариантный (contravariant) путем добавления к параметру типа префикса -. Это допустимо, так как параметр типа используется только в позиции аргумента. Пометка его как контравариантного означает, что можно передать (или вернуть) Consumer[Item] там, где ожидается Consumer[Buyable]. То есть у нас есть отношение подтипа Consumer[Item] &lt;: Consumer[Buyable]. Помните, что для типа Producer все было наоборот, и у нас был Producer[Buyable] &lt;: Producer[Item]. Метод Consumer[Item].take принимает Item. Как вызывающий take, мы также можем предоставить Buyable, который будет с радостью принят Consumer[Item], поскольку Buyable — это подтип Item, то есть, по крайней мере, Item. Контравариантные типы для потребителей Контравариантные типы встречаются гораздо реже, чем ковариантные типы. Наиболее важным типом, помеченным как контравариантный, с которым можно столкнуться, является тип функций: trait Function[-A, +B]: def apply(a: A): B Тип аргумента A помечен как контравариантный A — он использует значения типа A. Тип результата B, напротив, помечен как ковариантный — он создает значения типа B. Вот несколько примеров, иллюстрирующих отношения подтипов, вызванные аннотациями вариантности функций: val f: Function[Buyable, Buyable] = b =&gt; b // OK - допустимо вернуть Buyable там, где ожидается Item val g: Function[Buyable, Item] = f // OK - допустимо передать аргумент Book туда, где ожидается Buyable val h: Function[Book, Buyable] = f Резюме В этом разделе были рассмотрены три различных вида вариантности: Producers обычно ковариантны и помечают свой параметр типа со знаком +. Это справедливо и для неизменяемых коллекций. Consumers обычно контравариантны и помечают свой параметр типа со знаком -. Типы, которые являются одновременно производителями и потребителями, должны быть инвариантными и не требуют какой-либо маркировки для параметра своего типа. В эту категорию, в частности, попадают изменяемые коллекции, такие как Array. References: Scala3 book"
    } ,    
    {
      "title": "Переменные и типы данных",
      "url": "/scalaworkbook/docs/types.html",
      "content": "{{page.title}} В этом разделе представлен обзор переменных и типов данных Scala. Два вида переменных Переменная может быть неизменяемой или изменяемой: Тип Описание val Создает неизменяемую переменную, подобную final в Java. Согласно стандартам Scala и функционального программирования желательно всегда создавать переменную с помощью val. var Создает изменяемую переменную. Практически не используется в Scala, т.к. изменяемая переменная противоречит принципам функционального программирования. В примере показано, как создавать val и var переменные: val a = 0 // a: Int = 0 var b = 1 // b: Int = 1 Значение val не может быть переназначено. Если попытаться переназначить, то будет получена ошибка компиляции: val msg = \"Hello, world\" msg = \"Aloha\" // error: // Reassignment to val msg // msg = \"Aloha\" // ^^^^^^^^^^^^^ И наоборот, var может быть переназначен: var msg = \"Hello, world\" // msg: String = \"Hello, world\" msg = \"Aloha\" msg // res1: String = \"Aloha\" Объявление типов переменных Когда создается переменная, можно явно объявить ее тип или позволить определить тип компилятору: val x: Int = 1 val x = 1 Вторая форма известна как вывод типа (type inference), и это отличный способ помочь сохранить код кратким. Компилятор Scala обычно может определить тип данных, как показано в выходных данных этих примеров: val x = 1 // x: Int = 1 val s = \"a string\" // s: String = \"a string\" val nums = List(1, 2, 3) // nums: List[Int] = List(1, 2, 3) Всегда можно явно объявить тип переменной, но в простых примерах, подобных этим, в этом нет необходимости: val x: Int = 1 val s: String = \"a string\" val p: Person = Person(\"Richard\") В Scala все значения имеют тип, включая числовые значения и функции. Иерархия типов в Scala Приведенная ниже диаграмма иллюстрирует подмножество иерархии типов. Any - это супертип всех типов, также называемый the top type. Он определяет универсальные методы, такие как equals, hashCode и toString. У верхнего типа Any есть подтип Matchable, который используется для обозначения всех типов, для которых возможно выполнить pattern matching. Важно гарантировать вызов свойства “параметричность”, что вкратце означает, что мы не можем сопоставлять шаблоны для значений типа Any, а только для значений, которые являются подтипом Matchable. Справочная документация содержит более подробную информацию о Matchable. Matchable имеет два важных подтипа: AnyVal и AnyRef. AnyVal представляет типы значений. Существует несколько предопределенных типов значений, и они non-nullable: Double, Float, Long, Int, Short, Byte, Char, Unit и Boolean. Unit - это тип значения, который не несет никакой значимой информации. Существует ровно один экземпляр Unit - (). AnyRef представляет ссылочные типы. Все типы, не являющиеся значениями, определяются как ссылочные типы. Каждый пользовательский тип в Scala является подтипом AnyRef. Если Scala используется в контексте среды выполнения Java, AnyRef соответствует java.lang.Object. В языках, основанных на операторах, void используется для методов, которые ничего не возвращают. В Scala для методов, которые не имеют возвращаемого значения, такие как следующий метод, для той же цели используется Unit: def printIt(a: Any): Unit = println(a) Вот пример, демонстрирующий, что строки, целые числа, символы, логические значения и функции являются экземплярами Any и могут обрабатываться так же, как и любой другой объект: val list: List[Any] = List( \"a string\", 732, 'c', true, () =&gt; \"an anonymous function returning a string\" ) // list: List[Any] = List( // \"a string\", // 732, // 'c', // true, // &lt;function&gt; // ) Код определяет список значений типа List[Any]. Список инициализируется элементами различных типов, но каждый из них является экземпляром scala.Any, поэтому мы можем добавить их в список. Типы значений в Scala Как показано выше, числовые типы Scala расширяют AnyVal, и все они являются полноценными объектами. В этих примерах показано, как объявлять переменные этих числовых типов: val b: Byte = 1 val i: Int = 1 val l: Long = 1 val s: Short = 1 val d: Double = 2.0 val f: Float = 3.0 В первых четырех примерах, если явно не указать тип, то число 1 по умолчанию будет равно Int, поэтому, если нужен один из других типов данных — Byte, Long или Short — необходимо явно объявить эти типы. Числа с десятичной дробью (например, 2.0) по умолчанию будут иметь значение Double, поэтому, если необходим Float, нужно объявить Float явно, как показано в последнем примере. Поскольку Int и Double являются числовыми типами по умолчанию, их можно создавать без явного объявления типа данных: val i = 123 // i: Int = 123 val j = 1.0 // j: Double = 1.0 Также можно добавить символы L, D, and F (или их эквивалент в нижнем регистре) для того, чтобы задать Long, Double, или Float значения: val x = 1_000L // x: Long = 1000L val y = 2.2D // y: Double = 2.2 val z = 3.3F // z: Float = 3.3F В Scala также есть типы String (значение заключается в двойные кавычки или три двойных) и Char (значение заключается в одинарные кавычки): val name = \"Bill\" // name: String = \"Bill\" val c = 'a' // c: Char = 'a' BigInt и BigDecimal Для действительно больших чисел можно использовать типы BigInt и BigDecimal: var a = BigInt(1_234_567_890_987_654_321L) // a: BigInt = 1234567890987654321 var b = BigDecimal(123_456.789) // b: BigDecimal = 123456.789 Где Double и Float являются приблизительными десятичными числами, а BigDecimal используется для точной арифметики, например, при работе с валютой. BigInt и BigDecimal поддерживают все привычные числовые операторы: val b = BigInt(1234567890) // b: BigInt = 1234567890 val c = b + b // c: BigInt = 2469135780 val d = b * b // d: BigInt = 1524157875019052100 Строки Строки Scala похожи на строки Java, но у них есть две замечательные дополнительные функции: они поддерживают интерполяцию строк создавать многострочные строки очень просто String interpolation Интерполяция строк обеспечивает очень удобный способ использования переменных внутри строк. Например, учитывая эти три переменные: val firstName = \"John\" val mi = 'C' val lastName = \"Doe\" их комбинацию можно получить так: s\"Name: $firstName $mi $lastName\" // res4: String = \"Name: John C Doe\" Достаточно поставить перед строкой букву s, а затем - символ $ перед именами переменных внутри строки. Чтобы вставить произвольные выражения в строку, они заключаются в фигурные скобки: s\"2 + 2 = ${2 + 2}\" // res6: String = \"2 + 2 = 4\" val x = -1 // x: Int = -1 s\"x.abs = ${x.abs}\" // res7: String = \"x.abs = 1\" Символ s, помещенный перед строкой, является лишь одним из возможных интерполяторов. Если использовать f вместо s, можно использовать синтаксис форматирования в стиле printf в строке. Кроме того, интерполятор строк - это всего лишь специальный метод, и его можно определить самостоятельно. Например, некоторые библиотеки баз данных определяют очень мощный интерполятор sql. Multiline strings Многострочные строки создаются путем включения строки в три двойные кавычки: println(\"\"\"The essence of Scala: Fusion of functional and object-oriented programming in a typed setting.\"\"\") // The essence of Scala: // Fusion of functional and object-oriented // programming in a typed setting. Одним из недостатков базового подхода является то, что строки после первой имеют отступ. Если важно исключить отступ, можно поставить символ | перед всеми строками после первой и вызвать метод stripMargin после строки: println(\"\"\"The essence of Scala: |Fusion of functional and object-oriented |programming in a typed setting.\"\"\".stripMargin) // The essence of Scala: // Fusion of functional and object-oriented // programming in a typed setting. Теперь все строки выравниваются по левому краю. Здесь также можно использовать переменные внутри строки, добавив s перед первыми \"\"\". Приведение типов Типы значений могут быть приведены следующим образом: Например: val x: Int = 987654321 // x: Int = 987654321 val y: Long = x // y: Long = 987654321L val face: Char = '☺' // face: Char = '☺' val number: Int = face // number: Int = 9786 Приведение типов однонаправленное, следующий код не будет компилиться: val a: Long = 987654321 val b: Float = a val c: Long = b // val c: Long = b // ^ // Found: (b : Float) // Required: Long Неявное приведение типов в некоторых случаях помечено как deprecated и может быть запрещено в будущих версиях: val x: Long = 987654321 val y: Float = x // method long2float in object Long is deprecated since 2.13.1: Implicit conversion from Long to Float is dangerous because it loses precision. Write `.toFloat` instead. // val y: Float = x // ^ Nothing и null Nothing является подтипом всех типов, также называемым the bottom type. Нет значения, которое имело бы тип Nothing. Он обычно сигнализирует о прекращении, таком как thrown exception, выходе из программы или бесконечном цикле - т.е. это тип выражения, который не вычисляется до определенного значения, или метод, который нормально не возвращается. Null - это подтип всех ссылочных типов (т.е. любой подтип AnyRef). Он имеет единственное значение, определяемое ключевым словом null. В настоящее время применение null считается плохой практикой. Его следует использовать в основном для взаимодействия с другими языками JVM. Опция opt-in compiler изменяет статус Null, делая все ссылочные типы non-nullable. Этот параметр может стать значением по умолчанию в будущей версии Scala. Более подробная информация доступна по ссылке. В то же время null почти никогда не следует использовать в коде Scala. Альтернативы null обсуждаются в главе о функциональном программировании и в документации API. References: Scala3 book, Variables and Data Types Scala3 book, A First Look at Types"
    } ,    
    {
      "title": "Параметры функции",
      "url": "/scalaworkbook/docs/functions/variables.html",
      "content": "{{page.title}} Вернемся к примеру из предыдущего раздела: val doubledInts = ints.map((i: Int) =&gt; i * 2) Анонимной функцией является следующая часть: (i: Int) =&gt; i * 2 Причина, по которой она называется анонимной (anonymous), заключается в том, что она не присваивается переменной и, следовательно, не имеет имени. Однако анонимная функция, также известная как функциональный литерал (function literal), может быть назначена переменной для создания функциональной переменной (function variable): val double = (i: Int) =&gt; i * 2 Код выше создает функциональную переменную с именем double. В этом выражении исходный литерал функции находится справа от символа =, а новое имя переменной - слева. Список параметров функции подчеркнут: val double = (i: Int) =&gt; i * 2 -------- Как и список параметров для метода, список параметров функции означает, что функция double принимает один параметр с типом Int и именем i. Как можно видеть ниже, double имеет тип Int =&gt; Int, что означает, что он принимает один параметр Int и возвращает Int: val double = (i: Int) =&gt; i * 2 // double: Int =&gt; Int = ... Вызов метода Функция double может быть вызвана так: val x = double(2) // x: Int = 4 double также можно передать в вызов map: List(1, 2, 3).map(double) // res0: List[Int] = List(2, 4, 6) Кроме того, когда есть другие функции типа Int =&gt; Int: val triple = (i: Int) =&gt; i * 3 можно сохранить их в List или Map: val functionList: List[Int =&gt; Int] = List(double, triple) val functionMap: Map[String, Int =&gt; Int] = Map( \"2x\" -&gt; double, \"3x\" -&gt; triple ) functionList имеет тип List[Int =&gt; Int], functionMap - Map[String, Int =&gt; Int]. Ключевые моменты Ключевые моменты: чтобы создать функциональную переменную, достаточно присвоить имя переменной функциональному литералу когда есть функция, с ней можно обращаться как с любой другой переменной, то есть как со String или Int переменной А благодаря улучшенной функциональности Eta Expansion в Scala 3 с методами можно обращаться точно так же. References: Scala3 book Scala3 book, Function Variables"
    } ,    
    {
      "title": "Что такое функциональное программирование?",
      "url": "/scalaworkbook/docs/fp/what-is-fp.html",
      "content": "{{page.title}} Википедия определяет функциональное программирование следующим образом: Функциональное программирование — парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния. В функциональном программировании функции рассматриваются как “граждане первого класса”, что означает, что они могут быть привязаны к именам (включая локальные идентификаторы), передаваться в качестве аргументов и возвращаться из других функций, как и любой другой тип данных. Это позволяет писать программы в декларативном и составном стиле, где небольшие функции объединяются модульным образом. Также полезно знать, что опытные функциональные программисты рассматривают свой код математически, что объединение чистых функций вместе похоже на объединение ряда алгебраических уравнений. Когда пишется функциональный код, вы чувствуете себя математиком, и как только понимаете парадигму, то хотите писать только чистые функции, которые всегда возвращают значения, а не исключения или null, чтобы можно было комбинировать чистые функции вместе. Ощущение, что вы пишете математические уравнения (выражения), является движущим желанием, заставляющим использовать только чистые функции и неизменяемые значения - это то, что используется в алгебре и других формах математики. Функциональное программирование - это большая тема, и нет простого способа сжать её всю в одну главу. В следующих разделах будет представлен обзор основных тем и показаны некоторые инструменты, предоставляемые Scala для написания функционального кода. References: Scala3 book Wikipedia"
    } ,    
    {
      "title": "Взаимодействие с Java",
      "url": "/scalaworkbook/docs/with_java.html",
      "content": "{{page.title}} ??? References: Scala3 book"
    } ,    
    {
      "title": "Написание своего собственного метода map",
      "url": "/scalaworkbook/docs/functions/write-map.html",
      "content": "{{page.title}} Теперь, когда известно, как писать собственные функции высшего порядка, рассмотрим более реальный пример. Представим, что у класса List нет метода map, и есть необходимость его написать. Первым шагом при создании функций является точное определение проблемы. Сосредоточившись только на List[Int], получаем: Необходимо написать метод map, который можно использовать для применения функции к каждому элементу в List[Int], возвращая преобразованные элементы в виде нового списка. Учитывая это утверждение, начнем писать сигнатуру метода. Во-первых, известно, что функция должна приниматься в качестве параметра, и эта функция должна преобразовать Int в какой-то общий тип A, поэтому получаем: def map(f: (Int) =&gt; A) Синтаксис использования универсального типа требует объявления этого символа типа перед списком параметров, поэтому добавляем объявление типа: def map[A](f: (Int) =&gt; A) Далее известно, что map также должен принимать List[Int]: def map[A](f: (Int) =&gt; A, xs: List[Int]) Наконец, также известно, что map возвращает преобразованный список, содержащий элементы универсального типа A: def map[A](f: (Int) =&gt; A, xs: List[Int]): List[A] = ??? Теперь все, что нужно сделать, это написать тело метода. Метод map применяет заданную им функцию к каждому элементу в заданном списке для создания нового преобразованного списка. Один из способов сделать это - использовать выражение for: for x &lt;- xs yield f(x) for выражения зачастую делают код удивительно простым, и в данном случае - это все тело метода. Объединив for с сигнатурой метода, получим автономный метод map, который работает с List[Int]: def map[A](f: (Int) =&gt; A, xs: List[Int]): List[A] = for x &lt;- xs yield f(x) Обобщим метод map Обратим внимание, что выражение for не делает ничего, что зависит от типа Int внутри списка. Следовательно, можно заменить Int в сигнатуре типа параметром универсального типа B: def map[A, B](f: (B) =&gt; A, xs: List[B]): List[A] = for x &lt;- xs yield f(x) Получился метод map, который работает с любым списком. Демонстрация работы получившегося map: def double(i : Int) = i * 2 def strlen(s: String) = s.length map(double, List(1, 2, 3)) // res0: List[Int] = List(2, 4, 6) map(strlen, List(\"a\", \"bb\", \"ccc\")) // res1: List[Int] = List(1, 2, 3) Теперь, когда рассмотрены методы, принимающие функции в качестве входных параметров, перейдем к методам, возвращающим функции. References: Scala3 book"
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
