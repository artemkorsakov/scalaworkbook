<!DOCTYPE html><html><head><title>Scala workbook: Macros</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Артём Корсаков" /><meta name="description" content="Функциональная разработка на Scala." /><meta name="og:image" content="/scalaworkbook/img/poster.png" /><meta name="image" property="og:image" content="/scalaworkbook/img/poster.png" /><meta name="og:title" content="Scala workbook: Macros" /><meta name="title" property="og:title" content="Scala workbook: Macros" /><meta name="og:site_name" content="Scala workbook" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Функциональная разработка на Scala." /><link rel="icon" type="image/png" href="/scalaworkbook/img/favicon.png" /><meta name="twitter:title" content="Scala workbook: Macros" /><meta name="twitter:image" content="https://artemkorsakov.github.io/scalaworkbook/img/poster.png" /><meta name="twitter:description" content="Функциональная разработка на Scala." /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalaworkbook/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalaworkbook/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalaworkbook/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalaworkbook/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalaworkbook/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalaworkbook/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalaworkbook/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalaworkbook/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalaworkbook/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalaworkbook/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalaworkbook/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalaworkbook/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalaworkbook/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalaworkbook/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalaworkbook/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalaworkbook/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalaworkbook/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalaworkbook/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalaworkbook/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalaworkbook/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalaworkbook/highlight/styles/vs.css" /><link rel="stylesheet" href="/scalaworkbook/css/pattern-style.css" /><link rel="stylesheet" href="/scalaworkbook/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalaworkbook/" class="brand"><div class="brand-wrapper"><span>Scala workbook</span></div></a></li> <li><a href="/scalaworkbook/docs/index" class="">Обзор Scala</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/start/getting-started" class="">С чего начать?</a></li></ul></li> <li><a href="/scalaworkbook/docs/hello_world" class="">Hello, world!</a></li> <li><a href="/scalaworkbook/docs/repl" class="">REPL</a></li> <li><a href="/scalaworkbook/docs/types" class="">Типы данных</a></li> <li><a href="/scalaworkbook/docs/structures" class="">Структуры управления</a></li> <li><a href="/scalaworkbook/docs/modeling" class="">Моделирование данных</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/modeling/classes" class="">Classes</a></li> <li><a href="/scalaworkbook/docs/modeling/objects" class="">Objects</a></li> <li><a href="/scalaworkbook/docs/modeling/companion-objects" class="">Companion objects</a></li> <li><a href="/scalaworkbook/docs/modeling/traits" class="">Traits</a></li> <li><a href="/scalaworkbook/docs/modeling/abstract-class" class="">Абстрактные классы</a></li> <li><a href="/scalaworkbook/docs/modeling/enums" class="">Enums</a></li> <li><a href="/scalaworkbook/docs/modeling/case-class" class="">Case classes</a></li> <li><a href="/scalaworkbook/docs/modeling/oop" class="">Моделирование ООП</a></li> <li><a href="/scalaworkbook/docs/modeling/fp" class="">Моделирование ФП</a></li></ul></li> <li><a href="/scalaworkbook/docs/methods" class="">Методы</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/methods/method-features" class="">Определение методов</a></li> <li><a href="/scalaworkbook/docs/methods/default-parameters" class="">Параметры по умолчанию</a></li> <li><a href="/scalaworkbook/docs/methods/named-parameters" class="">Именованные параметры</a></li> <li><a href="/scalaworkbook/docs/methods/by-name-parameter" class="">Параметры по имени</a></li> <li><a href="/scalaworkbook/docs/methods/partially-applied-functions" class="">Каррирование</a></li> <li><a href="/scalaworkbook/docs/methods/vararg-parameters" class="">Variable Arguments</a></li> <li><a href="/scalaworkbook/docs/methods/generic-parameter" class="">Generic параметры</a></li> <li><a href="/scalaworkbook/docs/methods/extension-methods" class="">Методы расширения</a></li> <li><a href="/scalaworkbook/docs/methods/main-methods" class="">main методы</a></li></ul></li> <li><a href="/scalaworkbook/docs/functions" class="">Функции</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/functions/anonymous" class="">Анонимные функции</a></li> <li><a href="/scalaworkbook/docs/functions/variables" class="">Параметры функции</a></li> <li><a href="/scalaworkbook/docs/functions/eta" class="">Eta расширение</a></li> <li><a href="/scalaworkbook/docs/functions/hofs" class="">Функции высшего порядка</a></li> <li><a href="/scalaworkbook/docs/functions/write-map" class="">Собственный map</a></li> <li><a href="/scalaworkbook/docs/functions/returns-function" class="">Возврат функции в методе</a></li></ul></li> <li><a href="/scalaworkbook/docs/packaging" class="">Пакеты и импорт</a></li> <li><a href="/scalaworkbook/docs/toplevel-definitions" class="">Верхнеур. определения</a></li> <li><a href="/scalaworkbook/docs/collections" class="">Коллекции</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/collections/classes" class="">Типы коллекций</a></li> <li><a href="/scalaworkbook/docs/collections/methods" class="">Методы в коллекциях</a></li></ul></li> <li><a href="/scalaworkbook/docs/fp" class="">Функц. программирование</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/fp/what-is-fp" class="">Что такое ФП?</a></li> <li><a href="/scalaworkbook/docs/fp/immutable-values" class="">Неизменяемые значения</a></li> <li><a href="/scalaworkbook/docs/fp/pure-functions" class="">Чистые функции</a></li> <li><a href="/scalaworkbook/docs/fp/functions-are-values" class="">Функции - это значения</a></li> <li><a href="/scalaworkbook/docs/fp/functional-error-handling" class="">Обработка ошибок</a></li></ul></li> <li><a href="/scalaworkbook/docs/type-system" class="">Система типов</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/type-system/types-inferred" class="">Определение типов</a></li> <li><a href="/scalaworkbook/docs/type-system/types-generics" class="">Generics типы</a></li> <li><a href="/scalaworkbook/docs/type-system/types-intersection" class="">Пересечение типов</a></li> <li><a href="/scalaworkbook/docs/type-system/types-union" class="">Объединение типов</a></li> <li><a href="/scalaworkbook/docs/type-system/types-adts" class="">Алгебр. типы данных</a></li> <li><a href="/scalaworkbook/docs/type-system/types-variance" class="">Ковариантность</a></li> <li><a href="/scalaworkbook/docs/type-system/types-opaque" class="">Непрозрачные типы</a></li> <li><a href="/scalaworkbook/docs/type-system/types-structural" class="">Структурные типы</a></li> <li><a href="/scalaworkbook/docs/type-system/types-dependent-function" class="">Зависимые типы функций</a></li> <li><a href="/scalaworkbook/docs/type-system/type-lambdas" class="">Type Lambdas</a></li> <li><a href="/scalaworkbook/docs/type-system/match-types" class="">Match Types</a></li> <li><a href="/scalaworkbook/docs/type-system/polymorphic-function-types" class="">Полимор. типы функций</a></li> <li><a href="/scalaworkbook/docs/type-system/types-others" class="">Другие типы</a></li></ul></li> <li><a href="/scalaworkbook/docs/abstractions" class="">Абстракции</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/abstractions/ca-given" class="">Given</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-using" class="">Using</a></li> <li><a href="/scalaworkbook/docs/abstractions/type-classes" class="">Класс типов</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-context-bounds" class="">Контекстные границы</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-given-imports" class="">Given imports</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-extension-methods" class="">Методы расш. - детали</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-type-classes" class="">Импл. type классов</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-type-class-derivation" class="">Type Class Derivation</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-multiversal-equality" class="">Multiversal Equality</a></li> <li><a href="/scalaworkbook/docs/abstractions/context-functions" class="">Контекстные функции</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-implicit-conversions" class="">Неявные преобр.</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-by-name-parameters" class="">Конт. пар. по имени</a></li> <li><a href="/scalaworkbook/docs/abstractions/export-causes" class="">Предложения export</a></li> <li><a href="/scalaworkbook/docs/abstractions/parameter-untupling" class="">Распаковка параметров</a></li> <li><a href="/scalaworkbook/docs/abstractions/type-test" class="">Проверка типа</a></li></ul></li> <li><a href="/scalaworkbook/docs/concurrency" class="">Параллелизм</a></li> <li><a href="/scalaworkbook/docs/tools" class="">Утилиты</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/tools/tools-sbt" class="">Sbt</a></li> <li><a href="/scalaworkbook/docs/tools/tools-worksheets" class="">Worksheet</a></li></ul></li> <li><a href="/scalaworkbook/docs/with_java" class="">Взаимодействие с Java</a></li> <li><a href="/scalaworkbook/docs/metaprogramming" class="">Metaprogramming</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/metaprogramming/inline" class="">Inline</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/compile-time-ops" class="">Compile-time ops</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/macros" class=" active ">Macros</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/quoted-code" class="">Quoted Code</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/runtime-staging" class="">Runtime Staging</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/reflection" class="">Reflection</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/tasty-inspection" class="">TASTy Inspection</a></li></ul></li> <li><a href="/scalaworkbook/docs/soft-keywords" class="">Soft Keywords</a></li> <li><a href="/scalaworkbook/docs/extra" class="">Доп. материалы</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="search-nav hidden-xs hidden-sm"><div id="search-dropdown"><label><i class="fa fa-search"></i>Search</label><input id="search-bar" type="text" placeholder="Enter keywords here..." onclick="displayToggleSearch(event)" /><ul id="search-dropdown-content" class="dropdown dropdown-content"></ul></div></li></ul></div></div></div></div><div id="content" data-github-owner="artemkorsakov" data-github-repo="scalaworkbook"><div class="content-wrapper"><section><h2 id="macros">Macros</h2>

<p><a href="/scalaworkbook/docs/metaprogramming/inline">Встроенные методы</a> предоставляют элегантную технику метапрограммирования, 
выполняя некоторые операции во время компиляции. 
Однако иногда встраивания недостаточно, и нужны более мощные способы анализа и синтеза программ во время компиляции. 
Макросы позволяют делать именно это: относиться к <strong>программам как к данным</strong> и манипулировать ими.</p>

<h3 id="макросы-рассматривают-программы-как-значения">Макросы рассматривают программы как значения</h3>

<p>С помощью макроса программы можно рассматривать как значения, 
что позволяет анализировать и генерировать их во время компиляции. 
Выражение Scala с типом <code class="highlighter-rouge">T</code> представлено экземпляром типа <code class="highlighter-rouge">scala.quoted.Expr[T]</code>.</p>

<p>Более детально о типе <code class="highlighter-rouge">Expr[T]</code>, а также различные способы анализа и построения экземпляров, 
будут раскрыты в главах <a href="/scalaworkbook/docs/metaprogramming/quoted-code">Quoted Code</a> и <a href="/scalaworkbook/docs/metaprogramming/reflection">Reflection</a>. 
Пока достаточно знать, что макросы — это метапрограммы, которые манипулируют выражениями типа <code class="highlighter-rouge">Expr[T]</code>.</p>

<p>Следующая реализация макроса просто печатает выражение предоставленного аргумента:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">inspectCode</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Any</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">println</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">show</span><span class="o">)</span>
  <span class="n">x</span>
</code></pre></div></div>

<p>После печати выражения аргумента исходный аргумент возвращается как выражение Scala типа <code class="highlighter-rouge">Expr[Any]</code>.</p>

<p>Как уже упоминалось в разделе <a href="/scalaworkbook/docs/metaprogramming/inline">Inline</a>, 
встроенные методы предоставляют точку входа для определений макросов:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">inspect</span><span class="o">(</span><span class="n">inline</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">$</span><span class="o">{</span> <span class="nf">inspectCode</span><span class="o">(</span><span class="ss">'x</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>Все макросы определены с расширением <code class="highlighter-rouge">inline def</code>. 
Реализация этой точки входа всегда имеет одинаковую форму:</p>
<ul>
  <li>они содержат только одну <a href="/scalaworkbook/docs/metaprogramming/quoted-code">склейку</a> <code class="highlighter-rouge">${ ... }</code></li>
  <li>склейка содержит единственный вызов метода, реализующего макрос (например <code class="highlighter-rouge">inspectCode</code>).</li>
  <li>вызов реализации макроса получает параметры в кавычках (то есть <code class="highlighter-rouge">'x</code> вместо <code class="highlighter-rouge">x</code>) и контекстное <code class="highlighter-rouge">Quotes</code>.</li>
</ul>

<p>Вызов <code class="highlighter-rouge">inspect</code> макроса <code class="highlighter-rouge">inspect(sys error "abort")</code> выводит 
строковое представление выражения аргумента во время компиляции:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">scala</span><span class="o">.</span><span class="py">sys</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"abort"</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="макросы-и-параметры-типа">Макросы и параметры типа</h4>

<p>Если у макроса есть параметры типа, реализация также должна о них знать. 
Точно так же, как <code class="highlighter-rouge">scala.quoted.Expr[T]</code> представляет выражение Scala типа <code class="highlighter-rouge">T</code>, 
<code class="highlighter-rouge">scala.quoted.Type[T]</code> используется для представления типа Scala <code class="highlighter-rouge">T</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">logged</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">inline</span> <span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">$</span><span class="o">{</span> <span class="nf">loggedCode</span><span class="o">(</span><span class="ss">'x</span><span class="o">)</span>  <span class="o">}</span>

<span class="k">def</span> <span class="nf">loggedCode</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Type</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<p>И экземпляр <code class="highlighter-rouge">Type[T]</code>, и контекст <code class="highlighter-rouge">Quotes</code> автоматически предоставляются склейкой 
в соответствующем встроенном методе (то есть <code class="highlighter-rouge">logged</code>) и могут использоваться реализацией макроса.</p>

<h4 id="определение-и-использование-макросов">Определение и использование макросов</h4>

<p>Ключевое различие между встраиванием и макросами заключается в способе их оценки. 
Встраивание работает, переписывая код и выполняя оптимизацию на основе правил, известных компилятору. 
С другой стороны, макрос выполняет написанный пользователем код, генерирующий код, до которого макрос расширяется.</p>

<p>Технически компиляция встроенного кода <code class="highlighter-rouge">${ inspectCode('x) }</code> вызывает метод <code class="highlighter-rouge">inspectCode</code> 
во время компиляции (через Java reflection), а затем метод <code class="highlighter-rouge">inspectCode</code> выполняется как обычный код.</p>

<p>Чтобы иметь возможность выполнить <code class="highlighter-rouge">inspectCode</code>, нужно сначала скомпилировать его исходный код. 
Как следствие, мы не можем определить и использовать макрос в одном и том же классе/файле. 
Однако можно иметь определение макроса и его вызов в одном и том же проекте, 
если реализация макроса может быть скомпилирована первой.</p>

<blockquote>
  <p><strong>Приостановленные файлы</strong></p>

  <p>Чтобы разрешить определение и использование макросов в одном и том же проекте, 
расширяются только те вызовы макросов, которые уже были скомпилированы. 
Для всех остальных (неизвестных) вызовов макросов компиляция файла приостанавливается. 
Приостановленные файлы компилируются только после успешной компиляции всех незаблокированных файлов. 
В некоторых случаях будут циклические зависимости, которые будут блокировать завершение компиляции. 
Чтобы получить больше информации о том, какие файлы приостановлены, 
можно использовать флаг компилятора <code class="highlighter-rouge">-Xprint-suspension</code>.</p>
</blockquote>

<h4 id="пример-статическая-оценка-power-с-помощью-макросов">Пример: статическая оценка <code class="highlighter-rouge">power</code> с помощью макросов</h4>

<p>Вспомним определение <code class="highlighter-rouge">power</code> из раздела <a href="/scalaworkbook/docs/metaprogramming/inline">Inline</a>, 
которое специализировало вычисление <code class="highlighter-rouge">xⁿ</code> для статически известных значений <code class="highlighter-rouge">n</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">power</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">inline</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
  <span class="n">inline</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span> <span class="mf">1.0</span>
  <span class="k">else</span> <span class="n">inline</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="n">then</span> <span class="n">x</span> <span class="o">*</span> <span class="nf">power</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">else</span> <span class="nf">power</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>

<p>В оставшейся части этого раздела будет определен макрос, 
который вычисляет <code class="highlighter-rouge">xⁿ</code> для статически известных значений <code class="highlighter-rouge">x</code> и <code class="highlighter-rouge">n</code>. 
Хотя это также возможно с помощью <code class="highlighter-rouge">inline</code>, 
реализация с помощью макросов проиллюстрирует несколько вещей.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">power</span><span class="o">(</span><span class="n">inline</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">inline</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="nf">powerCode</span><span class="o">(</span><span class="ss">'x</span><span class="o">,</span> <span class="ss">'n</span><span class="o">)</span>  <span class="o">}</span>

<span class="k">def</span> <span class="nf">powerCode</span><span class="o">(</span>
  <span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span>
  <span class="n">n</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<h3 id="простые-выражения">Простые выражения</h3>

<p><code class="highlighter-rouge">powerCode</code> можно было бы реализовать следующим образом:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pow</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="nf">pow</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">powerCode</span><span class="o">(</span>
  <span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span>
  <span class="n">n</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">val</span> <span class="nv">value</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nf">pow</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">valueOrError</span><span class="o">,</span> <span class="nv">n</span><span class="o">.</span><span class="py">valueOrError</span><span class="o">)</span>
  <span class="nc">Expr</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
</code></pre></div></div>

<p>Здесь операция <code class="highlighter-rouge">pow</code> представляет собой простую функцию Scala, которая вычисляет значение <code class="highlighter-rouge">xⁿ</code>. 
Интересная часть заключается в том, как мы создаем и изучаем <code class="highlighter-rouge">Expr</code>-ы.</p>

<h4 id="создание-выражений-из-значений">Создание выражений из значений</h4>

<p>Давайте сначала посмотрим <code class="highlighter-rouge">Expr.apply(value)</code>. 
Учитывая значение типа <code class="highlighter-rouge">T</code>, этот вызов вернет выражение, содержащее код, 
представляющий данное значение (то есть типа <code class="highlighter-rouge">Expr[T]</code>). 
Значение аргумента <code class="highlighter-rouge">Expr</code> вычисляется во время компиляции, 
во время выполнения нужно только создать экземпляр этого значения.</p>

<p>Создание выражений из значений работает для всех примитивных типов, кортежей любой арности, 
<code class="highlighter-rouge">Class</code>, <code class="highlighter-rouge">Array</code>, <code class="highlighter-rouge">Seq</code>, <code class="highlighter-rouge">Set</code>, <code class="highlighter-rouge">List</code>, <code class="highlighter-rouge">Map</code>, <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">Either</code>, <code class="highlighter-rouge">BigInt</code>, <code class="highlighter-rouge">BigDecimal</code>, <code class="highlighter-rouge">StringContext</code>. 
Другие типы также могут работать, если для них реализован <code class="highlighter-rouge">ToExpr</code>, 
<a href="/scalaworkbook/docs/metaprogramming/quoted-code">как будет показано позже</a>.</p>

<h4 id="извлечение-значений-из-выражений">Извлечение значений из выражений</h4>

<p>Второй метод, который используется при реализации <code class="highlighter-rouge">powerCode</code> - это <code class="highlighter-rouge">Expr[T].valueOrError</code>, 
имеющий эффект, противоположный <code class="highlighter-rouge">Expr.apply</code>. 
Он пытается извлечь значение типа <code class="highlighter-rouge">T</code> из выражения типа <code class="highlighter-rouge">Expr[T]</code>. 
Это может быть успешным только в том случае, если выражение непосредственно содержит код значения, 
в противном случае будет выдано исключение, которое остановит раскрытие макроса и сообщит, 
что выражение не соответствует значению.</p>

<p>Вместо <code class="highlighter-rouge">valueOrError</code>, можно было бы также использовать операцию <code class="highlighter-rouge">value</code>, которая вернет <code class="highlighter-rouge">Option</code>. 
Таким образом, можно сообщить об ошибке с помощью пользовательского сообщения.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">...</span>
  <span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">value</span><span class="o">,</span> <span class="nv">n</span><span class="o">.</span><span class="py">value</span><span class="o">)</span> <span class="k">match</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">base</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="n">exponent</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="nf">pow</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">exponent</span><span class="o">)</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">report</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"Expected a known value for the exponent, but was "</span> <span class="o">+</span> <span class="nv">n</span><span class="o">.</span><span class="py">show</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nv">report</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"Expected a known value for the base, but was "</span> <span class="o">+</span> <span class="nv">x</span><span class="o">.</span><span class="py">show</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>Кроме того, также можно использовать экстрактор <code class="highlighter-rouge">Expr.unapply</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">...</span>
  <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">match</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="n">base</span><span class="o">),</span> <span class="nc">Expr</span><span class="o">(</span><span class="n">exponent</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="nf">pow</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">exponent</span><span class="o">)</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">...</span>
</code></pre></div></div>

<p>Операции <code class="highlighter-rouge">value</code>, <code class="highlighter-rouge">valueOrError</code> и <code class="highlighter-rouge">Expr.unapply</code> будут работать для всех примитивных типов, кортежей любой арности, 
<code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">Seq</code>, <code class="highlighter-rouge">Set</code>, <code class="highlighter-rouge">Map</code>, <code class="highlighter-rouge">Either</code> и <code class="highlighter-rouge">StringContext</code>. 
Другие типы также могут работать, если для них реализован FromExpr, 
<a href="/scalaworkbook/docs/metaprogramming/quoted-code">как будет показано позже</a>.</p>

<h4 id="отображение-выражений">Отображение выражений</h4>

<p>В реализации <code class="highlighter-rouge">inspectCode</code> было видно, как преобразовать выражения 
в строковое представление исходного кода с помощью метода <code class="highlighter-rouge">.show</code>. 
Это может быть полезно для отладки реализации макросов:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">debugPowerCode</span><span class="o">(</span>
  <span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span>
  <span class="n">n</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">println</span><span class="o">(</span>
    <span class="n">s</span><span class="s">"""powerCode
       |  x := ${x.show}
       |  n := ${n.show}"""</span><span class="o">.</span><span class="py">stripMargin</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">code</span> <span class="k">=</span> <span class="nf">powerCode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"  code := ${code.show}"</span><span class="o">)</span>
  <span class="n">code</span>
</code></pre></div></div>

<h4 id="работа-с-переменными-аргументами">Работа с переменными аргументами</h4>

<p>Переменные аргументы в Scala представлены с помощью <code class="highlighter-rouge">Seq</code>, 
поэтому, когда пишется макрос с переменным аргументом, он будет передан как <code class="highlighter-rouge">Expr[Seq[T]]</code>. 
Можно восстановить каждый отдельный аргумент (типа <code class="highlighter-rouge">Expr[T]</code>) с помощью экстрактора <code class="highlighter-rouge">scala.quoted.Varargs</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.quoted.Varargs</span>

<span class="n">inline</span> <span class="k">def</span> <span class="nf">sumNow</span><span class="o">(</span><span class="n">inline</span> <span class="n">nums</span><span class="k">:</span> <span class="kt">Int*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="nf">sumCode</span><span class="o">(</span><span class="ss">'nums</span><span class="o">)</span>  <span class="o">}</span>

<span class="k">def</span> <span class="nf">sumCode</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">nums</span> <span class="k">match</span>
    <span class="k">case</span>  <span class="nc">Varargs</span><span class="o">(</span><span class="n">numberExprs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// numberExprs: Seq[Expr[Int]]</span>
      <span class="k">val</span> <span class="nv">numbers</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">numberExprs</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">valueOrError</span><span class="o">)</span>
      <span class="nc">Expr</span><span class="o">(</span><span class="nv">numbers</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">report</span><span class="o">.</span><span class="py">error</span><span class="o">(</span>
      <span class="s">"Expected explicit argument"</span> <span class="o">+</span>
      <span class="s">"Notation `args: _*` is not supported."</span><span class="o">,</span> <span class="n">numbersExpr</span><span class="o">)</span>
</code></pre></div></div>

<p>Экстрактор сопоставит вызов <code class="highlighter-rouge">sumNow(1, 2, 3)</code> и извлечет <code class="highlighter-rouge">Seq[Expr[Int]]</code>, содержащий код каждого параметра. 
Но если попытаться сопоставить аргумент вызова <code class="highlighter-rouge">sumNow(nums: _*)</code>, экстрактор не совпадет.</p>

<p><code class="highlighter-rouge">Varargs</code> также может быть использован в качестве конструктора. 
<code class="highlighter-rouge">Varargs(Expr(1), Expr(2), Expr(3))</code> вернет <code class="highlighter-rouge">Expr[Seq[Int]]</code>.</p>

<h3 id="сложные-выражения">Сложные выражения</h3>

<p>Было показано, как создавать и распаковывать выражения, соответствующие простым значениям. 
Для работы с более сложными выражениями Scala предлагает различные средства метапрограммирования, начиная от</p>
<ul>
  <li>дополнительные конструкторы, такие как <code class="highlighter-rouge">Expr.apply</code>,</li>
  <li><a href="/scalaworkbook/docs/metaprogramming/quoted-code">сопоставление с образцом в цитатах</a>,</li>
  <li><a href="/scalaworkbook/docs/metaprogramming/reflection">reflection API</a>;</li>
</ul>

<p>каждый из них усложняется и потенциально теряет гарантии безопасности. 
Обычно рекомендуется чаще использовать простые API. 
В оставшейся части этого раздела вводятся еще несколько дополнительных конструкторов и деструкторов, 
а в последующих главах представлены более продвинутые API.</p>

<h4 id="коллекции">Коллекции</h4>

<p>Было показано, как преобразовать <code class="highlighter-rouge">List[Int]</code> в <code class="highlighter-rouge">Expr[List[Int]]</code> используя <code class="highlighter-rouge">Expr.apply</code>. 
Как насчет преобразования <code class="highlighter-rouge">List[Expr[Int]]</code> в <code class="highlighter-rouge">Expr[List[Int]]</code>? 
Упоминалось, что <code class="highlighter-rouge">Varargs.apply</code> может сделать это для последовательностей; 
аналогично, для других типов коллекций доступны соответствующие методы:</p>
<ul>
  <li><code class="highlighter-rouge">Expr.ofList</code>: преобразует <code class="highlighter-rouge">List[Expr[T]]</code> в <code class="highlighter-rouge">Expr[List[T]]</code></li>
  <li><code class="highlighter-rouge">Expr.ofSeq</code>: преобразует <code class="highlighter-rouge">Seq[Expr[T]]</code> в <code class="highlighter-rouge">Expr[Seq[T]]</code> (так же, как Varargs)</li>
  <li><code class="highlighter-rouge">Expr.ofTupleFromSeq</code>: преобразует <code class="highlighter-rouge">Seq[Expr[T]]</code> в <code class="highlighter-rouge">Expr[Tuple]</code></li>
  <li><code class="highlighter-rouge">Expr.ofTuple</code>: преобразует <code class="highlighter-rouge">(Expr[T1], ..., Expr[Tn])</code> в <code class="highlighter-rouge">Expr[(T1, ..., Tn)]</code></li>
</ul>

<h4 id="простые-блоки">Простые блоки</h4>

<p>Конструктор <code class="highlighter-rouge">Expr.block</code> предоставляет простой способ создания блока кода <code class="highlighter-rouge">{ stat1; ...; statn; expr }</code>. 
Его первые аргументы — это список со всеми операторами, а второй аргумент — выражение в конце блока.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">test</span><span class="o">(</span><span class="n">inline</span> <span class="n">ignore</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">computation</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="nf">testCode</span><span class="o">(</span><span class="ss">'ignore</span><span class="o">,</span> <span class="ss">'computation</span><span class="o">)</span> <span class="o">}</span>

<span class="k">def</span> <span class="nf">testCode</span><span class="o">(</span><span class="n">ignore</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">],</span> <span class="n">computation</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="nv">ignore</span><span class="o">.</span><span class="py">valueOrError</span> <span class="n">then</span> <span class="nc">Expr</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
  <span class="k">else</span> <span class="nv">Expr</span><span class="o">.</span><span class="py">block</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">computation</span><span class="o">),</span> <span class="nc">Expr</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span>
</code></pre></div></div>

<p>Конструктор <code class="highlighter-rouge">Expr.block</code> полезен, когда необходимо сгенерировать код, содержащий несколько побочных эффектов. 
Вызов макроса <code class="highlighter-rouge">test(false, EXPRESSION)</code> будет генерировать <code class="highlighter-rouge">{ EXPRESSION; true}</code>, 
в то время как вызов <code class="highlighter-rouge">test(true, EXPRESSION)</code> приведет к <code class="highlighter-rouge">false</code>.</p>

<h4 id="простое-сопоставление">Простое сопоставление</h4>

<p>Этот метод <code class="highlighter-rouge">Expr.matches</code> можно использовать для проверки равенства одного выражения другому. 
С помощью этого метода можно было бы реализовать <code class="highlighter-rouge">value</code> операцию <code class="highlighter-rouge">Expr[Boolean]</code> следующим образом:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">value</span><span class="o">(</span><span class="n">boolExpr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="nv">boolExpr</span><span class="o">.</span><span class="py">matches</span><span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span> <span class="n">then</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
  <span class="k">else</span> <span class="k">if</span> <span class="nv">boolExpr</span><span class="o">.</span><span class="py">matches</span><span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span> <span class="n">then</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
  <span class="k">else</span> <span class="nc">None</span>
</code></pre></div></div>

<p>Его также можно использовать для сравнения двух написанных пользователем выражений. 
Обратите внимание, что <code class="highlighter-rouge">matches</code> выполняется только ограниченная нормализация, 
и хотя, например, Scala выражение <code class="highlighter-rouge">2</code> соответствует выражению <code class="highlighter-rouge">{ 2 }</code>, 
это не относится к выражению <code class="highlighter-rouge">{ val x: Int = 2; x }</code>.</p>

<h4 id="произвольные-выражения">Произвольные выражения</h4>

<p>Можно создать произвольный код Scala <code class="highlighter-rouge">Expr[T]</code>, заключив его <a href="/scalaworkbook/docs/metaprogramming/quoted-code">в цитаты</a>. 
Например, <code class="highlighter-rouge">'{ ${expr}; true }</code> сгенерирует <code class="highlighter-rouge">Expr[Int]</code> эквивалент <code class="highlighter-rouge">Expr.block(List(expr), Expr(true))</code>. 
В следующем разделе, посвященном <a href="/scalaworkbook/docs/metaprogramming/quoted-code">Quoted Code</a>, цитаты представлены более подробно.</p>

<hr />

<p><strong>References:</strong></p>
<ul>
  <li><a href="https://docs.scala-lang.org/scala3/guides/macros/macros.html">Scala 3 Guide</a></li>
  <li><a href="https://docs.scala-lang.org/scala3/reference/metaprogramming/macros.html">Scala 3 Reference</a></li>
</ul>


<hr>
<div class="edit-button" style="display: flex; justify-content: space-between;">
    
    <a href="/scalaworkbook/docs/metaprogramming/compile-time-ops" class="btn-sm btn-info btn-left"><-- Предыдущая</a>
    
    
    <a href="/scalaworkbook/docs/metaprogramming/quoted-code" class="btn-sm btn-info btn-right">Следующая --></a>
    
</div></section><div class="edit-button"><a href="https://github.com/artemkorsakov/scalaworkbook/edit/main/docs/docs/docs/metaprogramming/macros.md" target="_blank" rel="noopener noreferrer" class="btn-sm btn-info">Редактировать страницу</a></div></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalaworkbook/highlight/highlight.pack.js"></script><script src="/scalaworkbook/lunr/lunr.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script src="/scalaworkbook/js/search.js"></script><script src="/scalaworkbook/js/main.js"></script></body></html>