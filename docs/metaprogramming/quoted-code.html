<!DOCTYPE html><html><head><title>Scala workbook: Quoted Code</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Артём Корсаков" /><meta name="description" content="Функциональная разработка на Scala." /><meta name="og:image" content="/scalaworkbook/img/poster.png" /><meta name="image" property="og:image" content="/scalaworkbook/img/poster.png" /><meta name="og:title" content="Scala workbook: Quoted Code" /><meta name="title" property="og:title" content="Scala workbook: Quoted Code" /><meta name="og:site_name" content="Scala workbook" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Функциональная разработка на Scala." /><link rel="icon" type="image/png" href="/scalaworkbook/img/favicon.png" /><meta name="twitter:title" content="Scala workbook: Quoted Code" /><meta name="twitter:image" content="https://artemkorsakov.github.io/scalaworkbook/img/poster.png" /><meta name="twitter:description" content="Функциональная разработка на Scala." /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalaworkbook/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalaworkbook/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalaworkbook/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalaworkbook/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalaworkbook/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalaworkbook/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalaworkbook/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalaworkbook/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalaworkbook/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalaworkbook/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalaworkbook/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalaworkbook/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalaworkbook/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalaworkbook/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalaworkbook/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalaworkbook/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalaworkbook/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalaworkbook/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalaworkbook/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalaworkbook/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalaworkbook/highlight/styles/vs.css" /><link rel="stylesheet" href="/scalaworkbook/css/pattern-style.css" /><link rel="stylesheet" href="/scalaworkbook/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalaworkbook/" class="brand"><div class="brand-wrapper"><span>Scala workbook</span></div></a></li> <li><a href="/scalaworkbook/docs/index" class="">Обзор Scala</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/start/getting-started" class="">С чего начать?</a></li></ul></li> <li><a href="/scalaworkbook/docs/hello_world" class="">Hello, world!</a></li> <li><a href="/scalaworkbook/docs/repl" class="">REPL</a></li> <li><a href="/scalaworkbook/docs/types" class="">Типы данных</a></li> <li><a href="/scalaworkbook/docs/structures" class="">Структуры управления</a></li> <li><a href="/scalaworkbook/docs/modeling" class="">Моделирование данных</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/modeling/classes" class="">Classes</a></li> <li><a href="/scalaworkbook/docs/modeling/objects" class="">Objects</a></li> <li><a href="/scalaworkbook/docs/modeling/companion-objects" class="">Companion objects</a></li> <li><a href="/scalaworkbook/docs/modeling/traits" class="">Traits</a></li> <li><a href="/scalaworkbook/docs/modeling/abstract-class" class="">Абстрактные классы</a></li> <li><a href="/scalaworkbook/docs/modeling/enums" class="">Enums</a></li> <li><a href="/scalaworkbook/docs/modeling/case-class" class="">Case classes</a></li> <li><a href="/scalaworkbook/docs/modeling/oop" class="">Моделирование ООП</a></li> <li><a href="/scalaworkbook/docs/modeling/fp" class="">Моделирование ФП</a></li></ul></li> <li><a href="/scalaworkbook/docs/methods" class="">Методы</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/methods/method-features" class="">Определение методов</a></li> <li><a href="/scalaworkbook/docs/methods/default-parameters" class="">Параметры по умолчанию</a></li> <li><a href="/scalaworkbook/docs/methods/named-parameters" class="">Именованные параметры</a></li> <li><a href="/scalaworkbook/docs/methods/by-name-parameter" class="">Параметры по имени</a></li> <li><a href="/scalaworkbook/docs/methods/partially-applied-functions" class="">Каррирование</a></li> <li><a href="/scalaworkbook/docs/methods/vararg-parameters" class="">Variable Arguments</a></li> <li><a href="/scalaworkbook/docs/methods/generic-parameter" class="">Generic параметры</a></li> <li><a href="/scalaworkbook/docs/methods/extension-methods" class="">Методы расширения</a></li> <li><a href="/scalaworkbook/docs/methods/main-methods" class="">main методы</a></li></ul></li> <li><a href="/scalaworkbook/docs/functions" class="">Функции</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/functions/anonymous" class="">Анонимные функции</a></li> <li><a href="/scalaworkbook/docs/functions/variables" class="">Параметры функции</a></li> <li><a href="/scalaworkbook/docs/functions/eta" class="">Eta расширение</a></li> <li><a href="/scalaworkbook/docs/functions/hofs" class="">Функции высшего порядка</a></li> <li><a href="/scalaworkbook/docs/functions/write-map" class="">Собственный map</a></li> <li><a href="/scalaworkbook/docs/functions/returns-function" class="">Возврат функции в методе</a></li></ul></li> <li><a href="/scalaworkbook/docs/packaging" class="">Пакеты и импорт</a></li> <li><a href="/scalaworkbook/docs/toplevel-definitions" class="">Верхнеур. определения</a></li> <li><a href="/scalaworkbook/docs/collections" class="">Коллекции</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/collections/classes" class="">Типы коллекций</a></li> <li><a href="/scalaworkbook/docs/collections/methods" class="">Методы в коллекциях</a></li></ul></li> <li><a href="/scalaworkbook/docs/fp" class="">Функц. программирование</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/fp/what-is-fp" class="">Что такое ФП?</a></li> <li><a href="/scalaworkbook/docs/fp/immutable-values" class="">Неизменяемые значения</a></li> <li><a href="/scalaworkbook/docs/fp/pure-functions" class="">Чистые функции</a></li> <li><a href="/scalaworkbook/docs/fp/functions-are-values" class="">Функции - это значения</a></li> <li><a href="/scalaworkbook/docs/fp/functional-error-handling" class="">Обработка ошибок</a></li></ul></li> <li><a href="/scalaworkbook/docs/type-system" class="">Система типов</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/type-system/types-inferred" class="">Определение типов</a></li> <li><a href="/scalaworkbook/docs/type-system/types-generics" class="">Generics типы</a></li> <li><a href="/scalaworkbook/docs/type-system/types-intersection" class="">Пересечение типов</a></li> <li><a href="/scalaworkbook/docs/type-system/types-union" class="">Объединение типов</a></li> <li><a href="/scalaworkbook/docs/type-system/types-adts" class="">Алгебр. типы данных</a></li> <li><a href="/scalaworkbook/docs/type-system/types-variance" class="">Ковариантность</a></li> <li><a href="/scalaworkbook/docs/type-system/types-opaque" class="">Непрозрачные типы</a></li> <li><a href="/scalaworkbook/docs/type-system/types-structural" class="">Структурные типы</a></li> <li><a href="/scalaworkbook/docs/type-system/types-dependent-function" class="">Зависимые типы функций</a></li> <li><a href="/scalaworkbook/docs/type-system/type-lambdas" class="">Type Lambdas</a></li> <li><a href="/scalaworkbook/docs/type-system/match-types" class="">Match Types</a></li> <li><a href="/scalaworkbook/docs/type-system/polymorphic-function-types" class="">Полимор. типы функций</a></li> <li><a href="/scalaworkbook/docs/type-system/types-others" class="">Другие типы</a></li></ul></li> <li><a href="/scalaworkbook/docs/abstractions" class="">Абстракции</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/abstractions/ca-given" class="">Given</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-using" class="">Using</a></li> <li><a href="/scalaworkbook/docs/abstractions/type-classes" class="">Класс типов</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-context-bounds" class="">Контекстные границы</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-given-imports" class="">Given imports</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-extension-methods" class="">Методы расш. - детали</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-type-classes" class="">Импл. type классов</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-type-class-derivation" class="">Type Class Derivation</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-multiversal-equality" class="">Multiversal Equality</a></li> <li><a href="/scalaworkbook/docs/abstractions/context-functions" class="">Контекстные функции</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-implicit-conversions" class="">Неявные преобр.</a></li> <li><a href="/scalaworkbook/docs/abstractions/ca-by-name-parameters" class="">Конт. пар. по имени</a></li></ul></li> <li><a href="/scalaworkbook/docs/details" class="">Детали</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/details/export-causes" class="">Предложения export</a></li> <li><a href="/scalaworkbook/docs/details/parameter-untupling" class="">Распаковка параметров</a></li> <li><a href="/scalaworkbook/docs/details/type-test" class="">Проверка типа</a></li> <li><a href="/scalaworkbook/docs/details/pattern-matching" class="">Экстракторы</a></li></ul></li> <li><a href="/scalaworkbook/docs/concurrency" class="">Параллелизм</a></li> <li><a href="/scalaworkbook/docs/tools" class="">Утилиты</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/tools/tools-sbt" class="">Sbt</a></li> <li><a href="/scalaworkbook/docs/tools/tools-worksheets" class="">Worksheet</a></li></ul></li> <li><a href="/scalaworkbook/docs/with_java" class="">Взаимодействие с Java</a></li> <li><a href="/scalaworkbook/docs/metaprogramming" class="">Metaprogramming</a> <ul class="sub-section"> <li><a href="/scalaworkbook/docs/metaprogramming/inline" class="">Inline</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/compile-time-ops" class="">Compile-time ops</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/macros" class="">Macros</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/quoted-code" class=" active ">Quoted Code</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/runtime-staging" class="">Runtime Staging</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/reflection" class="">Reflection</a></li> <li><a href="/scalaworkbook/docs/metaprogramming/tasty-inspection" class="">TASTy Inspection</a></li></ul></li> <li><a href="/scalaworkbook/docs/soft-keywords" class="">Soft Keywords</a></li> <li><a href="/scalaworkbook/docs/extra" class="">Доп. материалы</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="search-nav hidden-xs hidden-sm"><div id="search-dropdown"><label><i class="fa fa-search"></i>Search</label><input id="search-bar" type="text" placeholder="Enter keywords here..." onclick="displayToggleSearch(event)" /><ul id="search-dropdown-content" class="dropdown dropdown-content"></ul></div></li></ul></div></div></div></div><div id="content" data-github-owner="artemkorsakov" data-github-repo="scalaworkbook"><div class="content-wrapper"><section><h2 id="quoted-code">Quoted Code</h2>

<h3 id="кодовые-блоки">Кодовые блоки</h3>

<p>Блок кода в кавычках <code class="highlighter-rouge">'{ ... }</code> синтаксически похож на строковую кавычку <code class="highlighter-rouge">" ... "</code> 
с той разницей, что первая содержит типизированный код. 
Чтобы вставить код в другой код, можно использовать синтаксис <code class="highlighter-rouge">$expr</code> или <code class="highlighter-rouge">${ expr }</code>, 
где <code class="highlighter-rouge">expr</code> имеет тип <code class="highlighter-rouge">Expr[T]</code>.
Интуитивно понятно, что код непосредственно внутри кавычки (<code class="highlighter-rouge">'{ ... }</code>) сейчас не выполняется, 
в то время как код внутри склейки (<code class="highlighter-rouge">${ ... }</code>) оценивается и результаты встраиваются в окружающее выражение.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">msg</span> <span class="k">=</span> <span class="nc">Expr</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">printHello</span> <span class="k">=</span> <span class="o">'{</span> <span class="nf">print</span><span class="o">(</span><span class="nc">$msg</span><span class="o">)</span> <span class="o">}</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">printHello</span><span class="o">.</span><span class="py">show</span><span class="o">)</span> <span class="c1">// print("Hello")</span>
</code></pre></div></div>

<p>Как правило, цитаты задерживают выполнение, в то время как склейка делает это раньше окружающего кода.
Из-за некоторых технических соображений непосредственно внутри <code class="highlighter-rouge">inline</code> определений, 
которые называются <a href="/scalaworkbook/docs/metaprogramming/macros">макросами</a>, 
разрешены только склейки верхнего уровня.</p>

<p>Можно написать цитату внутри цитаты, но этот шаблон не распространен при написании макросов.</p>

<h3 id="согласованность-уровней">Согласованность уровней</h3>

<p>Нельзя просто написать любой произвольный код в цитатах и в склейках, 
так как одна часть программы будет жить во время компиляции, а другая — во время выполнения. 
Рассмотрим следующий плохо сконструированный код:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">myBadCounter1</span><span class="o">(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="o">'{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Проблема с этим кодом в том, что <code class="highlighter-rouge">x</code> существует во время компиляции, 
но затем мы пытаемся использовать его после завершения компиляции (возможно, даже на другой машине). 
Ясно, что невозможно получить доступ к его значению и обновить <code class="highlighter-rouge">x</code>.</p>

<p>Теперь рассмотрим двойную версию, где определяется переменная во время выполнения 
и происходит попытка получить к ней доступ во время компиляции:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">myBadCounter2</span><span class="o">(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">$</span><span class="o">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span> <span class="ss">'x</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Ясно, что это не должно работать, так как переменная еще не существует.</p>

<p>Чтобы убедиться, что нельзя писать программы, которые содержат такого рода проблемы, 
виды ссылок, разрешенных в области цитат, ограничиваются.</p>

<p>Вводятся уровни как количество цитат за вычетом количества склеек, окружающих выражение или определение.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// level 0</span>
<span class="o">'{</span> <span class="c1">// level 1</span>
  <span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">$</span><span class="o">{</span> <span class="c1">// level 0</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="ss">'x</span> <span class="c1">// level 1</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Система разрешает ссылки на глобальные определения, например, <code class="highlighter-rouge">println</code> на любом уровне, 
но ограничивает ссылки на локальные определения. 
Доступ к локальному определению возможен только в том случае, если оно задано на том же уровне, что и его ссылка. 
Это позволит поймать ошибки в <code class="highlighter-rouge">myBadCounter1</code> и <code class="highlighter-rouge">myBadCounter2</code>.</p>

<p>Несмотря на то, что нельзя ссылаться на переменную внутри цитаты, 
все же можно передать ее текущее значение через кавычку, 
подняв значение до выражения с помощью <code class="highlighter-rouge">Expr.apply</code>.</p>

<h3 id="дженерики">Дженерики</h3>

<p>При использовании параметров типа или других видов абстрактных типов с кодом в кавычках 
потребуется явно отслеживать некоторые из этих типов. 
Scala использует семантику стертых типов для своих дженериков. 
Это означает, что типы удаляются из программы при компиляции, 
и среде выполнения не нужно отслеживать все типы во время выполнения.</p>

<p>Рассмотрим следующий код:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">$x</span> <span class="c1">// error</span>
  <span class="o">...</span> <span class="c1">// use x2</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Здесь будет получено сообщение об ошибке, сообщающее, что не хватает контекстного параметра <code class="highlighter-rouge">Type[T]</code>. 
Это можно легко исправить, написав:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Type</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">$x</span>
  <span class="o">...</span> <span class="c1">// use x2</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Код будет эквивалентен такой более подробной версии:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Type</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">t.Underlying</span> <span class="o">=</span> <span class="nc">$x</span>
  <span class="o">...</span> <span class="c1">// use x2</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Обратите внимание, что у <code class="highlighter-rouge">Type</code> вызывается член типа <code class="highlighter-rouge">Underlying</code>, который ссылается на тип, хранящийся в <code class="highlighter-rouge">Type</code>; 
в данном случае <code class="highlighter-rouge">t.Underlying</code> есть <code class="highlighter-rouge">T</code>. 
Даже если <code class="highlighter-rouge">Type</code> используется неявно, как правило, лучше оставить его контекстуальным, 
так как некоторые изменения внутри цитаты могут потребовать этого. 
Менее подробная версия обычно является лучшим способом написания типов, поскольку ее намного проще читать. 
В некоторых случаях не будет статически известен тип внутри <code class="highlighter-rouge">Type</code> 
и нужно будет использовать <code class="highlighter-rouge">t.Underlying</code> для ссылки на него.</p>

<p>Когда нужен этот дополнительный <code class="highlighter-rouge">Type</code> параметр?</p>
<ul>
  <li>когда тип является абстрактным и используется на уровне выше текущего</li>
</ul>

<p>Когда добавляется контекстный параметр <code class="highlighter-rouge">Type</code> в метод, 
он либо получается из другого параметра контекста, либо неявно с помощью вызова <code class="highlighter-rouge">Type.of</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">evalAndUse</span><span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="c1">// эквивалентно:</span>
<span class="n">evalAndUse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Expr</span><span class="o">(</span><span class="mi">3</span><span class="o">))(</span><span class="n">using</span> <span class="nv">Type</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
</code></pre></div></div>

<p>Не каждый тип можно использовать в качестве параметра <code class="highlighter-rouge">Type.of[..]</code> из коробки. 
Например, нельзя восстановить абстрактные типы, которые уже были стерты:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evalAndUse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">given</span> <span class="nc">Type</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Type</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="c1">// error</span>
  <span class="o">'{</span>
    <span class="k">val</span> <span class="nv">x2</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">$x</span>
    <span class="o">...</span> <span class="c1">// use x2</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Но можно написать более сложные типы, которые зависят от этих абстрактных типов. 
Например, если ищем или явно создаем <code class="highlighter-rouge">Type[List[T]]</code>, 
то системе потребуется <code class="highlighter-rouge">Type[T]</code> в текущем контексте для компиляции.</p>

<p>Хороший код должен добавлять <code class="highlighter-rouge">Types</code> только к параметрам контекста и никогда не использовать их явно. 
Однако явное использование полезно при отладке, хотя и достигается за счет краткости и ясности.</p>

<h3 id="toexpr">ToExpr</h3>

<p>Метод <code class="highlighter-rouge">Expr.apply</code> использует экземпляры <code class="highlighter-rouge">ToExpr</code> для создания выражения, которое создаст копию значения.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Expr</span><span class="k">:</span>
  <span class="kt">def</span> <span class="kt">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">,</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">summon</span><span class="o">[</span><span class="kt">ToExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="py">apply</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ToExpr</code> определяется следующим образом:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</code></pre></div></div>

<p>Метод <code class="highlighter-rouge">ToExpr.apply</code> примет значение <code class="highlighter-rouge">T</code> и сгенерирует код, который создаст копию этого значения во время выполнения.</p>

<p>Можно определить собственные <code class="highlighter-rouge">ToExpr</code>-ы, например:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">if</span> <span class="n">x</span> <span class="n">then</span> <span class="o">'{</span><span class="kc">true</span><span class="o">}</span>
    <span class="k">else</span> <span class="o">'{</span><span class="kc">false</span><span class="o">}</span>
<span class="o">}</span>

<span class="n">given</span> <span class="nc">ToExpr</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">stringContext</span><span class="k">:</span> <span class="kt">StringContext</span><span class="o">)(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">val</span> <span class="nv">parts</span> <span class="k">=</span> <span class="nc">Varargs</span><span class="o">(</span><span class="nv">stringContext</span><span class="o">.</span><span class="py">parts</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Expr</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
    <span class="o">'{</span> <span class="nc">StringContext</span><span class="o">(</span><span class="nc">$parts</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Конструктор <code class="highlighter-rouge">Varargs</code> просто создает <code class="highlighter-rouge">Expr[Seq[T]]</code>, который можно эффективно склеить как varargs. 
В общем, любую последовательность <code class="highlighter-rouge">$mySeq: _*</code> можно соединить, чтобы соединить ее как varargs.</p>

<h3 id="шаблоны-цитат">Шаблоны цитат</h3>

<p>Цитаты также можно использовать для проверки эквивалентности одного выражения другому 
или для деконструкции выражения на части.</p>

<h4 id="соответствие-точному-выражению">Соответствие точному выражению</h4>

<p>Самое простое, что можно сделать, - это проверить, соответствует ли выражение другому известному выражению. 
Пример:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valueOfBoolean</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="kc">true</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="kc">false</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>

<span class="k">def</span> <span class="nf">valueOfBooleanOption</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<h4 id="соответствующее-частичное-выражение">Соответствующее частичное выражение</h4>

<p>Для большей компактности, можно сопоставить часть выражения, используя склейку (<code class="highlighter-rouge">$</code>), 
чтобы сматчить произвольный код и извлечь его.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valueOfBooleanOption</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$boolExpr</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nf">valueOfBoolean</span><span class="o">(</span><span class="n">boolExpr</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<h4 id="соответствие-типов-выражений">Соответствие типов выражений</h4>

<p>Также можно сопоставлять код произвольного типа <code class="highlighter-rouge">T</code>. 
Ниже матчится <code class="highlighter-rouge">$x</code> типа <code class="highlighter-rouge">T</code> и на выходе получается <code class="highlighter-rouge">x</code> типа <code class="highlighter-rouge">Expr[T]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOfOption</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[T]</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<p>Также можно проверить тип выражения:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valueOf</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Any</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">$x</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nf">valueOfBoolean</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[Boolean]</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">$x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">}</span>  <span class="k">=&gt;</span> <span class="nf">valueOfBooleanOption</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[Option[Boolean]]</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<p>Или аналогично для частичного выражения:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="c1">// x: Expr[Boolean]</span>
</code></pre></div></div>

<h4 id="соответствующий-приемник-методов">Соответствующий приемник методов</h4>

<p>Когда желательно сопоставить получателя метода, нужно явно указать его тип:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="o">'{</span> <span class="o">(</span><span class="nc">$ls</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]).</span><span class="py">sum</span> <span class="o">}</span> <span class="k">=&gt;</span>
</code></pre></div></div>

<p>Если бы было написано <code class="highlighter-rouge">$ls.sum</code>, то нельзя было бы узнать тип <code class="highlighter-rouge">ls</code> и метод <code class="highlighter-rouge">sum</code>, который вызывается.</p>

<p>Другой распространенный случай, когда нужны аннотации типов, — это инфиксные операции:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="o">'{</span> <span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="nc">$y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span>
<span class="k">case</span> <span class="o">'{</span> <span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="nc">$y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span>
<span class="k">case</span> <span class="o">...</span>
</code></pre></div></div>

<h4 id="сопоставление-типов">Сопоставление типов</h4>

<p>До сих пор предполагалось, что типы внутри паттернов цитат будут известны статически. 
Шаблоны цитат также допускают общие типы и экзистенциальные типы.</p>

<h5 id="общие-типы-в-шаблонах">Общие типы в шаблонах</h5>

<p>Рассмотрим функцию <code class="highlighter-rouge">exprOfOption</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOfOption</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[T]</span>
                <span class="c1">// ^^^ type ascription with generic type T</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>Обратите внимание, что на этот раз <code class="highlighter-rouge">T</code> добавлен в шаблон явно, хотя его можно было бы вывести. 
Ссылаясь на универсальный тип <code class="highlighter-rouge">T</code> в шаблоне, в области видимости должен быть доступен <code class="highlighter-rouge">given Type[T]</code>. 
Это означает, что <code class="highlighter-rouge">$x: T</code> будет матчиться, только если <code class="highlighter-rouge">x</code> имеет тип <code class="highlighter-rouge">Expr[T]</code>. 
В данном конкретном случае это условие всегда будет истинным.</p>

<p>Теперь рассмотрим следующий вариант, где <code class="highlighter-rouge">x</code> - необязательное значение со (статически) неизвестным типом элемента:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOfOptionOf</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// x: Expr[T]</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<p>На этот раз шаблон будет соответствовать только в том случае, если <code class="highlighter-rouge">Some($x: T)</code> - тип <code class="highlighter-rouge">.OptionSome[T]</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exprOfOptionOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]('{</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="o">})</span>   <span class="c1">// Some('{3})</span>
<span class="n">exprOfOptionOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]('{</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"a"</span><span class="o">)</span> <span class="o">})</span> <span class="c1">// None</span>
</code></pre></div></div>

<h5 id="переменные-типа-в-шаблонах">Переменные типа в шаблонах</h5>

<p>Код в кавычках может содержать типы, неизвестные вне кавычек. 
Можно сопоставить их, используя переменные типа шаблона. 
Как и в обычном шаблоне, переменные типа записываются с использованием имен нижнего регистра.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exprOptionToList</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Expr</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]]</span> <span class="k">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">$x</span><span class="k">:</span> <span class="kt">t</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span>
                <span class="c1">// ^^^ this binds the type `t` in the body of the case</span>
      <span class="nc">Some</span><span class="o">('{</span> <span class="nc">List</span><span class="o">[</span><span class="kt">t</span><span class="o">](</span><span class="nc">$x</span><span class="o">)</span> <span class="o">})</span> <span class="c1">// x: Expr[List[t]]</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">=&gt;</span>
      <span class="nc">Some</span><span class="o">('{</span> <span class="nc">Nil</span> <span class="o">})</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</code></pre></div></div>

<p>Шаблон <code class="highlighter-rouge">$x: t</code> будет соответствовать выражению любого типа и <code class="highlighter-rouge">t</code> будет привязан к типу шаблона. 
Эта переменная типа доступна только в правой части case. 
В этом примере переменная используется для построения списка <code class="highlighter-rouge">List[t]($x)</code>(<code class="highlighter-rouge">List($x)</code> тоже сработает). 
Поскольку это тип, который неизвестен статически, нужен <code class="highlighter-rouge">given Type[t]</code> в области видимости. 
К счастью, приведенный шаблон автоматически это предоставит.</p>

<p>Простой шаблон <code class="highlighter-rouge">case '{ $expr: tpe } =&gt;</code> очень полезен, если необходимо знать точный тип выражения.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
<span class="n">expr</span> <span class="k">match</span>
  <span class="k">case</span> <span class="o">'{</span> <span class="nc">$expr</span><span class="k">:</span> <span class="kt">tpe</span> <span class="o">}</span> <span class="k">=&gt;</span>
    <span class="nv">Type</span><span class="o">.</span><span class="py">show</span><span class="o">[</span><span class="kt">tpe</span><span class="o">]</span> <span class="c1">// could be: Option[Int], Some[Int], None, Option[1], Option[2], ...</span>
    <span class="o">'{</span> <span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">tpe</span> <span class="o">=</span> <span class="nc">$expr</span><span class="o">;</span> <span class="n">x</span> <span class="o">}</span> <span class="c1">// binds the value without widening the type</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>В некоторых случаях необходимо определить переменную шаблона, 
на которую ссылаются несколько раз или имеющую некоторые ограничения типа. 
Для этого можно создать переменные шаблона в начале шаблона, используя <code class="highlighter-rouge">type t</code> переменную шаблона типа.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Use: Converts a redundant `list.map(f).map(g)` to only use one call
 * to `map`: `list.map(y =&gt; g(f(y)))`.
 */</span>
<span class="k">def</span> <span class="nf">fuseMap</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">'{</span>
    <span class="k">type</span> <span class="kt">u</span>
    <span class="k">type</span> <span class="kt">v</span>
    <span class="o">(</span><span class="nc">$ls</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">`u`</span><span class="o">])</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">$f</span><span class="k">:</span> <span class="kt">`u`</span> <span class="o">=&gt;</span> <span class="n">`v`</span><span class="o">)</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">$g</span><span class="k">:</span> <span class="kt">`v`</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">=&gt;</span>
    <span class="o">'{</span> <span class="nv">$ls</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="nc">$g</span><span class="o">(</span><span class="nc">$f</span><span class="o">(</span><span class="n">y</span><span class="o">)))</span> <span class="o">}</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Здесь определяются две переменные типа <code class="highlighter-rouge">u</code> и <code class="highlighter-rouge">v</code>, а затем к ним идет обращение. 
Обращение идет не напрямую <code class="highlighter-rouge">u</code> или <code class="highlighter-rouge">v</code> (без обратных кавычек), 
потому что они будут интерпретироваться как переменные нового типа с тем же именем переменной. 
Эта нотация следует обычному синтаксису 
<a href="https://www.scala-lang.org/files/archive/spec/2.13/08-pattern-matching.html#stable-identifier-patterns">шаблонов стабильных идентификаторов (stable identifier patterns)</a>. 
Кроме того, если переменная типа должна быть ограничена, 
можно добавить ограничения непосредственно к определению типа <code class="highlighter-rouge">case '{ type u &lt;: AnyRef; ... } =&gt;:</code></p>

<p>Обратите внимание, что предыдущий случай также может быть записан как <code class="highlighter-rouge">case '{ ($ls: List[u]).map[v]($f).map[T]($g) =&gt;</code>.</p>

<h5 id="quote-types-patterns">Quote types patterns</h5>

<p>Типы, представленные с помощью <code class="highlighter-rouge">Type[T]</code>, можно сопоставить с помощью шаблона <code class="highlighter-rouge">case '[...] =&gt;</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mirrorFields</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Type</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">match</span>
    <span class="k">case</span> <span class="o">'[</span><span class="kt">field</span> <span class="kt">*:</span> <span class="kt">fields</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="nv">Type</span><span class="o">.</span><span class="py">show</span><span class="o">[</span><span class="kt">field</span><span class="o">]</span> <span class="o">::</span> <span class="n">mirrorFields</span><span class="o">[</span><span class="kt">fields</span><span class="o">]</span>
    <span class="k">case</span> <span class="o">'[</span><span class="kt">EmptyTuple</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="nc">Nil</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nv">compiletime</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"Expected known tuple but got: "</span> <span class="o">+</span> <span class="nv">Type</span><span class="o">.</span><span class="py">show</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

<span class="n">mirrorFields</span><span class="o">[</span><span class="kt">EmptyTuple</span><span class="o">]</span>         <span class="c1">// Nil</span>
<span class="n">mirrorFields</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="c1">// List("Int", "String", "Int")</span>
<span class="n">mirrorFields</span><span class="o">[</span><span class="kt">Tuple</span><span class="o">]</span>              <span class="c1">// error: Expected known tuple but got: Tuple</span>
</code></pre></div></div>

<p>Как и в случае выражений шаблонов в кавычках, переменные типа представлены с использованием имен нижнего регистра.</p>

<h3 id="fromexpr">FromExpr</h3>

<p>Методы <code class="highlighter-rouge">Expr.value</code>, <code class="highlighter-rouge">Expr.valueOrError</code> и <code class="highlighter-rouge">Expr.unapply</code> 
используют экземпляры <code class="highlighter-rouge">FromExpr</code> для извлечения значения, если это возможно.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extension</span> <span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span>
  <span class="kt">def</span> <span class="kt">value</span><span class="o">(</span><span class="kt">using</span> <span class="kt">Quotes</span><span class="o">)(</span><span class="kt">using</span> <span class="kt">fromExpr:</span> <span class="kt">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">fromExpr</span><span class="o">.</span><span class="py">unapply</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">valueOrError</span><span class="o">(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)(</span><span class="n">using</span> <span class="n">fromExpr</span><span class="k">:</span> <span class="kt">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="nv">fromExpr</span><span class="o">.</span><span class="py">unapply</span><span class="o">(</span><span class="n">expr</span><span class="o">).</span><span class="py">getOrElse</span><span class="o">(</span><span class="nv">eport</span><span class="o">.</span><span class="py">throwError</span><span class="o">(</span><span class="s">"..."</span><span class="o">,</span> <span class="n">expr</span><span class="o">))</span>
<span class="n">end</span> <span class="n">extension</span>

<span class="k">object</span> <span class="nc">Expr</span><span class="k">:</span>
  <span class="kt">def</span> <span class="kt">unapply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)(</span><span class="n">using</span> <span class="n">fromExpr</span><span class="k">:</span> <span class="kt">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">fromExpr</span><span class="o">.</span><span class="py">unapply</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">FromExpr</code> определяется следующим образом:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FromExpr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</code></pre></div></div>

<p>Метод <code class="highlighter-rouge">FromExpr.unapply</code> примет значение <code class="highlighter-rouge">x</code> и сгенерирует код, 
который создаст копию этого значения во время выполнения.</p>

<p>Можно определить собственные <code class="highlighter-rouge">FromExprs</code> следующим образом:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span> <span class="nc">FromExpr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">x</span> <span class="k">match</span>
      <span class="k">case</span> <span class="o">'{</span> <span class="kc">true</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">'{</span> <span class="kc">false</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>

<span class="n">given</span> <span class="nc">FromExpr</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">]</span> <span class="k">with</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">StringContext</span><span class="o">]</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">'{</span> <span class="k">new</span> <span class="nc">StringContext</span><span class="o">(</span><span class="n">$</span><span class="o">{</span><span class="nc">Varargs</span><span class="o">(</span><span class="nc">Exprs</span><span class="o">(</span><span class="n">args</span><span class="o">))}</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">StringContext</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">'{</span>     <span class="nc">StringContext</span><span class="o">(</span><span class="n">$</span><span class="o">{</span><span class="nc">Varargs</span><span class="o">(</span><span class="nc">Exprs</span><span class="o">(</span><span class="n">args</span><span class="o">))}</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">}</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">StringContext</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Стоит обратить внимание на то, что были рассмотрены два случая <code class="highlighter-rouge">StringContext</code>. 
Поскольку это объект <em>case class</em>, его можно создать 
с помощью <code class="highlighter-rouge">new StringContext</code> или <code class="highlighter-rouge">StringContext.apply</code> из объекта-компаньона. 
Также был использован <code class="highlighter-rouge">Varargs</code> экстрактор для сопоставления аргументов 
типа <code class="highlighter-rouge">Expr[Seq[String]]</code> с <code class="highlighter-rouge">Seq[Expr[String]]</code>. 
Затем был использован <code class="highlighter-rouge">Exprs</code>, чтобы сопоставить известные константы в <code class="highlighter-rouge">Seq[Expr[String]]</code> для получения <code class="highlighter-rouge">Seq[String]</code>.</p>

<h3 id="цитаты">Цитаты</h3>

<p><code class="highlighter-rouge">Quotes</code> - основная точка входа для создания всех цитат. 
Этот контекст обычно просто передается через контекстные абстракции (<code class="highlighter-rouge">using</code> и <code class="highlighter-rouge">?=&gt;</code>). 
Каждая область цитаты будет иметь свой собственный <code class="highlighter-rouge">Quotes</code>. 
Новые области вводятся каждый раз, когда вводится соединение (<code class="highlighter-rouge">${ ... }</code>). 
Хотя кажется, что splice принимает выражение в качестве аргумента, на самом деле он принимает <code class="highlighter-rouge">Quotes ?=&gt; Expr[T]</code>. 
Следовательно, можно было бы написать это явно как <code class="highlighter-rouge">${ (using q) =&gt; ... }</code>. 
Это может быть полезно при отладке, чтобы избежать создания имен для этих областей.</p>

<p>Метод <code class="highlighter-rouge">scala.quoted.quotes</code> обеспечивает простой способ использования <code class="highlighter-rouge">Quotes</code> без его именования. 
Обычно он импортируется вместе с <code class="highlighter-rouge">Quotes</code> используя <code class="highlighter-rouge">import scala.quoted.*</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">$</span><span class="o">{</span> <span class="o">(</span><span class="n">using</span> <span class="n">q1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">body</span><span class="o">(</span><span class="n">using</span> <span class="n">q1</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// equivalent to</span>
<span class="n">$</span><span class="o">{</span> <span class="nf">body</span><span class="o">(</span><span class="n">using</span> <span class="n">quotes</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>Предупреждение: если вы явно назовете <code class="highlighter-rouge">Quotes</code> <code class="highlighter-rouge">quotes</code>, вы перетрёте это определение.</p>

<p>Когда пишется splice верхнего уровня в макросе, вызывается что-то похожее на следующее определение. 
Этот splice обеспечит начальное значение <code class="highlighter-rouge">Quotes</code>, связанное с расширением макроса.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">$</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Quotes</span> <span class="kt">?=&gt;</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></div></div>

<p>Когда есть splice внутри цитаты, внутренний контекст цитаты будет зависеть от внешнего. 
Эта ссылка представлена с использованием типа <code class="highlighter-rouge">Quotes.Nested</code>. 
Пользователям цитат почти никогда не понадобится использовать <code class="highlighter-rouge">Quotes.Nested</code>. 
Эти сведения полезны только для расширенных макросов, 
которые будут проверять код и могут столкнуться с деталями кавычек и splice-ов.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">using</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quotes</span><span class="o">)</span> <span class="k">=</span> <span class="o">'{</span>
  <span class="n">$</span><span class="o">{</span> <span class="o">(</span><span class="n">using</span> <span class="n">q2</span><span class="k">:</span> <span class="kt">q1.Nested</span><span class="o">)</span> <span class="o">?=&gt;</span>
      <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Можно представить, что вложенный splice подобен следующему методу, где <code class="highlighter-rouge">ctx</code> - контекст, полученный окружающей цитатой.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">$</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="n">q</span><span class="k">:</span> <span class="kt">Quotes</span><span class="o">)(</span><span class="n">x</span><span class="k">:</span> <span class="kt">q.Nested</span> <span class="kt">?=&gt;</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></div></div>

<h3 id="β-reduction">β-reduction</h3>

<p>Когда есть лямбда, применяемая к аргументу в кавычке <code class="highlighter-rouge">'{ ((x: Int) =&gt; x + x)(y) }</code>, 
она не уменьшается внутри кавычки; код сохраняется как есть. 
Существует оптимизация, которая будет β-редуцировать все лямбда-выражения, непосредственно применяемые к параметрам, 
чтобы избежать создания замыкания. 
Это не будет видно с точки зрения цитаты.</p>

<p>Иногда бывает полезно выполнить эту β-редукцию непосредственно на цитатах. 
Для этого используется функция <code class="highlighter-rouge">Expr.betaReduce[T]</code>, которая получает <code class="highlighter-rouge">Expr[T]</code> и β-редуцирует, 
если она непосредственно содержит применяемую лямбду.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Expr</span><span class="o">.</span><span class="py">betaReduce</span><span class="o">('{</span> <span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">)(</span><span class="n">y</span><span class="o">)</span> <span class="o">})</span> <span class="c1">// returns '{ val x = y; x + x }</span>
</code></pre></div></div>

<h3 id="summon-values">Summon values</h3>

<p>Есть два способа вызвать значения в макросе.
Во-первых, использовать using параметр во встроенном методе, который явно передается реализации макроса.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">setOf</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="n">setOfCode</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="ss">'ord</span><span class="o">)</span> <span class="o">}</span>

<span class="k">def</span> <span class="nf">setOfCode</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">ord</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">'{</span> <span class="nv">TreeSet</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="nc">$ord</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>В этом случае параметр контекста обнаруживается до развертывания макроса. Если не найден, макрос не будет раскрыт.</p>

<p>Второй способ — использование <code class="highlighter-rouge">Expr.summon</code>. 
Это позволяет программно искать различные given выражения. 
Следующий пример аналогичен предыдущему примеру:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">setOf</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="n">setOfCode</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">}</span>

<span class="k">def</span> <span class="nf">setOfCode</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Expr</span><span class="o">.</span><span class="py">summon</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">match</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ord</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">'{</span> <span class="nv">TreeSet</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">using</span> <span class="nc">$ord</span><span class="o">)</span> <span class="o">}</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">'{</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div></div>

<p>Разница в том, что во втором сценарии макрос разворачивается перед выполнением неявного поиска. 
Поэтому можно написать произвольный код для обработки случая, когда элемент <code class="highlighter-rouge">Ordering[T]</code> не найден. 
Здесь используется <code class="highlighter-rouge">HashSet</code> вместо <code class="highlighter-rouge">TreeSet</code>, потому что первый не нуждается в <code class="highlighter-rouge">Ordering</code>.</p>

<h3 id="цитатные-классы-типов">Цитатные классы типов</h3>

<p>В предыдущем примере было показано, как явно использовать класс типа <code class="highlighter-rouge">Expr[Ordering[T]]</code>, 
используя предложение аргумента <code class="highlighter-rouge">using</code>. 
Это хорошо, но не очень удобно, если нужно использовать класс типов несколько раз. 
Чтобы показать это, будем использовать функцию <code class="highlighter-rouge">powerCode</code>, 
которую можно использовать для любого числового типа.</p>

<p>Во-первых, может быть полезно сделать так, чтобы класс типа <code class="highlighter-rouge">Expr</code> мог сделать его given параметром. 
Для этого нужно явно указать <code class="highlighter-rouge">powerCode</code> в <code class="highlighter-rouge">power</code>, 
потому что есть given <code class="highlighter-rouge">Numeric[Num]</code>, но требуется <code class="highlighter-rouge">Expr[Numeric[Num]]</code>. 
Но тогда можно игнорировать его в <code class="highlighter-rouge">powerMacro</code> и в любом другом месте, которое только его передает.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inline</span> <span class="k">def</span> <span class="nf">power</span><span class="o">[</span><span class="kt">Num</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Num</span><span class="o">,</span> <span class="n">inline</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">using</span> <span class="n">num</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">Num</span><span class="o">])</span> <span class="k">=</span>
  <span class="n">$</span><span class="o">{</span> <span class="nf">powerMacro</span><span class="o">(</span><span class="ss">'x</span><span class="o">,</span> <span class="ss">'n</span><span class="o">)(</span><span class="n">using</span> <span class="ss">'num</span><span class="o">)</span> <span class="o">}</span>

<span class="k">def</span> <span class="nf">powerMacro</span><span class="o">[</span><span class="kt">Num:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Num</span><span class="o">],</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="n">using</span> <span class="nc">Expr</span><span class="o">[</span><span class="kt">Numeric</span><span class="o">[</span><span class="kt">Num</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Num</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">powerCode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">n</span><span class="o">.</span><span class="py">valueOrAbort</span><span class="o">)</span>
</code></pre></div></div>

<p>Чтобы использовать этот класс типа, нужен given <code class="highlighter-rouge">Numeric[Num]</code>,но у нас есть <code class="highlighter-rouge">Expr[Numeric[Num]]</code>, 
и поэтому нужно склеить это выражение в сгенерированном коде. 
Чтобы сделать его доступным, можно просто соединить его с заданным определением.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">powerCode</span><span class="o">[</span><span class="kt">Num:</span> <span class="kt">Type</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Num</span><span class="o">],</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">using</span> <span class="n">num</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Numeric</span><span class="o">[</span><span class="kt">Num</span><span class="o">]])(</span><span class="n">using</span> <span class="nc">Quotes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">Num</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">'{</span> <span class="nv">$num</span><span class="o">.</span><span class="py">one</span> <span class="o">}</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">'{</span>
    <span class="n">given</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">Num</span><span class="o">]</span> <span class="k">=</span> <span class="nc">$num</span>
    <span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="nc">$x</span> <span class="o">*</span> <span class="nc">$x</span>
    <span class="n">$</span><span class="o">{</span> <span class="nf">powerCode</span><span class="o">(</span><span class="ss">'y</span><span class="o">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">else</span> <span class="o">'{</span>
    <span class="n">given</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">Num</span><span class="o">]</span> <span class="k">=</span> <span class="nc">$num</span>
    <span class="nc">$x</span> <span class="o">*</span> <span class="n">$</span><span class="o">{</span> <span class="nf">powerCode</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>References:</strong></p>
<ul>
  <li><a href="https://docs.scala-lang.org/scala3/guides/macros/quotes.html">Scala 3 Guide</a></li>
  <li><a href="https://docs.scala-lang.org/scala3/reference/metaprogramming/macros.html">Scala 3 Reference</a></li>
</ul>


<hr>
<div class="edit-button" style="display: flex; justify-content: space-between;">
    
    <a href="/scalaworkbook/docs/metaprogramming/macros" class="btn-sm btn-info btn-left"><-- Предыдущая</a>
    
    
    <a href="/scalaworkbook/docs/metaprogramming/runtime-staging" class="btn-sm btn-info btn-right">Следующая --></a>
    
</div></section><div class="edit-button"><a href="https://github.com/artemkorsakov/scalaworkbook/edit/main/docs/docs/docs/metaprogramming/quoted-code.md" target="_blank" rel="noopener noreferrer" class="btn-sm btn-info">Редактировать страницу</a></div></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalaworkbook/highlight/highlight.pack.js"></script><script src="/scalaworkbook/lunr/lunr.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script src="/scalaworkbook/js/search.js"></script><script src="/scalaworkbook/js/main.js"></script></body></html>