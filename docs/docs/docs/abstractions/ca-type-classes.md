---
layout: docsplus
title: "Импл. type классов"
prev: abstractions/ca-extension-methods
next: abstractions/ca-multiversal-equality
---

## Имплементация type классов

Класс типов — это абстрактный параметризованный тип, 
который позволяет добавлять новое поведение к любому закрытому типу данных без использования подтипов. 
Это полезно во многих случаях, например:
- выражение того, как тип, которым вы не владеете, например, из стандартной или сторонней библиотеки,
  соответствует такому поведению
- добавление поведения к нескольким типам без введения отношений подтипов между этими типами

В Scala 3 классы типов — это просто trait-ы с одним или несколькими параметрами типа, 
реализации которых предоставляются заданными экземплярами.

### Пример

Рассмотрим `Show` - хорошо известный класс типов в Haskell. 
Следующий код показывает один из способов его реализации в Scala 3. 
Предположим, что классы Scala не имеют метода `toString`. 
Можно определить класс `Show`, чтобы добавить это поведение к любому классу, 
который необходимо преобразовать в пользовательскую строку.

#### Класс типа

Первым шагом в создании класса типа является объявление параметризованного trait, 
который имеет один или несколько абстрактных методов. 
Поскольку у `Showable` есть только один метод с именем `show`, он написан так:

```scala mdoc:silent
// Класс типа
trait Showable[A]:
  extension(a: A) def show: String
```

В Scala 3 это способ сказать, что любой тип, который реализует этот trait, должен определять, как работает метод `show`. 
Обратите внимание, что синтаксис очень близок к обычному trait:

```scala
// a trait
trait Show:
  def show: String
```

Следует отметить несколько важных моментов:
- классы типов, такие как `Showable`, принимают параметр типа `A`, чтобы установить, 
для какого типа предоставляется реализация `show`; Напротив, стандартные trait, такие, как `Show`, этого не делают.
- чтобы добавить функциональность `show` к определенному типу `A`, 
стандартный trait требует, чтобы `A` расширял `Show`, 
в то время как для классов типов требуется реализация `Showable[A]`.
- чтобы разрешить одинаковый синтаксис вызова метода в обоих `Showable`, который имитирует один из `Show`, 
`Showable.show` определяется как метод расширения.

#### Реализация конкретных экземпляров

Следующий шаг — определить, для каких классов должен работать `Showable`, а затем реализовать это поведение. 
Например, чтобы реализовать `Showable` для данного класса `Person`:

```scala mdoc:silent
case class Person(firstName: String, lastName: String)
```

нужно определить `given` значение для `Showable[Person]`. 
Этот код предоставляет конкретный экземпляр `Showable` для класса `Person`:

```scala mdoc:silent
given Showable[Person] with
  extension(p: Person) def show: String =
    s"${p.firstName} ${p.lastName}"
```

Как показано, `Showable[Person]` определяет метод расширения класса `Person` 
и использует ссылку `p` внутри тела метода `show`.

#### Использование класса типов

Этот класс типа можно использовать следующим образом:

```scala mdoc
val person = Person("John", "Doe")
println(person.show)
```

Опять же, если бы в Scala не было метода `toString`, доступного для каждого класса, 
можно было бы использовать эту технику, чтобы добавить поведение `Showable` к любому классу, 
который необходимо преобразовать в `String`.

#### Написание методов, использующих класс типов

Как и в случае с наследованием, можно определить методы, использующие `Showable` в качестве параметра типа:

```scala mdoc
def showAll[S: Showable](xs: List[S]): Unit =
  xs.foreach(x => println(x.show))
showAll(List(Person("Jane", "Jackson"), Person("Mary", "Jameson")))
```

#### Класс типов с несколькими методами

Если необходимо создать класс типов с несколькими методами, исходный синтаксис выглядит следующим образом:

```scala
trait HasLegs[A]:
  extension (a: A)
    def walk(): Unit
    def run(): Unit
```

### Распространенные классы типов

#### Полугруппы и моноиды

Вот определение класса типа `Monoid`:

```scala mdoc:silent
trait SemiGroup[T]:
  extension (x: T) def combine (y: T): T

trait Monoid[T] extends SemiGroup[T]:
  def unit: T
```

Реализация класса типа `Monoid` для типа String может быть следующей:

```scala mdoc:silent
given Monoid[String] with
  extension (x: String) def combine (y: String): String = x.concat(y)
  def unit: String = ""
```

Тогда как для типа `Int` можно было бы написать следующее:

```scala mdoc:silent
given Monoid[Int] with
  extension (x: Int) def combine (y: Int): Int = x + y
  def unit: Int = 0
```

Этот моноид теперь можно использовать в качестве привязки к контексту в следующем методе `combineAll`:

```scala mdoc:silent
def combineAll[T: Monoid](xs: List[T]): T =
  xs.foldLeft(summon[Monoid[T]].unit)(_.combine(_))
```

Чтобы избавиться от `summon[...]` можно определить объект `Monoid` следующим образом:

```scala mdoc:silent
object Monoid:
  def apply[T](using m: Monoid[T]) = m
```

Что позволило бы переписать метод `combineAll` следующим образом:

```scala mdoc:silent
def combineAll[T: Monoid](xs: List[T]): T =
  xs.foldLeft(Monoid[T].unit)(_.combine(_))
```

#### Функторы

Тип `Functor` предоставляет возможность "отображать" свои значения, 
т.е. применять функцию, которая трансформируется внутри значения, сохраняя при этом его форму. 
Например, чтобы изменить каждый элемент коллекции, не удаляя и не добавляя их. 
Можно представить все типы, которые могут быть "отображены" с помощью `F`. 
Это конструктор типа: тип его значений становится конкретным, когда предоставляется аргумент типа. 
Поэтому мы пишем его `F[_]`, намекая, что тип `F` принимает в качестве аргумента другой тип. 
Таким образом, определение generic `Functor` будет записано как:

```scala mdoc:silent
trait Functor[F[_]]:
  def map[A, B](x: F[A], f: A => B): F[B]
```

Что можно было бы прочитать следующим образом: 
"Конструктор `Functor` типа `F[_]` представляет собой возможность преобразования `F[A]` к `F[B]` 
посредством применения функции `f` с типом `A => B`". 
Мы называем здесь определение `Functor` классом типов. 
Экземпляр `Functor` для типа `List` можно определить следующим образом:

```scala mdoc:silent
given Functor[List] with
  def map[A, B](x: List[A], f: A => B): List[B] =
    x.map(f) // List already has a `map` method
```


---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/ca-type-classes.html)
