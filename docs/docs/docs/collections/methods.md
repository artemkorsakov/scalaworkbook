---
layout: docs
title: "Методы в коллекциях"
---

## {{page.title}}

Важным преимуществом коллекций Scala является то, что они поставляются с десятками методов "из коробки", 
которые доступны для неизменяемых и изменяемых типов коллекций. 
Больше нет необходимости писать пользовательские циклы `for` каждый раз, когда нужно работать с коллекцией. 
При переходе от одного проекта к другому, можно обнаружить, что используются одни и те же методы.

В коллекциях доступны десятки методов, поэтому здесь показаны не все из них. 
Показаны только некоторые из наиболее часто используемых методов, в том числе:
- `map`
- `filter`
- `foreach`
- `head`
- `tail`
- `take`, `takeWhile`
- `drop`, `dropWhile`
- `reduce`

Следующие методы работают со всеми типами последовательностей, включая `List`, `Vector`, `ArrayBuffer` и т. д.. 
Примеры рассмотрены на `List`-е, если не указано иное.

> Важно напомнить, что ни один из методов в `List` не изменяет список. 
> Все они работают в функциональном стиле, то есть возвращают новую коллекцию с измененными результатами.


### Примеры распространенных методов

Для общего представления в примерах ниже показаны некоторые из наиболее часто используемых методов коллекций. 
Во-первых, вот несколько методов, которые не используют лямбда-выражения:

```scala mdoc
val a = List(10, 20, 30, 40, 10)
a.distinct                      
a.drop(2)                
a.dropRight(2)             
a.head                            
a.headOption                      
a.init                       
a.intersect(List(19,20,21))  
a.last                       
a.lastOption                 
a.slice(2,4)                 
a.tail                       
a.take(3)                    
a.takeRight(2)               
```

#### Функции высшего порядка и лямбда-выражения

Далее будут показаны некоторые часто используемые функции высшего порядка (HOF), 
которые принимают лямбды (анонимные функции). 
Для начала приведем несколько вариантов лямбда-синтаксиса, начиная с самой длинной формы, 
поэтапно переходящей к наиболее сжатой:

```scala mdoc
a.filter((i: Int) => i < 25)   // 1. наиболее явная форма
a.filter((i) => i < 25)        // 2. `Int` не требуется
a.filter(i => i < 25)          // 3. скобки не обязательны
a.filter(_ < 25)               // 4. `i` не требуется   
```

В этих примерах:
1. Первый пример показывает самую длинную форму. Такое многословие требуется редко, только в самых сложных случаях.
2. Компилятор знает, что `a` содержит `Int`, поэтому нет необходимости повторять это в функции.
3. Если в функции только один параметр, например `i`, то скобки не нужны.
4. В случае одного параметра, если он появляется в анонимной функции только раз, можно заменить параметр на `_`.

В главе [Анонимные функции](../functions/anonymous) представлена более подробная информация 
и примеры правил, связанных с сокращением лямбда-выражений. 

Примеры других HOF, использующих краткий лямбда-синтаксис:

```scala mdoc
a.dropWhile(_ < 25)
a.filter(_ > 100)  
a.filterNot(_ < 25)
a.find(_ > 20)     
a.takeWhile(_ < 30)
```

Важно отметить, что HOF также принимают в качестве параметров методы и функции, а не только лямбда-выражения. 
Вот несколько примеров `map` HOF, в которой используется метод с именем `double`. 
Снова показаны несколько вариантов синтаксиса лямбда:

```scala mdoc
def double(i: Int) = i * 2
a.map(i => double(i))
a.map(double(_))
a.map(double)                        
```

В последнем примере, когда анонимная функция состоит из одного вызова функции, принимающей один аргумент, 
нет необходимости указывать имя аргумента, поэтому даже `_` не требуется. 

Наконец, HOF можно комбинировать:

```scala mdoc
a.filter(_ < 40)
 .takeWhile(_ < 30)
 .map(_ * 10)                        
```

> **P.S.** Пример призван показать только то, как принято последовательно вызывать функции на неизменяемых коллекциях.
Его недостаток в том, что обход коллекции происходит целых три раза.

### Пример данных

В следующих разделах используются следующие списки:

```scala mdoc
val oneToTen = (1 to 10).toList
val names = List("adam", "brandy", "chris", "david")                         
```

### map

Метод `map` проходит через каждый элемент в существующем списке, применяя переданную функцию к каждому элементу, 
по одному за раз; затем возвращается новый список с измененными элементами.

Вот пример применения метода `map` к списку `oneToTen`:

```scala mdoc
val doubles = oneToTen.map(_ * 2)                         
```

Также можно писать анонимные функции, используя более длинную форму, например:

```scala mdoc:nest
val doubles = oneToTen.map(i => i * 2)                       
```

Однако в этом документы будет всегда использоваться первая, более короткая форма.

Вот еще несколько примеров применения метода `map` к `oneToTen` и `names`:

```scala mdoc
val capNames = names.map(_.capitalize)
val nameLengthsMap = names.map(s => (s, s.length)).toMap
val isLessThanFive = oneToTen.map(_ < 5)                       
```

Как показано в последних двух примерах, совершенно законно (и распространено) использовать `map` 
для возврата коллекции, которая имеет тип, отличный от исходного типа.

### filter

Метод `filter` создает новый список, содержащий элемент, удовлетворяющий предоставленному предикату. 
Предикат или условие — это функция, которая возвращает `Boolean` (`true` или `false`). 
Вот несколько примеров:

```scala mdoc
val lessThanFive = oneToTen.filter(_ < 5)
val evens = oneToTen.filter(_ % 2 == 0)
val shortNames = names.filter(_.length <= 4)                         
```

Отличительной особенностью функциональных методов коллекций является то, 
что их можно объединять вместе для решения задач. 
Например, в этом примере показано, как связать `filter` и `map`:

```scala mdoc
oneToTen.filter(_ < 4).map(_ * 10)
```

### foreach

Метод `foreach` используется для перебора всех элементов коллекции. 
Стоит обратить внимание, что `foreach` используется для побочных эффектов, таких как печать информации. 
Вот пример с `names`:

```scala mdoc
names.foreach(println)                         
```

### head


```scala mdoc
val b = List(List(1,2), List(3,4))
b.flatten                          
```
```scala mdoc
val nums = List("one", "two")
nums.flatMap(_.toUpperCase)
```

Эти примеры показывают, как методы `foldLeft` и `reduceLeft` используются для суммирования значений в последовательности целых чисел:

```scala mdoc
val firstTen = (1 to 10).toList
firstTen.reduceLeft(_ + _)        
firstTen.foldLeft(100)(_ + _) // 100 - начальное значение
```

Описание всех методов классов коллекции можно найти в [API документации](https://scala-lang.org/api/3.x/).








---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/taste-collections.html)
- [Scala3 book, Collections Methods](https://docs.scala-lang.org/scala3/book/collections-methods.html)
