---
layout: docsplus
title: "Методы в коллекциях"
prev: ./classes
next: ../fp
---

## {{page.title}}

Важным преимуществом коллекций Scala является то, что они поставляются с десятками методов "из коробки", 
которые доступны для неизменяемых и изменяемых типов коллекций. 
Больше нет необходимости писать пользовательские циклы `for` каждый раз, когда нужно работать с коллекцией. 
При переходе от одного проекта к другому, можно обнаружить, что используются одни и те же методы.

В коллекциях доступны десятки методов, поэтому здесь показаны не все из них. 
Показаны только некоторые из наиболее часто используемых методов, в том числе:
- `map`
- `filter`
- `foreach`
- `head`
- `tail`
- `take`, `takeWhile`
- `drop`, `dropWhile`
- `reduce`

Следующие методы работают со всеми типами последовательностей, включая `List`, `Vector`, `ArrayBuffer` и т. д.. 
Примеры рассмотрены на `List`-е, если не указано иное.

> Важно напомнить, что ни один из методов в `List` не изменяет список. 
> Все они работают в функциональном стиле, то есть возвращают новую коллекцию с измененными результатами.


### Примеры распространенных методов

Для общего представления в примерах ниже показаны некоторые из наиболее часто используемых методов коллекций. 
Вот несколько методов, которые не используют лямбда-выражения:

```scala mdoc
val a = List(10, 20, 30, 40, 10)
a.distinct                      
a.drop(2)                
a.dropRight(2)             
a.head                            
a.headOption                      
a.init                       
a.intersect(List(19,20,21))  
a.last                       
a.lastOption                 
a.slice(2,4)                 
a.tail                       
a.take(3)                    
a.takeRight(2)               
```

#### Функции высшего порядка и лямбда-выражения

Далее будут показаны некоторые часто используемые функции высшего порядка (HOF), 
которые принимают лямбды (анонимные функции). 
Для начала приведем несколько вариантов лямбда-синтаксиса, начиная с самой длинной формы, 
поэтапно переходящей к наиболее сжатой:

```scala mdoc:to-string
a.filter((i: Int) => i < 25)
a.filter((i) => i < 25)     
a.filter(i => i < 25)       
a.filter(_ < 25)            
```

В этих примерах:
1. Первый пример показывает самую длинную форму. Такое многословие требуется редко, только в самых сложных случаях.
2. Компилятор знает, что `a` содержит `Int`, поэтому нет необходимости повторять это в функции.
3. Если в функции только один параметр, например `i`, то скобки не нужны.
4. В случае одного параметра, если он появляется в анонимной функции только раз, его можно заменить на `_`.

В главе [Анонимные функции](../functions/anonymous) представлена более подробная информация 
и примеры правил, связанных с сокращением лямбда-выражений. 

Примеры других HOF, использующих краткий лямбда-синтаксис:

```scala mdoc
a.dropWhile(_ < 25)
a.filter(_ > 35)  
a.filterNot(_ < 25)
a.find(_ > 20)     
a.takeWhile(_ < 30)
```

Важно отметить, что HOF также принимают в качестве параметров методы и функции, а не только лямбда-выражения. 
Вот несколько примеров, в которых используется метод с именем `double`. 
Снова показаны несколько вариантов лямбда-выражений:

```scala mdoc
def double(i: Int) = i * 2
a.map(i => double(i))
a.map(double(_))
a.map(double)                        
```

В последнем примере, когда анонимная функция состоит из одного вызова функции, принимающей один аргумент, 
нет необходимости указывать имя аргумента, поэтому даже `_` не требуется. 

Наконец, HOF можно комбинировать:

```scala mdoc
a.filter(_ < 40)
 .takeWhile(_ < 30)
 .map(_ * 10)                        
```

> **P.S.** Пример призван показать только то, как принято последовательно вызывать функции на неизменяемых коллекциях.
Его недостаток в том, что обход коллекции происходит целых три раза.

### Пример данных

В следующих разделах используются следующие списки:

```scala mdoc
val oneToTen = (1 to 10).toList
val names = List("adam", "brandy", "chris", "david")                         
```

### map

Метод `map` проходит через каждый элемент в списке, применяя переданную функцию к элементу, 
по одному за раз; затем возвращается новый список с измененными элементами.

Вот пример применения метода `map` к списку `oneToTen`:

```scala mdoc
val doubles = oneToTen.map(_ * 2)                         
```

Также можно писать анонимные функции, используя более длинную форму, например:

```scala mdoc:nest
val doubles = oneToTen.map(i => i * 2)                       
```

Однако в этом документе будет всегда использоваться первая, более короткая форма.

Вот еще несколько примеров применения метода `map` к `oneToTen` и `names`:

```scala mdoc:width=120
val capNames = names.map(_.capitalize)
val nameLengthsMap = names.map(s => (s, s.length)).toMap
val isLessThanFive = oneToTen.map(_ < 5)                       
```

Как показано в последних двух примерах, совершенно законно (и распространено) использование `map` 
для возврата коллекции, которая имеет тип, отличный от исходного типа.

### filter

Метод `filter` создает новый список, содержащий только те элементы, которые удовлетворяют предоставленному предикату. 
Предикат или условие — это функция, которая возвращает `Boolean` (`true` или `false`). 
Вот несколько примеров:

```scala mdoc
val lessThanFive = oneToTen.filter(_ < 5)
val evens = oneToTen.filter(_ % 2 == 0)
val shortNames = names.filter(_.length <= 4)                         
```

Отличительной особенностью функциональных методов коллекций является то, 
что их можно объединять вместе для решения задач. 
Например, в этом примере показано, как связать `filter` и `map`:

```scala mdoc
oneToTen.filter(_ < 4).map(_ * 10)
```

> Если `filter` используется перед `map`, `flatMap` или `foreach`, 
> то для лучшей производительности он заменяется на `withFilter`, например, `oneToTen.withFilter(_ < 4).map(_ * 10)`

### foreach

Метод `foreach` используется для перебора всех элементов коллекции. 
Стоит обратить внимание, что `foreach` используется для побочных эффектов, таких как печать информации. 
Вот пример с `names`:

```scala mdoc
names.foreach(println)                         
```

### head

Метод `head` взят из Lisp и других более ранних языков функционального программирования. 
Он используется для доступа к первому элементу (головному (head) элементу) списка:

```scala mdoc
oneToTen.head 
names.head                        
```

`String` можно рассматривать как последовательность символов, 
т.е. строка также является коллекцией и имеет многие методы коллекций. 
Вот как `head` работает со строками:

```scala mdoc
"foo".head 
"bar".head                    
```

На пустой коллекции `head` выдает исключение:

```scala mdoc
val emptyList = List[Int]()
```
```scala mdoc:crash
emptyList.head                         
```

Чтобы не натыкаться на исключение вместо `head` желательно использовать `headOption`,
особенно при разработке в функциональном стиле:

```scala mdoc
emptyList.headOption                        
```

`headOption` не генерирует исключение, а возвращает тип `Option` со значением `None`. 
Более подробно о функциональном стиле программирования будет рассказано 
в [соответствующей главе](../fp).

### tail

Метод `tail` также взят из Lisp и используется для вывода всех элементов в списке после `head`. 

```scala mdoc
oneToTen.head
oneToTen.tail

names.head   
names.tail                 
```

Так же, как и `head`, `tail` можно использовать со строками:

```scala mdoc
"foo".tail
"bar".tail
```

`tail` выбрасывает исключение `java.lang.UnsupportedOperationException`, если список пуст, 
поэтому, как и в случае с `head` и `headOption`, существует также метод `tailOption`, 
который предпочтительнее в функциональном программировании.

Список матчится, поэтому можно использовать такие выражения:

```scala mdoc
val x :: xs = names
```

`x` - это `head` списка, а `xs` - `tail`.

Подобный pattern matching полезен во многих случаях, например, 
при написании метода суммирования с использованием рекурсии:

```scala
def sum(list: List[Int]): Int = list match
  case Nil => 0
  case x :: xs => x + sum(xs)
```

### take, takeRight, takeWhile

Методы `take`, `takeRight` и `takeWhile` предоставляют удобный способ "брать" (take) элементы из списка 
для создания нового. Примеры `take` и `takeRight`:

```scala mdoc
oneToTen.take(1)      
oneToTen.take(2)      

oneToTen.takeRight(1) 
oneToTen.takeRight(2)                        
```

Обратите внимание, как эти методы работают с «пограничными» случаями, 
когда запрашивается больше элементов, чем есть в последовательности, или запрашивается ноль элементов:

```scala mdoc
oneToTen.take(Int.MaxValue)     
oneToTen.takeRight(Int.MaxValue)
oneToTen.take(0)                
oneToTen.takeRight(0)           
```

А это `takeWhile`, который работает с функцией-предикатом:

```scala mdoc
oneToTen.takeWhile(_ < 5)    
names.takeWhile(_.length < 5)
```

### drop, dropRight, dropWhile

`drop`, `dropRight` и `dropWhile` удаляют элементы из списка и, по сути, противоположны своим аналогам "take". 
Вот некоторые примеры:

```scala mdoc
oneToTen.drop(1)     
oneToTen.drop(5)     

oneToTen.dropRight(8)
oneToTen.dropRight(7)
```

Пограничные случаи:

```scala mdoc
oneToTen.drop(Int.MaxValue)     
oneToTen.dropRight(Int.MaxValue)
oneToTen.drop(0)                
oneToTen.dropRight(0)           
```

А это `dropWhile`, который работает с функцией-предикатом:

```scala mdoc
oneToTen.dropWhile(_ < 5)    
names.dropWhile(_ != "chris")
```

### reduce

Метод `reduce` позволяет свертывать коллекцию до одного агрегируемого значения. 
Он принимает функцию (или анонимную функцию) и последовательно применяет эту функцию к элементам в списке.

Лучший способ объяснить `reduce` — создать небольшой вспомогательный метод. 
Например, метод `add`, который складывает вместе два целых числа, 
а также предоставляет хороший вывод отладочной информации:

```scala mdoc:silent
def add(x: Int, y: Int): Int =
  val theSum = x + y
  println(s"received $x and $y, their sum is $theSum")
  theSum                          
```

Рассмотрим список:

```scala mdoc:silent
val a = List(1,2,3,4)                         
```

вот что происходит, когда в `reduce` передается метод `add`:

```scala mdoc
a.reduce(add)                        
```

Как видно из результата, функция `reduce` использует `add` для сокращения списка `a` до единственного значения, 
в данном случае — суммы всех чисел в списке.

`reduce` можно использовать с анонимными функциями:

```scala mdoc
a.reduce(_ + _)                        
```

Аналогично можно использовать другие функции, например, перемножение всех чисел:

```scala mdoc
a.reduce(_ * _)                      
```

### Дальнейшее изучение коллекций

В коллекциях Scala есть десятки дополнительных методов, которые избавят от необходимости писать еще один цикл `for`. 
Более подробную информацию о коллекциях Scala см. в разделе 
[Изменяемые и неизменяемые коллекции][collections-2.13] 
и [Архитектура коллекций Scala][architecture-of-scala-213-collections].
А также в [API][api].

> В качестве последнего примечания, при использовании Java-кода в проекте Scala, 
> коллекции Java можно преобразовать в коллекции Scala. 
> После этого, их можно использовать в выражениях `for`, 
> а также воспользоваться преимуществами методов функциональных коллекций Scala. 
> Более подробную информацию можно найти в разделе [Взаимодействие с Java](../with_java).


---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/taste-collections.html)
- [Scala3 book, Collections Methods](https://docs.scala-lang.org/scala3/book/collections-methods.html)
- [Изменяемые и неизменяемые коллекции][collections-2.13]
- [Архитектура коллекций Scala][architecture-of-scala-213-collections]
- [collections API][api]

[collections-2.13]: https://docs.scala-lang.org/ru/overviews/collections-2.13/overview.html
[architecture-of-scala-213-collections]: https://docs.scala-lang.org/overviews/core/architecture-of-scala-213-collections.html
[api]: https://scala-lang.org/api/3.x/scala/collection.html