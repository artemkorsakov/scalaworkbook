---
layout: docs
title: "Типы коллекций"
---

## {{page.title}}

В этом разделе продемонстрированы наиболее распространенные типы коллекций и их методы. 
В конце этого раздела для получения более подробной информации представлены дополнительные ссылки 
для более глубокого изучения коллекций.

### Три основные категории коллекций

Для коллекций Scala можно выделить три основные категории:
- Последовательности (**Sequences**/**Seq**) представляют собой последовательный набор элементов 
и могут быть индексированными (как массив) или линейными (как связанный список)
- Карты (**Maps**) содержат набор пар ключ/значение, например Java `Map`, Python dictionary или Ruby `Hash`
- Наборы (**Sets**) — это неупорядоченный набор уникальных элементов

Все они являются базовыми типами и имеют подтипы для конкретных целей, 
таких как параллелизм (_concurrency_), кэширование (_caching_) и потоковая передача (_streaming_). 
В дополнение к этим трем основным категориям существуют и другие полезные типы коллекций, 
включая диапазоны (_ranges_), стеки (_stacks_) и очереди (_queues_).

#### Иерархия коллекций

В качестве краткого обзора следующие три рисунка показывают иерархию классов и трейтов в коллекциях Scala.

На первом рисунке показаны типы коллекций в пакете `scala.collection`. 
Все это высокоуровневые абстрактные классы или трейты, которые обычно имеют неизменяемые и изменяемые реализации.

![General collection hierarchy](https://docs.scala-lang.org/resources/images/tour/collections-diagram-213.svg)

На этом рисунке показаны все коллекции в пакете `scala.collection.immutable`:

![Immutable collection hierarchy](https://docs.scala-lang.org/resources/images/tour/collections-immutable-diagram-213.svg)

А на этом рисунке показаны все коллекции в пакете `scala.collection.mutable`:

![Mutable collection hierarchy](https://docs.scala-lang.org/resources/images/tour/collections-mutable-diagram-213.svg)

В следующих разделах представлены некоторые из распространенных типов.


### Общие коллекции

Основные коллекции, используемые чаще всего:

| Тип коллекции | Неизменяемая | Изменяемая | Описание                                                                                                                                                           |
|---------------|--------------|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `List`        | &#10003;     |            | Линейная неизменяемая последовательность (связный список)                                                                                                          |
| `Vector`      | &#10003;     |            | Индексированная неизменяемая последовательность                                                                                                                    |
| `LazyList`    | &#10003;     |            | Ленивый неизменяемый связанный список, элементы которого вычисляются только тогда, когда они необходимы; подходит для больших или бесконечных последовательностей. |
| `ArrayBuffer` |              | &#10003;   | Подходящий тип для изменяемой индексированной последовательности                                                                                                   |
| `ListBuffer`  |              | &#10003;   | Используется, когда вам нужен изменяемый список; обычно преобразуется в `List`                                                                                     |
| `Map`         | &#10003;     | &#10003;   | Итерируемая коллекция, состоящая из пар ключей и значений                                                                                                          |
| `Set`         | &#10003;     | &#10003;   | Итерируемая коллекция без повторяющихся элементов                                                                                                                  |

Как показано, `Map` и `Set` бывают как неизменяемыми, так и изменяемыми.

Основы каждого типа демонстрируются в следующих разделах.

> В Scala буфер, такой как `ArrayBuffer` или `ListBuffer`, представляет собой последовательность, 
> которая может увеличиваться и уменьшаться.

##### Примечание о неизменяемых коллекциях

В последующих разделах всякий раз, когда используется слово _immutable_, 
можно с уверенностью сказать, что тип предназначен для использования в стиле функционального программирования (FP). 
С помощью таких типов коллекция не меняется, 
а при вызове функциональных методов возвращается новый результат - новая коллекция.


### Выбор последовательности

При выборе последовательности можно руководствоваться двумя основными вопросами:
- должна ли последовательность индексироваться (как массив), обеспечивая быстрый доступ к любому элементу, 
или она должна быть реализована как линейный связанный список?
- необходима изменяемая или неизменяемая коллекция?

Здесь показаны рекомендуемые универсальные последовательные коллекции:

| Тип \ Категория           | Неизменяемая | Изменяемая    |
|---------------------------|--------------|---------------|
| индексируемая             | `Vector`     | `ArrayBuffer` |
| линейный связанный список | `List`       | `ListBuffer`  |

Например, если нужна неизменяемая индексированная коллекция, в общем случае следует использовать `Vector`. 
И наоборот, если нужна изменяемая индексированная коллекция, используйте `ArrayBuffer`.

> `List` и `Vector` часто используются при написании кода в функциональном стиле. 
> `ArrayBuffer` обычно используется при написании кода в императивном стиле. 
> `ListBuffer` используется, когда стили смешиваются, например, при создании списка.

Следующие несколько разделов кратко демонстрируют типы `List`, `Vector` и `ArrayBuffer`.

### List

[List](https://scala-lang.org/api/3.x/scala/collection/immutable/List.html) 
представляет собой линейную неизменяемую последовательность, что означает, 
что это связанный список, который нельзя изменить. 
Каждый раз, когда в список добавляются или удаляются элементы, по сути создается новый список из существующего.

#### Создание списка

Список можно создать различными способами:

```scala mdoc
val ints = List(1, 2, 3)
val names = List("Joel", "Chris", "Ed")
val namesAgain = "Joel" :: "Chris" :: "Ed" :: Nil
```

При желании тип списка можно объявить, хотя обычно в этом нет необходимости:

```scala mdoc:reset
val ints: List[Int] = List(1, 2, 3)
val names: List[String] = List("Joel", "Chris", "Ed")
```

Одно исключение — когда в коллекции смешанные типы; в этом случае тип желательно указывать явно:

```scala mdoc
val things: List[Any] = List(1, "two", 3.0)
```

#### Добавление элементов в список

Поскольку список неизменяем, в него нельзя добавлять новые элементы. 
Вместо этого создается новый список с добавленными к существующему списку элементами. 
Например, учитывая этот список:

```scala mdoc:silent:reset
val a = List(1, 2, 3)
```

Для добавления одного элемента используется метод `::`, для добавления нескольких — `:::`, как показано здесь:

```scala mdoc
val b = 0 :: a
val c = List(-1, 0) ::: a
```

Также можно добавить элементы в конец списка, но, поскольку список является односвязным, 
следует добавлять к нему элементы только в начало; 
добавление элементов в конец списка — 
относительно медленная операция, особенно при работе с большими последовательностями.

> Если необходимо добавлять к неизменяемой последовательности элементы в начало и конец, используется `Vector`.

Поскольку `List` является связанным списком, 
крайне нежелательно пытаться получить доступ к элементам больших списков по значению их индекса. 
Например, если есть `List` с миллионом элементов, доступ к такому элементу, как `myList(999_999)`, 
займет относительно много времени, потому что этот запрос должен пройти почти через все элементы. 
Если есть большая коллекция и необходимо получать доступ к элементам по их индексу, 
вместо `List` используйте `Vector` или `ArrayBuffer`.

#### Как запомнить названия методов

В методах Scala символ `:` представляет сторону, на которой находится последовательность, 
поэтому, когда используется `+:`, известно, что список должен быть справа:

```scala mdoc
0 +: a
```

Точно так же, когда используется `:+` список должен быть слева:

```scala mdoc
a :+ 4
```

Кроме того, хорошей особенностью этих символических имен методов является то, что они непротиворечивы. 
Те же имена методов используются с другими неизменяемыми последовательностями, такими как `Seq` и `Vector`. 
Также можно использовать несимволические имена методов для добавления элементов 
в начало (`a.prepended(4)`) или конец (`a.appended(4)`).

#### Как пройтись по списку

Представим, что есть список имён:

```scala mdoc:silent
val names = List("Joel", "Chris", "Ed")
```

Напечатать каждое имя можно следующим способом:

```scala mdoc
for name <- names do println(name)
```

Преимущество использования циклов `for` с коллекциями заключается в том, что Scala стандартизирован, 
и один и тот же подход работает со всеми последовательностями, 
включая `Array`, `ArrayBuffer`, `List`, `Seq`, `Vector`, `Map`, `Set` и т. д.

#### Немного истории

Для тех, кто интересуется немного историей, 
список Scala подобен списку из [языка программирования Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)), 
который был первоначально определен в 1958 году. 
Действительно, в дополнение к созданию такого списка:

```scala mdoc:reset
val ints = List(1, 2, 3)
```

точно такой же список можно создать следующим образом:

```scala mdoc
val list = 1 :: 2 :: 3 :: Nil
```

Это работает, потому что `List` — односвязный список, оканчивающийся элементом `Nil`, 
а `::` — это метод `List`, работающий как оператор "cons" в Lisp.

#### Немного в сторону: LazyList

Коллекции Scala также включают [LazyList](https://scala-lang.org/api/3.x/scala/collection/immutable/LazyList.html), 
который представляет собой ленивый неизменяемый связанный список. 
Он называется «ленивым» — или нестрогим — потому что вычисляет свои элементы только тогда, когда они необходимы.

Пример того, что `LazyList` не вычисляет свои элементы:

```scala mdoc
val x = LazyList.range(1, Int.MaxValue)
x.take(1)    
x.take(5)    
x.map(_ + 1) 
```

Вычисления начнут выполняться только если их заставить, например, вызвав метод `foreach`:

```scala mdoc
x.take(1).foreach(println)
```

Для получения дополнительной информации об использовании, преимуществах и недостатках 
строгих и нестрогих (ленивых) коллекций см. 
обсуждение "строгих" и "нестрогих" коллекций на странице 
["Архитектура Scala 2.13’s Collections"](https://docs.scala-lang.org/overviews/core/architecture-of-scala-213-collections.html).

### Vector

[Vector](https://scala-lang.org/api/3.x/scala/collection/immutable/Vector.html) - 
это индексируемая неизменяемая последовательность. 
"Индексируемая" часть описания означает, что она обеспечивает произвольный доступ 
и обновление за практически постоянное время, 
поэтому можно быстро получить доступ к элементам `Vector` по значению их индекса, 
например, получить доступ к `listOfPeople(123_456_789)`.

В общем, за исключением той разницы, что (а) `Vector` индексируется, а `List` - нет, 
и (б) `List` имеет метод `::`, эти два типа работают одинаково.

Вот несколько способов создания `Vector`:

```scala mdoc:reset
val nums = Vector(1, 2, 3, 4, 5)
val strings = Vector("one", "two")
case class Person(name: String)
val people = Vector(
  Person("Bert"),
  Person("Ernie"),
  Person("Grover")
)
```

Поскольку `Vector` неизменяем, в него нельзя добавить новые элементы. 
Вместо этого создается новая последовательность, добавляя в начало или в конец элементы к существующему `Vector`.

Например, так элементы добавляются в конец:

```scala mdoc
val a = Vector(1,2,3)
val b = a :+ 4
val c = a ++ Vector(4, 5)
```

А так - в начало `Vector`-а:

```scala mdoc:reset
val a = Vector(1,2,3)
val b = 0 +: a
val c = Vector(-1, 0) ++: a
```

В дополнение к быстрому произвольному доступу и обновлениям, 
`Vector` обеспечивает быстрое добавление в начало и конец.

> Подробную информацию о производительности `Vector` и других коллекций см. в 
> [характеристиках производительности коллекций](https://docs.scala-lang.org/overviews/collections-2.13/performance-characteristics.html).

Наконец, `Vector` в цикле `for` используется точно так же, как `List`, `ArrayBuffer` или любая другая последовательность:

```scala mdoc
val names = Vector("Joel", "Chris", "Ed")
for name <- names do println(s"My name is $name")
```

### ArrayBuffer

`ArrayBuffer` используется тогда, когда нужна изменяемая индексированная последовательность общего назначения. 
Он изменчив, поэтому можно изменять его элементы, а также изменять размер коллекции. 
Поскольку `ArrayBuffer` индексирован, произвольный доступ к элементам выполняется быстро.

#### Создание ArrayBuffer

Чтобы использовать `ArrayBuffer`, в отличие от предыдущих рассмотренных классов, его нужно вначале импортировать:

```scala mdoc:silent
import scala.collection.mutable.ArrayBuffer
```

Если необходимо начать с пустого `ArrayBuffer`, просто укажите его тип:

```scala mdoc:silent
var strings = ArrayBuffer[String]()
var ints = ArrayBuffer[Int]()
var people = ArrayBuffer[Person]()
```

Если известен примерный размер `ArrayBuffer`, его можно задать:

```scala mdoc:silent
val buf = new ArrayBuffer[Int](100_000)
```

Чтобы создать новый `ArrayBuffer` с начальными элементами, достаточно просто указать его начальные элементы, 
как для `List` или `Vector`:

```scala
val nums = ArrayBuffer(1, 2, 3)
val people = ArrayBuffer(
  Person("Bert"),
  Person("Ernie"),
  Person("Grover")
)
```

#### Добавление элементов в ArrayBuffer

Новые элементы добавляются в `ArrayBuffer` с помощью методов `+=` и `++=`. 
Также можно использовать текстовый аналог: `append`, `appendAll`, `insert`, `insertAll`, `prepend` и `prependAll`. 
Вот несколько примеров с `+=` и `++=`:

```scala mdoc:reset
val nums = ArrayBuffer(1, 2, 3)
nums += 4
nums ++= List(5, 6)
```

#### Удаление элементов из ArrayBuffer

`ArrayBuffer` является изменяемым, поэтому у него есть такие методы, как `-=`, `--=`, `clear`, `remove` и другие. 
Примеры с `-=` и `--=`:

```scala mdoc
val a = ArrayBuffer.range('a', 'h')
a -= 'a'
a --= Seq('b', 'c')
a --= Set('d', 'e')
```

#### Обновление элементов в ArrayBuffer

Элементы в `ArrayBuffer` можно обновлять, либо переназначать:

```scala mdoc
val a = ArrayBuffer.range(1,5)
a(2) = 50
a.update(0, 10)
```

### Maps

`Map` — это итерируемая коллекция, состоящая из пар ключей и значений. 
В Scala есть как изменяемые, так и неизменяемые типы `Map`. 
В этом разделе показано, как использовать неизменяемый `Map`.

#### Создание Map

Неизменяемая `Map` создается следующим образом:

```scala mdoc:silent
val states = Map(
  "AK" -> "Alaska",
  "AL" -> "Alabama",
  "AZ" -> "Arizona"
)
```

Перемещаться по элементам `Map` в цикле `for` можно следующим образом:

```scala mdoc
for (k, v) <- states do println(s"key: $k, value: $v")
```

#### Доступ к элементам Map

Доступ к элементам `Map` осуществляется через указание в скобках значения ключа:

```scala mdoc
val ak = states("AK")
val al = states("AL")
```

На практике также используются такие методы, как `keys`, `keySet`, `keysIterator`, циклы `for` 
и функции высшего порядка, такие как `map`, для работы с ключами и значениями `Map`.

#### Добавление элемента в Map

При добавлении элементов в неизменяемую карту с помощью `+` и `++`, создается новая карта:

```scala mdoc:reset
val a = Map(1 -> "one")
val b = a + (2 -> "two")
val c = b ++ Seq(
  3 -> "three",
  4 -> "four"
)
```

#### Удаление элементов из Map

Элементы удаляются с помощью методов `-` или `--`. 
В случае неизменяемой `Map` создается новый экземпляр, который нужно присвоить новой переменной:

```scala mdoc:reset
val a = Map(
  1 -> "one",
  2 -> "two",
  3 -> "three",
  4 -> "four"
)
val b = a - 4    
val c = a - 4 - 3
```

#### Обновление элементов в Map

Чтобы обновить элементы на неизменяемой `Map`, используется метод `update` (или оператор +). 
Результат присваивается новой переменной:

```scala mdoc:reset
val a = Map(
  1 -> "one",
  2 -> "two",
  3 -> "three"
)
val b = a.updated(3, "THREE!")
val c = a + (2 -> "TWO...")
```

#### Перебор элементов в Map

Элементы в `Map` можно перебрать с помощью цикла `for`, как и для остальных коллекций:

```scala mdoc:reset
val states = Map(
  "AK" -> "Alaska",
  "AL" -> "Alabama",
  "AZ" -> "Arizona"
)
for (k, v) <- states do println(s"key: $k, value: $v")
```

Существует много способов работы с ключами и значениями на `Map`. 
Общие методы `Map` включают `foreach`, `map`, `keys` и `values`.

В Scala есть много других специализированных типов `Map`, 
включая `CollisionProofHashMap`, `HashMap`, `LinkedHashMap`, `ListMap`, `SortedMap`, `TreeMap`, `WeakHashMap` и другие.

### Работа с Set

???



### Tuple (кортежи)

Scala `tuple` - это тип, который позволяет помещать коллекцию разных типов в один и тот же контейнер.
Например, учитывая `case class Person`:

```scala mdoc:silent
case class Person(name: String)
```

можно построить кортеж, содержащий `Int`, `String` и `Person`:

```scala mdoc
val t = (11, "eleven", Person("Eleven"))
```

Доступ к значениям кортежа осуществляется через индекс (начиная с 0):

```scala mdoc
t(0)
t(1)
t(2)
```

либо через методы вида `._i`, где `i` - порядковый номер (начиная с 1, в отличие от индекса)

```scala mdoc
t._1
t._2
t._3
```

Также можно использовать `extractor` для присвоения переменным значений полей кортежа:

```scala mdoc
val (num, str, person) = t
```

Кортежи хороши для случаев, когда необходимо поместить коллекцию разнородных типов 
в небольшую структуру, похожую на коллекцию.


---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/taste-collections.html)
- [Scala3 book, Collections Types](https://docs.scala-lang.org/scala3/book/collections-classes.html)
