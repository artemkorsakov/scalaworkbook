---
layout: docs
title: "Типы коллекций"
---

## {{page.title}}

В этом разделе продемонстрированы наиболее распространенные типы коллекций и их методы. 
В конце этого раздела для получения более подробной информации представлены дополнительные ссылки 
для более глубокого изучения коллекций.

### Три основные категории коллекций

Для коллекций Scala можно выделить три основные категории:
- Последовательности (**Sequences**/**Seq**) представляют собой последовательный набор элементов 
и могут быть индексированными (как массив) или линейными (как связанный список)
- Карты (**Maps**) содержат набор пар ключ/значение, например Java `Map`, Python dictionary или Ruby `Hash`
- Наборы (**Sets**) — это неупорядоченный набор уникальных элементов

Все они являются базовыми типами и имеют подтипы для конкретных целей, 
таких как параллелизм (_concurrency_), кэширование (_caching_) и потоковая передача (_streaming_). 
В дополнение к этим трем основным категориям существуют и другие полезные типы коллекций, 
включая диапазоны (_ranges_), стеки (_stacks_) и очереди (_queues_).

#### Иерархия коллекций

В качестве краткого обзора следующие три рисунка показывают иерархию классов и трейтов в коллекциях Scala.

На первом рисунке показаны типы коллекций в пакете `scala.collection`. 
Все это высокоуровневые абстрактные классы или трейты, которые обычно имеют неизменяемые и изменяемые реализации.

![General collection hierarchy](https://docs.scala-lang.org/resources/images/tour/collections-diagram-213.svg)

На этом рисунке показаны все коллекции в пакете `scala.collection.immutable`:

![Immutable collection hierarchy](https://docs.scala-lang.org/resources/images/tour/collections-immutable-diagram-213.svg)

А на этом рисунке показаны все коллекции в пакете `scala.collection.mutable`:

![Mutable collection hierarchy](https://docs.scala-lang.org/resources/images/tour/collections-mutable-diagram-213.svg)

В следующих разделах представлены некоторые из распространенных типов.


### Общие коллекции

Основные коллекции, используемые чаще всего:

| Тип коллекции | Неизменяемая | Изменяемая | Описание                                                                                                                                                           |
|---------------|--------------|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `List`        | &#10003;     |            | Линейная неизменяемая последовательность (связный список)                                                                                                          |
| `Vector`      | &#10003;     |            | Индексированная неизменяемая последовательность                                                                                                                    |
| `LazyList`    | &#10003;     |            | Ленивый неизменяемый связанный список, элементы которого вычисляются только тогда, когда они необходимы; подходит для больших или бесконечных последовательностей. |
| `ArrayBuffer` |              | &#10003;   | Подходящий тип для изменяемой индексированной последовательности                                                                                                   |
| `ListBuffer`  |              | &#10003;   | Используется, когда вам нужен изменяемый список; обычно преобразуется в `List`                                                                                     |
| `Map`         | &#10003;     | &#10003;   | Итерируемая коллекция, состоящая из пар ключей и значений                                                                                                          |
| `Set`         | &#10003;     | &#10003;   | Итерируемая коллекция без повторяющихся элементов                                                                                                                  |

Как показано, `Map` и `Set` бывают как неизменяемыми, так и изменяемыми.

Основы каждого типа демонстрируются в следующих разделах.

> В Scala буфер, такой как `ArrayBuffer` или `ListBuffer`, представляет собой последовательность, 
> которая может увеличиваться и уменьшаться.

##### Примечание о неизменяемых коллекциях

В последующих разделах всякий раз, когда используется слово _immutable_, 
можно с уверенностью сказать, что тип предназначен для использования в стиле функционального программирования (FP). 
С помощью таких типов коллекция не меняется, 
а при вызове функциональных методов возвращается новый результат - новая коллекция.


### Выбор последовательности

При выборе последовательности можно руководствоваться двумя основными вопросами:
- должна ли последовательность индексироваться (как массив), обеспечивая быстрый доступ к любому элементу, 
или она должна быть реализована как линейный связанный список?
- необходима изменяемая или неизменяемая коллекция?

Здесь показаны рекомендуемые универсальные последовательные коллекции:

| Тип \ Категория           | Неизменяемая | Изменяемая    |
|---------------------------|--------------|---------------|
| индексируемая             | `Vector`     | `ArrayBuffer` |
| линейный связанный список | `List`       | `ListBuffer`  |

Например, если нужна неизменяемая индексированная коллекция, в общем случае следует использовать `Vector`. 
И наоборот, если нужна изменяемая индексированная коллекция, используйте `ArrayBuffer`.

> `List` и `Vector` часто используются при написании кода в функциональном стиле. 
> `ArrayBuffer` обычно используется при написании кода в императивном стиле. 
> `ListBuffer` используется, когда стили смешиваются, например, при создании списка.

Следующие несколько разделов кратко демонстрируют типы `List`, `Vector` и `ArrayBuffer`.

### List

[List](https://scala-lang.org/api/3.x/scala/collection/immutable/List.html) 
представляет собой линейную неизменяемую последовательность, что означает, 
что это связанный список, который нельзя изменить. 
Каждый раз, когда в список добавляются или удаляются элементы, по сути создается новый список из существующего.

#### Создание списка

Список можно создать различными способами:

```scala mdoc
val ints = List(1, 2, 3)
val names = List("Joel", "Chris", "Ed")
val namesAgain = "Joel" :: "Chris" :: "Ed" :: Nil
```

При желании тип списка можно объявить, хотя обычно в этом нет необходимости:

```scala mdoc:reset
val ints: List[Int] = List(1, 2, 3)
val names: List[String] = List("Joel", "Chris", "Ed")
```

Одно исключение — когда в коллекции смешанные типы; в этом случае тип желательно указывать явно:

```scala mdoc
val things: List[Any] = List(1, "two", 3.0)
```

#### Добавление элементов в список

Поскольку список неизменяем, в него нельзя добавлять новые элементы. 
Вместо этого создается новый список с добавленными к существующему списку элементами. 
Например, учитывая этот список:

```scala mdoc:silent:reset
val a = List(1, 2, 3)
```

Для добавления одного элемента используется метод `::`, для добавления нескольких — `:::`, как показано здесь:

```scala mdoc
val b = 0 :: a
val c = List(-1, 0) ::: a
```

Также можно добавить элементы в конец списка, но, поскольку список является односвязным, 
следует добавлять к нему элементы только в начало; 
добавление элементов в конец списка — 
относительно медленная операция, особенно при работе с большими последовательностями.

> Если необходимо добавлять к неизменяемой последовательности элементы в начало и конец, используется `Vector`.

Поскольку `List` является связанным списком, 
крайне нежелательно пытаться получить доступ к элементам больших списков по значению их индекса. 
Например, если есть `List` с миллионом элементов, доступ к такому элементу, как `myList(999_999)`, 
займет относительно много времени, потому что этот запрос должен пройти почти через все элементы. 
Если есть большая коллекция и необходимо получать доступ к элементам по их индексу, 
вместо `List` используйте `Vector` или `ArrayBuffer`.

#### Как запомнить названия методов

В методах Scala символ `:` представляет сторону, на которой находится последовательность, 
поэтому, когда используется `+:`, известно, что список должен быть справа:

```scala mdoc
0 +: a
```

Точно так же, когда используется `:+` список должен быть слева:

```scala mdoc
a :+ 4
```

Кроме того, хорошей особенностью этих символических имен методов является то, что они непротиворечивы. 
Те же имена методов используются с другими неизменяемыми последовательностями, такими как `Seq` и `Vector`. 
Также можно использовать несимволические имена методов для добавления элементов 
в начало (`a.prepended(4)`) или конец (`a.appended(4)`).

#### Как пройтись по списку

Представим, что есть список имён:

```scala mdoc:silent
val names = List("Joel", "Chris", "Ed")
```

Напечатать каждое имя можно следующим способом:

```scala mdoc
for name <- names do println(name)
```

Преимущество использования циклов `for` с коллекциями заключается в том, что Scala стандартизирован, 
и один и тот же подход работает со всеми последовательностями, 
включая `Array`, `ArrayBuffer`, `List`, `Seq`, `Vector`, `Map`, `Set` и т. д.

#### Немного истории

Для тех, кто интересуется немного историей, 
список Scala подобен списку из [языка программирования Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)), 
который был первоначально определен в 1958 году. 
Действительно, в дополнение к созданию такого списка:

```scala mdoc:reset
val ints = List(1, 2, 3)
```

точно такой же список можно создать следующим образом:

```scala mdoc
val list = 1 :: 2 :: 3 :: Nil
```

Это работает, потому что `List` — это односвязный список, оканчивающийся элементом `Nil`, 
а `::` — это метод `List`, работающий как оператор "cons" в Lisp.




### Кортежи

Scala `tuple` - это тип, который позволяет помещать коллекцию разных типов в один и тот же контейнер.
Например, учитывая `case class Person`:

```scala mdoc:silent
case class Person(name: String)
```

можно построить кортеж, содержащий `Int`, `String` и `Person`:

```scala mdoc
val t = (11, "eleven", Person("Eleven"))
```

Доступ к значениям кортежа осуществляется через индекс (начиная с 0):

```scala mdoc
t(0)
t(1)
t(2)
```

либо через методы вида `._i`, где `i` - порядковый номер (начиная с 1, в отличие от индекса)

```scala mdoc
t._1
t._2
t._3
```

Также можно использовать `extractor` для присвоения переменным значений полей кортежа:

```scala mdoc
val (num, str, person) = t
```

Кортежи хороши для случаев, когда необходимо поместить коллекцию разнородных типов в небольшую структуру, похожую на коллекцию.

### Неизменяемые коллекции

В процессе работы с неизменяемыми коллекциями, такими как `List`, `Vector` и неизменяемыми классами `Map` и `Set`,
важно помнить, что их функции не изменяют коллекцию, для которой они вызываются;
вместо этого они возвращают новую коллекцию с обновленными данными.
В результате принято связывать их вместе в "fluent" стиле для решения проблем.

В этом примере показано, как дважды отфильтровать коллекцию, а затем умножить каждый элемент в оставшейся коллекции:

```scala mdoc:reset
val nums = (1 to 10).toList
val x = nums.filter(_ > 3)
  .filter(_ < 7)
  .map(_ * 10)  
```

> **P.S.** Пример призван показать только то, как принято последовательно вызывать функции на неизменяемых коллекциях.
Его недостаток в том, что обход коллекции происходит целых три раза.
Чтобы получить аналогичный результат за единичный обход коллекции, достаточно:
`nums.withFilter(n => 3 < n && n < 7).map(_ * 10)`



---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/taste-collections.html)
- [Scala3 book, Collections Types](https://docs.scala-lang.org/scala3/book/collections-classes.html)
