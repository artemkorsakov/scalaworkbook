---
layout: docs
title: "Функции первого класса"
---

## [Функции первого класса](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)

Scala обладает большинством возможностей, ожидаемых от функционального языка программирования, включая:
- Лямбды (анонимные функции)
- Функции высшего порядка (HOFs)
- Неизменяемые коллекции в стандартной библиотеке

Лямбды, также известные как анонимные функции, играют важную роль в том, чтобы код был кратким, но читабельным.

Эти два примера эквивалентны и показывают, как умножить каждое число в списке на 2, передав лямбду в метод `map`:

```scala mdoc
List(1, 2, 3).map(i => i * 2)
List(1, 2, 3).map(_ * 2)
```

Метод `map` класса `List` является типичным примером функции более высокого порядка - функции, которая принимает функцию в качестве параметра.

Эти примеры также эквивалентны следующему коду, который использует метод `double` вместо лямбда:

```scala mdoc
def double(i: Int): Int = i * 2
List(1, 2, 3).map(i => double(i))
List(1, 2, 3).map(double)   
```

## Неизменяемые коллекции

В процессе работы с неизменяемыми коллекциями, такими как `List`, `Vector` и неизменяемыми классами `Map` и `Set`, 
важно помнить, что их функции не изменяют коллекцию, для которой они вызываются; 
вместо этого они возвращают новую коллекцию с обновленными данными. 
В результате принято связывать их вместе в "fluent" стиле для решения проблем.

В этом примере показано, как дважды отфильтровать коллекцию, а затем умножить каждый элемент в оставшейся коллекции:

```scala mdoc
val nums = (1 to 10).toList
val x = nums.filter(_ > 3)
  .filter(_ < 7)
  .map(_ * 10)  
```

> **P.S.** Пример призван показать только то, как принято последовательно вызывать функции на неизменяемых коллекциях.
Он плох тем, что в нём обход коллекции происходит целых три раза. 
Чтобы получить аналогичный результат и обойти коллекцию только 1 раз, достаточно: 
`nums.withFilter(n => 3 < n && n < 7).map(_ * 10)`
