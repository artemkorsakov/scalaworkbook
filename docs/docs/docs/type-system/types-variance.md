---
layout: docs
title: "Ковариантность типов"
---

## {{page.title}}

Вариантность параметра типа управляет подтипом параметризованных типов (таких, как классы или trait-ы).

Чтобы объяснить вариантность, давайте предположим следующие определения типов:

```scala
trait Item { def productNumber: String }
trait Buyable extends Item { def price: Int }
trait Book extends Buyable { def isbn: String }
```

Предположим также следующие параметризованные типы:

```scala
// пример инвариантного типа
trait Pipeline[T]:
  def process(t: T): T

// пример ковариантного типа
trait Producer[+T]:
  def make: T

// пример контрвариантного типа
trait Consumer[-T]:
  def take(t: T): Unit
```

В целом существует три режима вариантности (**variance**):
- инвариант (**invariant**) — значение по умолчанию, написанное как `Pipeline[T]`
- ковариантный (**covariant**) — помечен знаком `+`, например `Producer[+T]`
- контравариантный (**contravariant**) — помечен знаком `-`, как в `Consumer[-T]`

Подробнее рассмотрим, что означает и как используется эта аннотация.

#### Инвариантные типы

По умолчанию такие типы, как `Pipeline`, инвариантны в своем аргументе типа (в данном случае `T`). 
Это означает, что такие типы, как `Pipeline[Item]`, `Pipeline[Buyable]` и `Pipeline[Book]`, 
не являются подтипами друг друга.

И это правильно! 
Предположим, что следующий метод использует два значения типа `Pipeline[Buyable]` 
и передает свой аргумент `b` одному из них в зависимости от цены:

```scala
def oneOf(
  p1: Pipeline[Buyable],
  p2: Pipeline[Buyable],
  b: Buyable
): Buyable =
  val b1 = p1.process(b)
  val b2 = p2.process(b)
  if b1.price < b2.price then b1 else b2
```

Теперь вспомним, что у нас есть следующие отношения подтипов между типами: `Book <: Buyable <: Item`.

Мы не можем передать `Pipeline[Book]` методу `oneOf`, 
потому что в реализации `oneOf` мы вызываем `p1` и `p2` со значением типа `Buyable`. 
`Pipeline[Book]` ожидает `Book`, что потенциально может вызвать _runtime error_.

Мы не можем передать `Pipeline[Item]`, потому что вызов `process` обещает вернуть `Item`; 
однако мы должны вернуть `Buyable`.

##### Почему Инвариант?

На самом деле тип `Pipeline` должен быть инвариантным, 
так как он использует свой параметр типа `T` и в качестве аргумента, и в качестве типа возвращаемого значения. 
По той же причине некоторые типы в библиотеке коллекций Scala, такие как `Array` или `Set`, 
также являются инвариантными.

#### Ковариантные типы

???





---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/types-variance.html)
