---
layout: docs
title: "Зависимые типы функций"
---

## {{page.title}}

Зависимый тип функции (_dependent function type_) описывает типы функций, 
где тип результата может зависеть от значений параметров функции. 
Концепция зависимых типов и типов зависимых функций является более продвинутой, 
и обычно с ней сталкиваются только при разработке собственных библиотек или использовании расширенных библиотек.

### Зависимые типы методов

Рассмотрим следующий пример гетерогенной базы данных, в которой могут храниться значения разных типов. 
Ключ содержит информацию о типе соответствующего значения:

```scala
trait Key { type Value }

trait DB {
  def get(k: Key): Option[k.Value] // зависимый метод
}
```

Получив ключ, метод `get` предоставляет доступ к карте и потенциально возвращает сохраненное значение типа `k.Value`. 
Мы можем прочитать этот _path-dependent type_ как: 
"в зависимости от конкретного типа аргумента `k` возвращается соответствующее значение".

Например, у нас могут быть следующие ключи:

```scala
object Name extends Key { type Value = String }
object Age extends Key { type Value = Int }
```

Вызовы метода `get` теперь будут возвращать такие типы:

```scala
val db: DB = ...
val res1: Option[String] = db.get(Name)
val res2: Option[Int] = db.get(Age)
```

Вызов метода `db.get(Name)` возвращает значение типа `Option[String]`, 
а вызов `db.get(Age)` возвращает значение типа `Option[Int]`. 
Тип возвращаемого значения зависит от конкретного типа аргумента, переданного для `get` — 
отсюда и название _dependent type_.

### Зависимые типы функций

Как видно выше, в Scala 2 уже была поддержка зависимых типов методов. 
Однако создание значений типа `DB` довольно громоздко:

```scala
// a user of a DB
def user(db: DB): Unit =
  db.get(Name) ... db.get(Age)

// creating an instance of the DB and passing it to `user`
user(new DB {
  def get(k: Key): Option[k.Value] = ... // implementation of DB
})
```

Необходимо вручную создать анонимный внутренний класс `DB`, реализующий метод `get`. 
Для кода, основанного на создании множества различных экземпляров `DB`, это очень утомительно.

`DB` trait имеет только один абстрактный метод `get`. 
Было бы неплохо использовать лямбда-синтаксис в этом месте?

```scala
user { k =>
  ... // implementation of DB
}
```

На самом деле, в Scala 3 теперь это возможно! Можно определить `DB` как зависимый тип функции:

```scala
type DB = (k: Key) => Option[k.Value]
//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//        A dependent function type
```

Учитывая это определение `DB`, можно использовать приведенный выше вызов `user`.

Подробнее о зависимых типах функций можно прочитать в 
[справочной документации](https://docs.scala-lang.org/scala3/reference/new-types/dependent-function-types.html).

### Практический пример: числовые выражения

???


---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/types-dependent-function.html)
