---
layout: docs
title: "Функции высшего порядка"
---

## {{page.title}}

Функция высшего порядка (HOF - higher-order function) часто определяется как функция, которая 
(а) принимает другие функции в качестве входных параметров или 
(б) возвращает функцию в качестве результата. 
В Scala HOF возможны, потому что функции являются [объектами первого класса](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0).

> В качестве важного примечания: 
> хотя в этом документе мы используем общепринятый термин "функция высшего порядка", 
> в Scala эта фраза применима как к методам, так и к функциям. 
> Благодаря технологии [Eta Expansion](eta) их, как правило, можно использовать в одних и тех же местах.

### От потребителя к разработчику

В примерах, приведенных ранее в документации, было видно, как пользоваться методами, 
которые принимают другие функции в качестве входных параметров, например, `map` и `filter`. 

В следующих разделах будет показано, как создавать HOF, в том числе:
- как писать методы, принимающие функции в качестве входных параметров
- как возвращать функции из методов

В процессе будет видно:
- синтаксис, который используется для определения входных параметров функции
- как вызвать функцию, если есть на нее ссылка

В качестве полезного побочного эффекта, как только синтаксис станет привычным, 
его можно начать использовать для определения параметров функций, анонимных функций и функциональных переменных, 
а также станет легче читать Scaladoc для функций высокого порядка.

### Понимание Scaladoc метода filter

Чтобы понять, как работают функции высшего порядка, полезно рассмотреть пример. 
Например, определим, какой тип функций принимает `filter`, взглянув на 
[его Scaladoc](https://scala-lang.org/api/3.x/scala/collection/immutable/List.html#filter-5a1). 
Вот определение `filter` в классе `List[A]`:

```scala
def filter(p: (A) => Boolean): List[A]
```

Это определение указывает на то, что `filter` - метод, который принимает параметр функции с именем `p`. 
По соглашению, `p` обозначает _предикат_, который представляет собой просто функцию, возвращающую `Boolean`. 
Таким образом, `filter` принимает предикат `p` в качестве входного параметра и возвращает `List[A]`, 
где `A` - тип, содержащийся в списке; если вы вызываете `filter` для `List[Int]`, то `A` - это тип `Int`.

На данный момент, если не учитывать назначение метода `filter`, все, что известно, 
это то, что его алгоритм каким-то образом использует предикат `p` для создания и возврата `List[A]`.

Если посмотреть конкретно на параметр функции `p`: `p: (A) => Boolean`, то эта часть описания `filter` означает, 
что любая передаваемая функция должна принимать тип `A` в качестве входного параметра и возвращать логическое значение. 
Итак, если список представляет собой список `List[Int]`, 
то можно заменить универсальный тип `A` на `Int` и прочитать эту подпись следующим образом: `p: (Int) => Boolean`.

Поскольку `isEven` имеет такой же тип — преобразует входное значение `Int` в результирующее `Boolean` — 
его можно использовать с `filter`.

### Написание методов, которые принимают параметры функции



---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/fun-hofs.html)
