---
layout: docs
title: "Распределение по пакетам и импорт"
---

## {{page.title}}

Scala использует `packages` для создания пространств имен, которые позволяют модульно разбивать программы. 
Scala поддерживает стиль именования пакетов, используемый в Java, 
а также нотацию пространства имен "фигурные скобки", используемую такими языками, как C++ и C#.

Подход Scala к импорту похож на Java, но более гибкий. С помощью Scala можно:
- импортировать пакеты, классы, объекты, `trait`-ы и методы
- размещать операторы импорта в любом месте
- скрывать и переименовывать участников при импорте

Эти особенности демонстрируются в следующих примерах.

### Создание пакета

Пакеты создаются путем объявления одного или нескольких имен пакетов в начале файла Scala. 
Например, если ваше доменное имя `acme.com` и вы работаете с пакетом `model` приложения с именем `myapp`, 
объявление пакета выглядит следующим образом:

```scala
package com.acme.myapp.model

class Person ...
```

По соглашению все имена пакетов должны быть строчными, 
а формальным соглашением об именах является `<top-level-domain>.<domain-name>.<project-name>.<module-name>`.

Хотя это и не обязательно, имена пакетов обычно совпадают с именами иерархии каталогов.
Поэтому, если следовать этому соглашению, класс `Person` в этом проекте будет найден 
в файле _MyApp/src/main/scala/com/acme/myapp/model/Person.scala_.

#### Использование нескольких пакетов в одном файле

Показанный выше синтаксис применяется ко всему исходному файлу: 
все определения в файле `Person.scala` принадлежат пакету `com.acme.myapp.model` 
в соответствии с `package` в начале файла.

В качестве альтернативы можно написать `package`, которые применяются только к содержащимся в них определениям:

```scala
package users:

  package administrators:  // полное имя пакета - users.administrators
    class AdminUser        // полное имя файла  - users.administrators.AdminUser

  package normalusers:     // полное имя пакета - users.normalusers
    class NormalUser       // полное имя файла  - users.normalusers.NormalUser
```

Обратите внимание, что за именами пакетов следует двоеточие, а определения внутри пакета имеют отступ.

Преимущество этого подхода заключается в том, что он допускает вложение пакетов 
и обеспечивает более очевидный контроль над областью действия и инкапсуляцией, особенно в пределах одного файла.

### Операторы импорта, часть 1

Операторы импорта используются для доступа к сущностям в других пакетах. 
Операторы импорта делятся на две основные категории:
- импорт классов, `trait`-ов, объектов, функций и методов
- импорт `given` предложений

Первая категория операторов импорта аналогична тому, что использует Java, 
с немного другим синтаксисом, обеспечивающим большую гибкость. 
Пример:

```scala
import users.*                            // импортируется все из пакета `users`
import users.User                         // импортируется только класс `User`
import users.{User, UserPreferences}      // импортируются только два члена пакета
import users.{UserPreferences as UPrefs}  // переименование импортированного члена
```

Эти примеры предназначены для того, чтобы дать представление о том, как работает первая категория операторов `import`. 
Более подробно они объясняются в следующих подразделах.

Операторы импорта также используются для импорта `given` экземпляров в область видимости. 
Они обсуждаются в конце этой главы.

> `import` не требуется для доступа к членам одного и того же пакета.

#### Импорт одного или нескольких членов

В Scala импортировать один элемент из пакета можно следующим образом:

```scala
import scala.concurrent.Future
```

несколько:

```scala
import scala.concurrent.Future
import scala.concurrent.Promise
import scala.concurrent.blocking
```

При импорте нескольких элементов можно импортировать их более лаконично:

```scala
import scala.concurrent.{Future, Promise, blocking}
```

Если необходимо импортировать все из пакета `scala.concurrent`, используется такой синтаксис:

```scala
import scala.concurrent.*
```

#### Переименование элементов при импорте

Иногда необходимо переименовать объекты при их импорте, чтобы избежать конфликтов имен. 
Например, если нужно использовать Scala класс `List` вместе с `java.util.List`, 
то можно переименовать `java.util.List` при импорте:

```scala
import java.util.{List as JavaList}
```

Теперь имя `JavaList` можно использовать для ссылки на класс `java.util.List` 
и использовать `List` для ссылки на Scala класс `List`.

Также можно переименовывать несколько элементов одновременно, используя следующий синтаксис:

```scala
import java.util.{Date as JDate, HashMap as JHashMap, *}
```

В этой строке кода говорится следующее: 
"Переименуйте классы `Date` и `HashMap`, как показано, 
и импортируйте все остальное из пакета `java.util`, не переименовывая".

#### Скрытие членов при импорте

При импорте часть объектов можно скрывать. 
Следующий оператор импорта скрывает класс `java.util.Random`, 
в то время как все остальное в пакете `java.util` импортируется:

```scala
import java.util.{Random as _, *}
```

Если попытаться получить доступ к классу `Random`, то выдается ошибка, 
но есть доступ ко всем остальным членам пакета `java.util`:

```scala
val r = new Random   // не скомпилируется
new ArrayList        // доступ есть
```

##### Скрытие нескольких элементов

Чтобы скрыть в `import` несколько элементов, их можно перечислить перед использованием `*`:

```scala mdoc:silent
import java.util.{List as _, Map as _, Set as _, *}
```

Перечисленные классы скрыты, но можно использовать все остальное в `java.util`:

```scala mdoc
val arr = new ArrayList[String]
```

Поскольку эти Java классы скрыты, можно использовать классы Scala `List`, `Set` и `Map` без конфликта имен:

```scala mdoc
val a = List(1, 2, 3)
val b = Set(1, 2, 3)
val c = Map(1 -> 1, 2 -> 2)
```

#### Импорт можно использовать в любом месте

В Scala операторы импорта могут быть объявлены где угодно. 
Их можно использовать в верхней части файла исходного кода:

```scala
package foo

import scala.util.Random

class ClassA:
  def printRandom:
    val r = new Random   // класс Random здесь доступен
    // ещё код...
```

Также операторы импорта можно использовать ближе к тому месту, где они необходимы:

```scala
package foo

class ClassA:
  import scala.util.Random   // внутри ClassA
  def printRandom {
    val r = new Random
    // ещё код...

class ClassB:
  // класс Random здесь невидим
  val r = new Random   // этот код не скомпилится
```

#### "Статический" импорт

Если необходимо импортировать элементы способом, аналогичным подходу «статического импорта» в Java, 
то есть для того, чтобы напрямую обращаться к членам класса, не добавляя к ним префикс с именем класса, 
используется следующий подход.

Синтаксис для импорта всех статических членов Java класса `Math`:

```scala
import java.lang.Math.*
```

Теперь можно получить доступ к статическим методам класса `Math`, таким как `sin` и `cos`, 
без необходимости предварять их именем класса:

```scala mdoc
import java.lang.Math.*
val a = sin(0) 
val b = cos(PI)
```




---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/packaging-imports.html)
