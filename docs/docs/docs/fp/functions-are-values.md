---
layout: docsplus
title: "Функции - это значения"
section: scala
prev: fp/pure-functions
next: fp/functional-error-handling
---

## {{page.title}}

Хотя каждый когда-либо созданный язык программирования, вероятно, позволяет писать чистые функции, 
вторая важная особенность ФП на Scala заключается в том, что функции можно создавать как значения,
точно так же, как создаются значения `String` и `Int`.

Эта особенность содержит много преимуществ, наиболее распространенными из которых являются:
- можно определять методы, принимающие в качестве параметров функции 
- можно передавать функции в качестве параметров в методы

Это было видно во многих местах предыдущих глав, когда демонстрировались такие методы, как `map` и `filter`:

```scala mdoc
val nums = (1 to 10).toList
val doubles = nums.map(_ * 2)         
val lessThanFive = nums.filter(_ < 5) 
```

В этих примерах анонимные функции передаются в `map` и `filter`.

> Анонимные функции также известны как лямбды.

Помимо передачи анонимных функций в `filter` и `map`, в них также можно передать методы:

```scala mdoc:reset:invisible
val nums = (1 to 10).toList
```
```scala mdoc:silent
def double(i: Int): Int = i * 2
def underFive(i: Int): Boolean = i < 5
```
```scala mdoc
val doubles = nums.filter(underFive).map(double) 
```

Эта возможность обращаться с методами и функциями как со значениями — 
мощное свойство, предоставляемое языками функционального программирования.

> Технически функция, которая принимает другую функцию в качестве входного параметра, 
> известна как функция высшего порядка. 


### Функции, анонимные функции и методы

В примерах выше анонимная функция это:

```scala
_ * 2
```

Как было показано в обсуждении [функций высшего порядка](../functions/hofs), `_ * 2` - сокращенная версия синтаксиса:

```scala
(i: Int) => i * 2
```

Такие функции называются "анонимными", потому что им не присваивается определенное имя. 
Для того чтобы это имя задать, достаточно просто назначить его переменной:

```scala mdoc:silent:reset
val double = (i: Int) => i * 2
```

Теперь появилась именованная функция, назначенная переменной `double`. 
Можно использовать эту функцию так же, как используется метод:

```scala mdoc
double(2)
```

В большинстве случаев не имеет значения, является ли `double` функцией или методом; 
Scala позволяет обращаться с ними одинаково. 
За кулисами технология Scala, которая позволяет обращаться с методами так же, как с функциями, 
известна как [Eta Expansion](../functions/eta).

Эта способность беспрепятственно передавать функции в качестве переменных 
является отличительной чертой функциональных языков программирования, таких как Scala.
И, как было видно на примерах `map` и `filter`,
возможность передавать функции в другие функции помогает создавать код,
который является кратким и при этом читабельным — _выразительным_.

Вот еще несколько примеров:

```scala mdoc:reset
List("bob", "joe").map(_.toUpperCase)  
List("bob", "joe").map(_.capitalize)   
List("plum", "banana").map(_.length)   

val fruits = List("apple", "pear")
fruits.map(_.toUpperCase)     
fruits.flatMap(_.toUpperCase) 

val nums = List(5, 1, 3, 11, 7)
nums.map(_ * 2)       
nums.filter(_ > 3)    
nums.takeWhile(_ < 6) 
nums.sortWith(_ < _)  
nums.sortWith(_ > _)  
nums.takeWhile(_ < 6).sortWith(_ < _) 
```


---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/fp-functions-are-values.html)
