---
layout: docsplus
title: "Особенности методов"
prev: ../methods
next: main-methods
---

## {{page.title}}

В этом разделе представлены различные аспекты определения и вызова методов.

### Определение методов

Методы Scala имеют много особенностей, в том числе следующие: 
- Generic параметры 
- Значения параметров по умолчанию 
- Несколько групп параметров 
- Контекстные параметры 
- Параметры по имени (by name parameters)
- ...

Синтаксис простого метода выглядит следующим образом:

```scala
def methodName(param1: Type1, param2: Type2): ReturnType =
  // здесь тело метода
end methodName   // опционально, можно не указывать
```

В этом синтаксисе:
- ключевое слово `def` используется для определения метода
- для наименования методов согласно стандартам Scala используется camel case convention
- у параметров метода необходимо всегда указывать тип
- возвращаемый тип метода указывать необязательно
- методы могут состоять как только из одной строки, так и из нескольких строк
- метку окончания метода `end methodName` указывать необязательно, её рекомендуется указывать только для длинных методов

Вот два примера однострочного метода с именем `add`, который принимает два входных параметра `Int`. 
Первая версия явно показывает возвращаемый тип метода - `Int`, а вторая - нет:

```scala
def add(a: Int, b: Int): Int = a + b
def add(a: Int, b: Int) = a + b
```

У публичных методов рекомендуется всегда указывать тип возвращаемого значения.
Объявление возвращаемого типа может упростить его понимание при просмотре кода другого человека 
или своего кода спустя некоторое время.

### Вызов методов

Вызов методов прост:

```scala
val x = add(1, 2)
```

Коллекции Scala имеют десятки встроенных методов. Эти примеры показывают, как их вызывать:

```scala mdoc:reset
val x = List(1, 2, 3)
x.size
x.contains(1)
x.map(_ * 10)
```

Внимание:
- `size` не принимает аргументов и возвращает количество элементов в списке 
- метод `contains` принимает один аргумент — значение для поиска
- `map` принимает один аргумент - функцию; в данном случае в него передается анонимная функция

### Многострочные методы

Если метод длиннее одной строки, начинайте тело метода со второй строки с отступом вправо:

```scala mdoc:reset
def addThenDouble(a: Int, b: Int): Int =
  val sum = a + b
  sum * 2
addThenDouble(1, 1)  
```

В этом методе:
- `sum` — неизменяемая локальная переменная; к ней нельзя получить доступ вне метода
- последняя строка удваивает значение `sum` - именно это значение возвращается из метода

Обратите внимание, что нет необходимости в операторе `return` в конце метода. 
Поскольку почти все в Scala является выражением — то это означает, что каждая строка кода возвращает 
(или вычисляет) значение — нет необходимости использовать `return`.

Это видно на примере того же метода, но в более сжатой форме:

```scala
def addThenDouble(a: Int, b: Int): Int = (a + b) * 2
```

В теле метода можно использовать все возможности Scala: 
- `if`/`else` выражения 
- `match` выражения 
- циклы `while`
- циклы `for` и `for` выражения
- присвоение переменных 
- вызовы других методов 
- определения других методов

В качестве ещё одного примера многострочного метода, 
`getStackTraceAsString` преобразует свой входной параметр `Throwable` в правильно отформатированную строку:

```scala
def getStackTraceAsString(t: Throwable): String =
  val sw = StringWriter()
  t.printStackTrace(PrintWriter(sw))
  sw.toString
```

В этом методе:
- в первой строке переменная `sw` принимает значение нового экземпляра `StringWriter`
- вторая строка сохраняет содержимое трассировки стека в `StringWriter`
- третья строка возвращает строковое представление трассировки стека

### Параметры по умолчанию

В параметрах метода можно указывать значения по умолчанию. 
В этом примере значения по умолчанию заданы как для `timeout`, так и для `protocol`:

```scala mdoc:silent
def makeConnection(timeout: Int = 5_000, protocol: String = "http") =
  println(f"timeout = ${timeout}%d, protocol = ${protocol}%s")
```

Поскольку параметры имеют значения по умолчанию, метод можно вызвать следующими способами:

```scala mdoc
makeConnection()                
makeConnection(2_000)          
makeConnection(3_000, "https")
```

Ключевые моменты:
- в первом примере метод вызывается без аргументов, 
поэтому он использует значения параметров по умолчанию: `5_000` и `http`
- во втором примере для значения `timeout` указано `2_000` -
оно используется вместе со значением по умолчанию для `protocol`
- в третьем примере указаны значения для обоих параметров, поэтому используются именно они

Обратите внимание, что при использовании значений параметров по умолчанию создается впечатление, 
что используются три разных переопределенных метода.

### Именованные параметры

При вызове метода при желании можно использовать имена параметров. 
Например, `makeConnection` также можно вызывать следующими способами:

```scala mdoc
makeConnection(timeout=10_000)
makeConnection(protocol="https")
makeConnection(timeout=10_000, protocol="https")
makeConnection(protocol="https", timeout=10_000)
```

Именованные параметры особенно полезны, когда несколько параметров метода имеют один и тот же тип.
Без помощи IDE очень сложно понять, какие параметры установлены в значение `true` или `false`,
и поэтому код может быть трудночитаемым:

```scala
engage(true, true, true, false)
```

Гораздо более понятным выглядит использование именованных переменных:

```scala
engage(
  speedIsSet = true,
  directionIsSet = true,
  picardSaidMakeItSo = true,
  turnedOffParkingBrake = false
)
```

### Рекомендации о методах, которые не принимают параметров

Когда метод не принимает параметров, говорят, что он имеет _arity_ уровень 0 (_arity-0_). 
Аналогично, если метод принимает один параметр - это метод с _arity-1_. 

Когда создаются методы _arity-0_:
- если метод выполняет побочные эффекты, такие как вызов `println`, метод объявляется с пустыми скобками.
- если метод не выполняет побочных эффектов, например, получение размера коллекции, 
что аналогично доступу к полю в коллекции, круглые скобки опускаются.

Например, этот метод выполняет побочный эффект, поэтому он объявлен с пустыми скобками:

```scala
def speak() = println("hi")
```

При вызове метода нужно обязательно указывать круглые скобки, если он был объявлен с ними:

```scala
speak     // error: "method speak must be called with () argument"
speak()   // prints "hi"
```

Хотя это всего лишь соглашение, его соблюдение значительно улучшает читаемость кода: 
с первого взгляда становится понятно, что метод с _arity-0_ имеет побочные эффекты.

### Использование if в качестве тела метода

Поскольку выражения `if`/`else` возвращают значение, их можно использовать в качестве тела метода. 
Вот метод с именем `isTruthy`, реализующий Perl-определения `true` и `false`:

```scala mdoc:silent
def isTruthy(a: Any) =
  if a == 0 || a == "" || a == false then
    false
  else
    true
```

Примеры показывают, как работает метод:

```scala mdoc
isTruthy(0)   
isTruthy("")  
isTruthy("hi")
isTruthy(1.0) 
```

### Использование match в качестве тела метода

Довольно часто в качестве тела метода используются match-выражения.
Вот еще одна версия `isTruthy`, написанная с `match` выражением:

```scala
def isTruthy(a: Matchable) = a match
  case 0 | "" | false => false
  case _ => true
```

Этот метод работает точно так же, как и предыдущий, в котором использовалось выражение `if`/`else`. 
Вместо `Any` в качестве типа параметра используется `Matchable`, 
чтобы принять любое значение, поддерживающее сопоставление с образцом (pattern matching).

### Контроль видимости методов в классах

В классах, объектах, `trait`-ах и `enum`-ах методы Scala по умолчанию общедоступны, 
поэтому созданный здесь экземпляр `Dog` может получить доступ к методу `speak`:

```scala mdoc
class Dog:
  def speak() = println("Woof")
val d = new Dog
d.speak()
```

Также методы можно помечать как `private`. 
Это делает их закрытыми в текущем классе, поэтому их нельзя вызвать или переопределить в подклассах:

```scala
class Animal:
  private def breathe() = println("I’m breathing")
  
class Cat extends Animal:
  // this method won’t compile
  override def breathe() = println("Yo, I’m totally breathing")
```

Если необходимо сделать метод закрытым в текущем классе, но разрешить подклассам вызывать или переопределять его,
метод помечается как `protected`, как показано в примере с методом `speak`:

```scala
class Animal:
  private def breathe() = println("I’m breathing")
  def walk() =
    breathe()
    println("I’m walking")
  protected def speak() = println("Hello?")

class Cat extends Animal:
  override def speak() = println("Meow")

val cat = new Cat
cat.walk()
cat.speak()
cat.breathe()   // won’t compile because it’s private
```

Настройка `protected` означает:
- к методу (или полю) могут обращаться другие экземпляры того же класса
- метод (или поле) не виден в текущем пакете
- он доступен для подклассов

### Методы в объектах

Ранее было показано, что `trait`-ы и классы могут иметь методы. 
Ключевое слово `object` используется для создания одноэлементного класса, и `object` также может содержать методы. 
Это хороший способ сгруппировать набор "служебных" методов. 
Например, этот объект содержит набор методов, которые работают со строками:

```scala
object StringUtils:

  def truncate(s: String, length: Int): String = s.take(length)

  def lettersAndNumbersOnly_?(s: String): Boolean =
    s.matches("[a-zA-Z0-9]+")

  def containsWhitespace(s: String): Boolean =
    s.matches(".*\\s.*")

end StringUtils
```

### Расширяемые методы

Основная цель расширяемых методов (extension methods) - 
позволить добавлять новые функциональные возможности в закрытые классы. 
Представим, что у нас есть класс `Circle`, но мы не можем изменить его исходный код. 
Например, он может быть определен следующим образом в сторонней библиотеке:

```scala mdoc:silent
case class Circle(x: Double, y: Double, radius: Double)
```

Если необходимо добавить методы в этот класс, можно их определить как методы расширения, например:

```scala mdoc:silent
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
  def diameter: Double = c.radius * 2
  def area: Double = math.Pi * c.radius * c.radius
```

Ключевое слово `extension` объявляет о намерении определить один или несколько методов расширения для параметра,
заключенного в круглые скобки.
Как показано в примере выше, параметры типа `Circle` затем могут быть использованы в теле методов расширения.

Теперь, если есть экземпляр `Circle` с именем `aCircle`, можно вызвать эти методы следующим образом:

```scala mdoc
val aCircle = Circle(0.0, 0.0, 1.0)
aCircle.circumference
aCircle.diameter
aCircle.area
```

### Дополнительно

В дальнейшем будет раскрыто еще больше информации о методах, в том числе:
- вызов методов суперкласса
- определение и использование параметров по имени (by-name parameters)
- метод, который принимает функцию
- inline методы
- обработка исключений
- использование изменяемых параметров метода
- методы, которые имеют несколько групп параметров (частично применяемые функции)
- методы с generic параметрами

---

**References:**
- [Scala3 book](https://docs.scala-lang.org/scala3/book/taste-methods.html)
- [Scala3 book, Method Features](https://docs.scala-lang.org/scala3/book/methods-most.html)
