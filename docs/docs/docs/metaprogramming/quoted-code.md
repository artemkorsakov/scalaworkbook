---
layout: docsplus
title: "Quoted Code"
prev: metaprogramming/macros
next: metaprogramming/runtime-staging
---

## {{page.title}}

### Кодовые блоки

Блок кода в кавычках `'{ ... }` синтаксически похож на строковую кавычку `" ... "` 
с той разницей, что первая содержит типизированный код. 
Чтобы вставить код в другой код, можно использовать синтаксис `$expr` или `${ expr }`, 
где `expr` имеет тип `Expr[T]`.
Интуитивно понятно, что код непосредственно внутри кавычки (`'{ ... }`) сейчас не выполняется, 
в то время как код внутри склейки (`${ ... }`) оценивается и результаты встраиваются в окружающее выражение.

```scala
val msg = Expr("Hello")
val printHello = '{ print($msg) }
println(printHello.show) // print("Hello")
```

Как правило, цитаты задерживают выполнение, в то время как склейка делает это раньше окружающего кода. 
Это обобщение позволяет также придавать значение `${ ... }`, которое не находится в цитатах. 
Это оценивает код в склейках во время компиляции и помещает результат в сгенерированный код. 
Из-за некоторых технических соображений непосредственно внутри `inline` определений, 
которые называются [макросами](@DOC@metaprogramming/macros), 
разрешены только склейки верхнего уровня.

Можно написать цитату внутри цитаты, но этот шаблон не распространен при написании макросов.

### Согласованность уровней

Нельзя просто написать любой произвольный код в цитатах и в склейках, 
так как одна часть программы будет жить во время компиляции, а другая — во время выполнения. 
Рассмотрим следующий плохо сконструированный код:

```scala
def myBadCounter1(using Quotes): Expr[Int] = {
  var x = 0
  '{ x += 1; x }
}
```

Проблема с этим кодом в том, что `x` существует во время компиляции, 
но затем мы пытаемся использовать его после завершения компиляции (возможно, даже на другой машине). 
Ясно, что было бы невозможно получить доступ к его значению и обновить его.

Теперь рассмотрим двойную версию, где определяется переменная во время выполнения 
и происходит попытка получить к ней доступ во время компиляции:

```scala
def myBadCounter2(using Quotes): Expr[Int] = '{
  var x = 0
  ${ x += 1; 'x }
}
```

Ясно, что это не должно работать, так как переменная еще не существует.

Чтобы убедиться, что нельзя писать программы, которые содержат такого рода проблемы, 
виды ссылок, разрешенных в области цитат, ограничиваются.

Вводятся уровни как количество цитат за вычетом количества склеек, окружающих выражение или определение.

```scala
// level 0
'{ // level 1
  var x = 0
  ${ // level 0
    x += 1
    'x // level 1
  }
}
```

Система разрешает ссылки на глобальные определения, например, `println` на любом уровне, 
но ограничивает ссылки на локальные определения. 
Доступ к локальному определению возможен только в том случае, если оно задано на том же уровне, что и его ссылка. 
Это позволит поймать ошибки в `myBadCounter1` и `myBadCounter2`.

Несмотря на то, что нельзя ссылаться на переменную внутри цитаты, 
все же можно передать ее текущее значение через кавычку, 
подняв значение до выражения с помощью `Expr.apply`.

### Дженерики

При использовании параметров типа или других видов абстрактных типов с кодом в кавычках 
потребуется явно отслеживать некоторые из этих типов. 
Scala использует семантику стертых типов для своих дженериков. 
Это означает, что типы удаляются из программы при компиляции, 
и среде выполнения не нужно отслеживать все типы во время выполнения.

Рассмотрим следующий код:

```scala
def evalAndUse[T](x: Expr[T])(using Quotes) = '{
  val x2: T = $x // error
  ... // use x2
}
```

Здесь будет получено сообщение об ошибке, сообщающее, что не хватает контекстного параметра `Type[T]`. 
Поэтому можно легко это исправить, написав:

```scala
def evalAndUse[T](x: Expr[T])(using Type[T])(using Quotes) = '{
  val x2: T = $x
  ... // use x2
}
```

Этот код будет эквивалентен такой более подробной версии:

```scala
def evalAndUse[T](x: Expr[T])(using t: Type[T])(using Quotes) = '{
  val x2: t.Underlying = $x
  ... // use x2
}
```

Обратите внимание, что у `Type` вызывается член типа `Underlying`, который ссылается на тип, хранящийся в `Type`; 
в данном случае `t.Underlying` есть `T`. 
Даже если `Type` используется неявно, как правило, лучше оставить его контекстуальным, 
так как некоторые изменения внутри цитаты могут потребовать этого. 
Менее подробная версия обычно является лучшим способом написания типов, поскольку ее намного проще читать. 
В некоторых случаях не будет статически известен тип внутри `Type` 
и нужно будет использовать `t.Underlying` для ссылки на него.

Когда нам нужен этот дополнительный `Type` параметр?
- Когда тип является абстрактным и используется на уровне выше текущего

Когда добавляется контекстный параметр `Type` в метод, 
он либо получается из другого параметра контекста, либо неявно с помощью вызова `Type.of`:

```scala
evalAndUse(Expr(3))
// эквивалентно:
evalAndUse[Int](Expr(3))(using Type.of[Int])
```

Не каждый тип можно использовать в качестве параметра `Type.of[..]` из коробки. 
Например, нельзя восстановить абстрактные типы, которые уже были стерты:

```scala
def evalAndUse[T](x: Expr[T])(using Quotes) =
  given Type[T] = Type.of[T] // error
  '{
    val x2: T = $x
    ... // use x2
  }
```

Но можно написать более сложные типы, которые зависят от этих абстрактных типов. 
Например, если ищем или явно создаем `Type[List[T]]`, 
то системе потребуется `Type[T]` в текущем контексте для компиляции.

Хороший код должен добавлять `Types` только к параметрам контекста и никогда не использовать их явно. 
Однако явное использование полезно при отладке, хотя и достигается за счет краткости и ясности.

### ToExpr




---

**References:**
- [Scala 3 Guide](https://docs.scala-lang.org/scala3/guides/macros/quotes.html)
