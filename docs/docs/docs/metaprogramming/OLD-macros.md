---
layout: docsplus
title: "Macros"
prev: metaprogramming/compile-time-ops
next: metaprogramming/runtime-staging
---

## {{page.title}}

> При разработке макросов включите флаг опции scalac `-Xcheck-macros`, 
> чтобы иметь дополнительные проверки во время выполнения.

### Макросы: Quotes и Splices

Макросы построены на двух хорошо известных фундаментальных операциях: кавычках и склейках. 
Кавычки выражаются как `'{...}` для выражений, 
а склейки - как `${ ... }`. 
Кроме того, в кавычках или склейках можно напрямую цитировать или склеивать идентификаторы (т.е. `'e` и `$e`). 
Можно заметить сходство двух вышеупомянутых синтаксических схем со знакомым синтаксисом интерполяции строк.

```scala
println(s"Hello, $name, here is the result of 1 + 1 = ${1 + 1}")
```

При интерполяции строк мы цитируем строку, а затем вставляем в нее две другие. 
Первый, `name`, является ссылкой на значение типа `String`, а второй является арифметическим выражением, 
которое будет оцениваться с последующим соединением его строкового представления.

Кавычки и склейки в этом разделе позволяют обращаться с кодом аналогичным образом, эффективно поддерживая макросы. 
Точка входа для макросов — это встроенный метод со склейкой верхнего уровня. 
Склейка называется верхним уровнем, потому что это единственный случай, 
когда мы сталкиваемся со склейкой вне кавычки (рассматриваем как кавычку единицу компиляции в месте вызова). 
Например, в приведенном ниже коде представлен `inline` метод `assert`, 
который во время компиляции вызывает метод `assertImpl` с логическим деревом выражений в качестве аргумента. 
`assertImpl` оценивает выражение и снова печатает его в сообщении об ошибке, если оно оценивается как `false`.

```scala
import scala.quoted.*

inline def assert(inline expr: Boolean): Unit =
  ${ assertImpl('expr) }

def assertImpl(expr: Expr[Boolean])(using Quotes) = '{
  if !$expr then
    throw AssertionError(s"failed assertion: ${${ showExpr(expr) }}")
}

def showExpr(expr: Expr[Boolean])(using Quotes): Expr[String] =
  '{ [имплементация будет ниже] }
```

Если `e` является выражением, то `'{e}` представляет типизированное абстрактное синтаксическое дерево, 
представляющее `e`. 
Если `T` - это тип, то `Type.of[T]` представляет структуру типа, представляющую `T`. 
Точные определения "типизированного абстрактного синтаксического дерева" или "типовой структуры" пока не имеют значения, 
эти термины используются только для того, чтобы дать некое интуитивное восприятие. 
И наоборот, `${e}` вычисляет выражение `e`, которое должно давать типизированное абстрактное синтаксическое дерево 
или структуру типа, и встраивает результат как выражение (соответственно, тип) во включающую программу.

Цитаты могут иметь склеенные части; 
в этом случае встроенные соединения оцениваются и внедряются как часть формирования предложения.

Кавычки и склейки также могут применяться непосредственно к идентификаторам. 
Идентификатор `$x`, начинающийся с `$`, который появляется внутри выражения или типа в кавычках, 
рассматривается как склейка `${x}`. 
Аналогично, идентификатор в кавычках `'x`, который появляется внутри склейки, 
рассматривается как кавычка `'{x}`.

Кавычки и склейки двойственны друг другу. Для произвольных выражений `e` имеем:

```scala
${'{e}} = e
'{${e}} = e
```

### Типы цитат

Сигнатуры кавычек и сплайсов могут быть описаны с использованием двух основных типов:
- `Expr[T]`: абстрактные синтаксические деревья, представляющие выражения типа `T`
- `Type[T]`: нестертое представление типа `T`.

Цитирование переводит выражения типа `T` в выражения типа `Expr[T]` и переводит типы `T` в выражения типа `Type[T]`. 
Склеивание преобразует выражения типа `Expr[T]` в выражения типа `T`, а выражения типа `Type[T]` — в типы `T`.

Два типа могут быть определены в пакете [scala.quoted](https://scala-lang.org/api/3.x/scala/quoted.html) следующим образом:

```scala
package scala.quoted

sealed trait Expr[+T]
sealed trait Type[T]
```

Оба `Expr` и `Type` являются `abstract` и `sealed`, поэтому все конструкторы для этих типов предоставляются системой. 
Один из способов создания значений этих типов — заключение в кавычки, 
другой — операции подъема для конкретных типов, которые будут обсуждаться позже.

### Принцип согласованности фаз

Фундаментальный принцип согласованности фаз (PCP - _phase consistency principle_) 
регулирует доступ к свободным переменным в цитируемом и склеенном коде:
- Для любой ссылки на свободную переменную `x` количество заключенных в кавычки областей 
и количество склеенных областей между ссылкой на `x` и определением `x` должно быть равным.

Здесь `this`-ссылки считаются свободными переменными. 
С другой стороны, предполагается, что все импорты полностью расширены и `_root_` не свободная переменная. 
Так что ссылки на глобальные определения разрешены везде.

Принцип фазовой согласованности можно обосновать следующим образом: 
во-первых, предположим, что результатом работы программы `P` является некоторый текст в кавычках `'{ ... x ... }`, 
ссылающийся на свободную переменную `x` в `P`. Это можно представить, только обратившись к исходной переменной `x`. 
Следовательно, результат программы должен будет сохранять само состояние программы как одну из его частей. 
Мы не хотим этого делать, поэтому эту ситуацию нужно сделать незаконной. 
Двойственно, предположим, что часть программы верхнего уровня представляет собой вставленный текст `${ ... x ... }`, 
ссылающийся на свободную переменную `x` в `P`. 
Это означало бы, что мы ссылаемся при построении на значение `P`, которое доступно только во время выполнения `P`. 
Это, конечно, невозможно и поэтому должно быть исключено. 
Теперь оценка программы с небольшим шагом будет уменьшать кавычки и склейки в равной мере, 
используя приведенные выше правила отмены. 
Но он не будет ни создавать, ни удалять кавычки или соединения по отдельности. 
Таким образом, PCP гарантирует, что разработка программы не приведет к одной из двух нежелательных ситуаций, описанных выше.

Что касается диапазона функций, которые он охватывает, 
эта форма макросов вводит принципиальную структуру метапрограммирования, 
которая очень близка к семейству языков MetaML. 
Одно из отличий состоит в том, что в MetaML нет эквивалента PCP — 
цитируемый код в MetaML может обращаться к переменным в окружающей его среде с некоторыми ограничениями и оговорками, 
поскольку такой доступ включает сериализацию. 
Однако это не является принципиальным выигрышем в выразительности.








---

**References:**
- [Scala 3 Reference](https://docs.scala-lang.org/scala3/reference/metaprogramming/macros.html)
